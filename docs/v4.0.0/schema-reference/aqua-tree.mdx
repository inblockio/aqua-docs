---
title: "Aqua Tree"
description: "The root data structure containing revisions and metadata"
sidebar_position: 1
---


The **Aqua Tree** is the primary data structure in Aqua Protocol. It serves as the container for all revisions, their relationships, and associated metadata. An Aqua Tree represents a complete, self-contained unit that can be stored, transmitted, and verified independently.

## Why "Tree" and Not "Chain"?

The term "tree" is intentional. While revisions form chains through their `previous_hash` references, the structure supports **branching** where a single revision can have multiple children. This creates a tree topology rather than a simple linear chain.

```txt
Genesis Revision
      |
  Revision A
    /    \
Rev B    Rev C  â† Branching creates a tree
  |        |
Rev D    Rev E
```

## Structure

An Aqua Tree consists of two primary components:

### Core Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revisions` | Object | Yes | Map of revision hashes to revision objects |
| `file_index` | Object | Yes | Map of content hashes to filenames |

### Complete Structure

```json
{
  "revisions": {
    "0xabc123...": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      // ... revision-specific fields
    },
    "0xdef456...": {
      // ... another revision
    }
  },
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "document.pdf",
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "contract.txt"
  }
}
```

## Revisions Map

The `revisions` field is an object where:
- **Keys**: Verification hashes of revisions (hex strings prefixed with `0x`)
- **Values**: Complete revision objects

Each revision is indexed by its verification hash, which is computed from the revision's canonical form. This allows O(1) lookup of any revision by its hash.

### Revision Hash as Key

```json
{
  "revisions": {
    "0xabc123...": { /* revision object */ },
    "0xdef456...": { /* revision object */ }
  }
}
```

The hash serves as:
- Unique identifier for the revision
- Key for efficient lookups
- Reference in `previous_hash` fields to build the chain

## File Index

The `file_index` maps content hashes to human-readable filenames. This provides context about what content each hash represents.

See the [File Index documentation](/docs/v4.0.0/schema-reference/file-index) for detailed information.

## Complete Example

Here's a minimal Aqua Tree with a genesis object revision and a signature:

```json

{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "text/plain",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Initial Document"
      }
    },
    "0xsig123...": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "nonce": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d",
      "local_timestamp": 1704067260,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c901",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "document.txt"
  }
}

```

## Navigating the Tree

### Finding the Genesis Revision

The genesis revision has no `previous_hash` field or has `previous_hash: null`. To find it:

```typescript
const genesis = Object.values(aquaTree.revisions).find(
  rev => !rev.previous_hash
);
```

### Following the Chain

To traverse from genesis to latest:

```typescript
function getChain(aquaTree, startHash) {
  const chain = [];
  let current = aquaTree.revisions[startHash];

  while (current) {
    chain.push(current);

    // Find child (revision that references this one)
    const childHash = Object.keys(aquaTree.revisions).find(hash =>
      aquaTree.revisions[hash].previous_hash === currentHash
    );

    current = childHash ? aquaTree.revisions[childHash] : null;
  }

  return chain;
}
```

### Finding All Branches

For trees with branches:

```typescript
function findChildren(aquaTree, parentHash) {
  return Object.entries(aquaTree.revisions)
    .filter(([_, rev]) => rev.previous_hash === parentHash)
    .map(([hash, rev]) => ({ hash, revision: rev }));
}
```

## Storage and Transmission

### File Storage

Aqua Trees are typically stored as JSON files with `.aqua.json` extension:

```bash
document.aqua.json
contract-2024-01-01.aqua.json
```

### Size Considerations

- Each revision: ~200-500 bytes (depending on type and content)
- Typical Aqua Tree: 1-10 KB for simple documents
- Large trees with many revisions: Up to several MB

### Compression

For large trees, consider gzip compression:

```bash
gzip document.aqua.json
# Results in document.aqua.json.gz
```

## Validation

An Aqua Tree is valid if:

1. **All revisions have valid hashes**: Each revision's hash matches its computed verification hash
2. **Previous hashes reference existing revisions**: All `previous_hash` values point to revisions in the tree (except genesis)
3. **No circular references**: Following `previous_hash` links eventually reaches genesis
4. **Signatures are valid**: All signature revisions have valid cryptographic signatures
5. **File index matches**: All hashes in file_index correspond to content referenced in revisions

## Use Cases

### Document Management

Store a document's complete revision history:
- Genesis: Initial document creation
- Updates: Each modification as new object revision
- Signatures: Approvals from stakeholders
- Witnesses: Blockchain timestamps for legal proof

### Multi-Document Projects

Use link revisions to connect related Aqua Trees:
- Main project tree links to component trees
- Each component has its own revision history
- Verification cascades through linked trees

### Credential Issuance

Issue verifiable credentials:
- Genesis: Credential data (degree, certificate, license)
- Signature: Issuing authority signs
- Witness: Blockchain timestamp for verification
- File index: Maps credential hash to recipient identifier

## Performance Considerations

### Lookup Performance

- Hash-based lookup: O(1)
- Finding children: O(n) where n is number of revisions
- Full chain traversal: O(m) where m is chain length

### Optimization Strategies

For large trees:
1. **Index children separately**: Maintain a `children` map for each revision
2. **Cache traversals**: Store pre-computed chain paths
3. **Lazy loading**: Load only needed revisions for verification
4. **Prune old revisions**: Archive historical revisions separately

## Related Documentation

- [Revision Types](/docs/v4.0.0/schema-reference/revision/revision) - Overview of all revision types
- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Genesis and data revisions
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Cryptographic signatures
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Blockchain anchoring
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Connecting trees
- [File Index](/docs/v4.0.0/schema-reference/file-index) - Content hash mapping