<!DOCTYPE html><!--JYW95fJa52_5pkdIpCduE--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/logo/aqua-logo.png"/><link rel="stylesheet" href="/_next/static/chunks/a06cf6f745569492.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/chunks/b0e9cc9922d4f147.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/c5d17ae37620b099.js"/><script src="/_next/static/chunks/f135411802e174fe.js" async=""></script><script src="/_next/static/chunks/75d21cea9920c19c.js" async=""></script><script src="/_next/static/chunks/turbopack-dd346d0f42493b25.js" async=""></script><script src="/_next/static/chunks/eb22c92016909501.js" async=""></script><script src="/_next/static/chunks/147f1793f0357acf.js" async=""></script><script src="/_next/static/chunks/d96012bcfc98706a.js" async=""></script><script src="/_next/static/chunks/963c71eec1d89c3f.js" async=""></script><meta name="next-size-adjust" content=""/><title>Signature Revision | Aqua Protocol</title><meta name="description" content="Schema specification for Signature Revisions in Aqua Protocol v4"/><link rel="canonical" href="https://aqua-protocol.org/docs/v4.0.0/schema-reference/revision/signing-revision"/><meta property="og:title" content="Signature Revision"/><meta property="og:description" content="Schema specification for Signature Revisions in Aqua Protocol v4"/><meta property="og:url" content="https://aqua-protocol.org/docs/v4.0.0/schema-reference/revision/signing-revision"/><meta property="og:site_name" content="Documentation Platform"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Signature Revision"/><meta name="twitter:description" content="Schema specification for Signature Revisions in Aqua Protocol v4"/><link rel="icon" href="/logo/aqua-logo.png"/><link rel="apple-touch-icon" href="/apple-icon.png"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="font-sans antialiased"><div hidden=""><!--$--><!--/$--></div><!--$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="max-w-4xl mx-auto px-6 py-8"><div class="animate-pulse space-y-4"><div class="h-8 bg-gray-200 rounded w-3/4"></div><div class="h-4 bg-gray-200 rounded w-1/2"></div><div class="space-y-3 mt-8"><div class="h-4 bg-gray-200 rounded"></div><div class="h-4 bg-gray-200 rounded w-5/6"></div><div class="h-4 bg-gray-200 rounded w-4/6"></div></div></div></div><!--/$--><!--$--><!--/$--><!--/$--><script src="/_next/static/chunks/c5d17ae37620b099.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"ConfigProvider\"]\n3:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"TabProvider\"]\n4:I[339756,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"default\"]\n5:I[837457,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"default\"]\n6:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"VersionNotFound\"]\nb:I[168027,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"default\"]\n:HL[\"/_next/static/chunks/a06cf6f745569492.css\",\"style\"]\n:HL[\"/_next/static/chunks/b0e9cc9922d4f147.css\",\"style\"]\n:HL[\"/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"JYW95fJa52-5pkdIpCduE\",\"c\":[\"\",\"docs\",\"v4.0.0\",\"schema-reference\",\"revision\",\"signing-revision\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"docs\",{\"children\":[[\"version\",\"v4.0.0\",\"d\"],{\"children\":[[\"slug\",\"schema-reference/revision/signing-revision\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/a06cf6f745569492.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/b0e9cc9922d4f147.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/eb22c92016909501.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/147f1793f0357acf.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"font-sans antialiased\",\"children\":[\"$\",\"$L2\",null,{\"config\":{\"site\":{\"title\":\"Aqua Protocol\",\"description\":\"Aqua\",\"baseUrl\":\"/\",\"language\":\"en\",\"url\":\"https://aqua-protocol.org\",\"organizationName\":\"inblockio\",\"projectName\":\"aqua-docs\",\"activeVersion\":\"v4.0.0\",\"favicon\":\"/logo/aqua-logo.png\",\"logo\":\"/logo/aqua-logo.png\"},\"theme\":{\"defaultMode\":\"system\",\"respectPrefersColorScheme\":true},\"navigation\":{\"showSidebar\":true,\"collapsibleSidebar\":true,\"showBreadcrumbs\":true,\"showTableOfContents\":true,\"tocPosition\":\"right\",\"tocMaxDepth\":3},\"search\":{\"enabled\":false,\"provider\":\"meilisearch\",\"placeholder\":\"Search documentation...\",\"meilisearch\":{\"host\":\"http://localhost:7700\",\"apiKey\":\"aSampleMasterKey\",\"indexName\":\"docs\"}},\"features\":{\"showLastUpdated\":true,\"showReadingTime\":true,\"showAuthors\":false,\"showTags\":true,\"versioning\":true,\"i18n\":false,\"editUrl\":\"https://github.com/inblockio/aqua-docs/edit/main/docs\"},\"$schema\":\"./lib/config.types.ts\",\"social\":{\"github\":\"https://github.com/inblockio\",\"twitter\":\"https://twitter.com/inblockio\",\"custom\":[{\"label\":\"Website\",\"href\":\"https://dev.inblock.io\"}]},\"analytics\":{\"googleAnalytics\":\"\",\"plausible\":\"\"},\"footer\":{\"copyright\":\"Copyright ¬© 2024 Aqua. All rights reserved.\",\"links\":[{\"title\":\"Documentation\",\"items\":[{\"label\":\"Getting Started\",\"href\":\"/docs/v1.0.0/getting-started\"},{\"label\":\"API Reference\",\"href\":\"/docs/v1.0.0/api\"}]},{\"title\":\"Community\",\"items\":[{\"label\":\"GitHub\",\"href\":\"https://github.com/inblockio/aqua-docs\"},{\"label\":\"Discord\",\"href\":\"#\"}]}]},\"banner\":{\"enabled\":false,\"message\":\"üéâ This is a development version. Some features may not work as expected.\",\"type\":\"error\",\"dismissible\":true},\"env\":{},\"deployment\":{\"target\":\"github-pages\",\"basePath\":\"\",\"customDomain\":true}},\"children\":[\"$\",\"$L3\",null,{\"defaultTab\":\"\",\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L6\",null,{}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":\"$L7\",\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"$L8\",{},null,false,false]},[\"$L9\",[],[]],false,false]},null,false,false]},null,false,false]},null,false,false],\"$La\",false]],\"m\":\"$undefined\",\"G\":[\"$b\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"d:I[897367,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"OutletBoundary\"]\ne:\"$Sreact.suspense\"\n10:I[897367,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"ViewportBoundary\"]\n12:I[897367,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"MetadataBoundary\"]\n7:[\"$\",\"$L5\",null,{}]\n8:[\"$\",\"$1\",\"c\",{\"children\":[\"$Lc\",null,[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$e\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@f\"}]}]]}]\n9:[\"$\",\"div\",\"l\",{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900\"}]}]\na:[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L10\",null,{\"children\":\"$L11\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$L12\",null,{\"children\":[\"$\",\"$e\",null,{\"name\":\"Next.Metadata\",\"children\":\"$L13\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]\n"])</script><script>self.__next_f.push([1,"14:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"DocLoading\"]\n15:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"DocLayoutWrapper\"]\n16:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"Header\"]\n17:T1ef1,"])</script><script>self.__next_f.push([1,"\n\nThe **Aqua Tree** is the primary data structure in Aqua Protocol. It serves as the container for all revisions, their relationships, and associated metadata. An Aqua Tree represents a complete, self-contained unit that can be stored, transmitted, and verified independently.\n\n## Why \"Tree\" and Not \"Chain\"?\n\nThe term \"tree\" is intentional. While revisions form chains through their `previous_hash` references, the structure supports **branching** where a single revision can have multiple children. This creates a tree topology rather than a simple linear chain.\n\n```txt\nGenesis Revision\n      |\n  Revision A\n    /    \\\nRev B    Rev C  ‚Üê Branching creates a tree\n  |        |\nRev D    Rev E\n```\n\n## Structure\n\nAn Aqua Tree consists of two primary components:\n\n### Core Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revisions` | Object | Yes | Map of revision hashes to revision objects |\n| `file_index` | Object | Yes | Map of content hashes to filenames |\n\n### Complete Structure\n\n```json\n{\n  \"revisions\": {\n    \"0xabc123...\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      // ... revision-specific fields\n    },\n    \"0xdef456...\": {\n      // ... another revision\n    }\n  },\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"document.pdf\",\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"contract.txt\"\n  }\n}\n```\n\n## Revisions Map\n\nThe `revisions` field is an object where:\n- **Keys**: Verification hashes of revisions (hex strings prefixed with `0x`)\n- **Values**: Complete revision objects\n\nEach revision is indexed by its verification hash, which is computed from the revision's canonical form. This allows O(1) lookup of any revision by its hash.\n\n### Revision Hash as Key\n\n```json\n{\n  \"revisions\": {\n    \"0xabc123...\": { /* revision object */ },\n    \"0xdef456...\": { /* revision object */ }\n  }\n}\n```\n\nThe hash serves as:\n- Unique identifier for the revision\n- Key for efficient lookups\n- Reference in `previous_hash` fields to build the chain\n\n## File Index\n\nThe `file_index` maps content hashes to human-readable filenames. This provides context about what content each hash represents.\n\nSee the [File Index documentation](/schema_reference/file_index) for detailed information.\n\n## Complete Example\n\nHere's a minimal Aqua Tree with a genesis object revision and a signature:\n\n```json\n\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"text/plain\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Initial Document\"\n      }\n    },\n    \"0xsig123...\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"nonce\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d\",\n      \"local_timestamp\": 1704067260,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c901\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"document.txt\"\n  }\n}\n\n```\n\n## Navigating the Tree\n\n### Finding the Genesis Revision\n\nThe genesis revision has no `previous_hash` field or has `previous_hash: null`. To find it:\n\n```typescript\nconst genesis = Object.values(aquaTree.revisions).find(\n  rev =\u003e !rev.previous_hash\n);\n```\n\n### Following the Chain\n\nTo traverse from genesis to latest:\n\n```typescript\nfunction getChain(aquaTree, startHash) {\n  const chain = [];\n  let current = aquaTree.revisions[startHash];\n\n  while (current) {\n    chain.push(current);\n\n    // Find child (revision that references this one)\n    const childHash = Object.keys(aquaTree.revisions).find(hash =\u003e\n      aquaTree.revisions[hash].previous_hash === currentHash\n    );\n\n    current = childHash ? aquaTree.revisions[childHash] : null;\n  }\n\n  return chain;\n}\n```\n\n### Finding All Branches\n\nFor trees with branches:\n\n```typescript\nfunction findChildren(aquaTree, parentHash) {\n  return Object.entries(aquaTree.revisions)\n    .filter(([_, rev]) =\u003e rev.previous_hash === parentHash)\n    .map(([hash, rev]) =\u003e ({ hash, revision: rev }));\n}\n```\n\n## Storage and Transmission\n\n### File Storage\n\nAqua Trees are typically stored as JSON files with `.aqua.json` extension:\n\n```bash\ndocument.aqua.json\ncontract-2024-01-01.aqua.json\n```\n\n### Size Considerations\n\n- Each revision: ~200-500 bytes (depending on type and content)\n- Typical Aqua Tree: 1-10 KB for simple documents\n- Large trees with many revisions: Up to several MB\n\n### Compression\n\nFor large trees, consider gzip compression:\n\n```bash\ngzip document.aqua.json\n# Results in document.aqua.json.gz\n```\n\n## Validation\n\nAn Aqua Tree is valid if:\n\n1. **All revisions have valid hashes**: Each revision's hash matches its computed verification hash\n2. **Previous hashes reference existing revisions**: All `previous_hash` values point to revisions in the tree (except genesis)\n3. **No circular references**: Following `previous_hash` links eventually reaches genesis\n4. **Signatures are valid**: All signature revisions have valid cryptographic signatures\n5. **File index matches**: All hashes in file_index correspond to content referenced in revisions\n\n## Use Cases\n\n### Document Management\n\nStore a document's complete revision history:\n- Genesis: Initial document creation\n- Updates: Each modification as new object revision\n- Signatures: Approvals from stakeholders\n- Witnesses: Blockchain timestamps for legal proof\n\n### Multi-Document Projects\n\nUse link revisions to connect related Aqua Trees:\n- Main project tree links to component trees\n- Each component has its own revision history\n- Verification cascades through linked trees\n\n### Credential Issuance\n\nIssue verifiable credentials:\n- Genesis: Credential data (degree, certificate, license)\n- Signature: Issuing authority signs\n- Witness: Blockchain timestamp for verification\n- File index: Maps credential hash to recipient identifier\n\n## Performance Considerations\n\n### Lookup Performance\n\n- Hash-based lookup: O(1)\n- Finding children: O(n) where n is number of revisions\n- Full chain traversal: O(m) where m is chain length\n\n### Optimization Strategies\n\nFor large trees:\n1. **Index children separately**: Maintain a `children` map for each revision\n2. **Cache traversals**: Store pre-computed chain paths\n3. **Lazy loading**: Load only needed revisions for verification\n4. **Prune old revisions**: Archive historical revisions separately\n\n## Related Documentation\n\n- [Revision Types](/schema_reference/revision) - Overview of all revision types\n- [Object Revision](/schema_reference/object_revision) - Genesis and data revisions\n- [Signature Revision](/schema_reference/signing_revision) - Cryptographic signatures\n- [Witness Revision](/schema_reference/witness_revision) - Blockchain anchoring\n- [Link Revision](/schema_reference/link_revision) - Connecting trees\n- [File Index](/schema_reference/file_index) - Content hash mapping"])</script><script>self.__next_f.push([1,"18:T1ef1,"])</script><script>self.__next_f.push([1,"\n\nThe **Aqua Tree** is the primary data structure in Aqua Protocol. It serves as the container for all revisions, their relationships, and associated metadata. An Aqua Tree represents a complete, self-contained unit that can be stored, transmitted, and verified independently.\n\n## Why \"Tree\" and Not \"Chain\"?\n\nThe term \"tree\" is intentional. While revisions form chains through their `previous_hash` references, the structure supports **branching** where a single revision can have multiple children. This creates a tree topology rather than a simple linear chain.\n\n```txt\nGenesis Revision\n      |\n  Revision A\n    /    \\\nRev B    Rev C  ‚Üê Branching creates a tree\n  |        |\nRev D    Rev E\n```\n\n## Structure\n\nAn Aqua Tree consists of two primary components:\n\n### Core Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revisions` | Object | Yes | Map of revision hashes to revision objects |\n| `file_index` | Object | Yes | Map of content hashes to filenames |\n\n### Complete Structure\n\n```json\n{\n  \"revisions\": {\n    \"0xabc123...\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      // ... revision-specific fields\n    },\n    \"0xdef456...\": {\n      // ... another revision\n    }\n  },\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"document.pdf\",\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"contract.txt\"\n  }\n}\n```\n\n## Revisions Map\n\nThe `revisions` field is an object where:\n- **Keys**: Verification hashes of revisions (hex strings prefixed with `0x`)\n- **Values**: Complete revision objects\n\nEach revision is indexed by its verification hash, which is computed from the revision's canonical form. This allows O(1) lookup of any revision by its hash.\n\n### Revision Hash as Key\n\n```json\n{\n  \"revisions\": {\n    \"0xabc123...\": { /* revision object */ },\n    \"0xdef456...\": { /* revision object */ }\n  }\n}\n```\n\nThe hash serves as:\n- Unique identifier for the revision\n- Key for efficient lookups\n- Reference in `previous_hash` fields to build the chain\n\n## File Index\n\nThe `file_index` maps content hashes to human-readable filenames. This provides context about what content each hash represents.\n\nSee the [File Index documentation](/schema_reference/file_index) for detailed information.\n\n## Complete Example\n\nHere's a minimal Aqua Tree with a genesis object revision and a signature:\n\n```json\n\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"text/plain\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Initial Document\"\n      }\n    },\n    \"0xsig123...\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"nonce\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d\",\n      \"local_timestamp\": 1704067260,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c901\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"document.txt\"\n  }\n}\n\n```\n\n## Navigating the Tree\n\n### Finding the Genesis Revision\n\nThe genesis revision has no `previous_hash` field or has `previous_hash: null`. To find it:\n\n```typescript\nconst genesis = Object.values(aquaTree.revisions).find(\n  rev =\u003e !rev.previous_hash\n);\n```\n\n### Following the Chain\n\nTo traverse from genesis to latest:\n\n```typescript\nfunction getChain(aquaTree, startHash) {\n  const chain = [];\n  let current = aquaTree.revisions[startHash];\n\n  while (current) {\n    chain.push(current);\n\n    // Find child (revision that references this one)\n    const childHash = Object.keys(aquaTree.revisions).find(hash =\u003e\n      aquaTree.revisions[hash].previous_hash === currentHash\n    );\n\n    current = childHash ? aquaTree.revisions[childHash] : null;\n  }\n\n  return chain;\n}\n```\n\n### Finding All Branches\n\nFor trees with branches:\n\n```typescript\nfunction findChildren(aquaTree, parentHash) {\n  return Object.entries(aquaTree.revisions)\n    .filter(([_, rev]) =\u003e rev.previous_hash === parentHash)\n    .map(([hash, rev]) =\u003e ({ hash, revision: rev }));\n}\n```\n\n## Storage and Transmission\n\n### File Storage\n\nAqua Trees are typically stored as JSON files with `.aqua.json` extension:\n\n```bash\ndocument.aqua.json\ncontract-2024-01-01.aqua.json\n```\n\n### Size Considerations\n\n- Each revision: ~200-500 bytes (depending on type and content)\n- Typical Aqua Tree: 1-10 KB for simple documents\n- Large trees with many revisions: Up to several MB\n\n### Compression\n\nFor large trees, consider gzip compression:\n\n```bash\ngzip document.aqua.json\n# Results in document.aqua.json.gz\n```\n\n## Validation\n\nAn Aqua Tree is valid if:\n\n1. **All revisions have valid hashes**: Each revision's hash matches its computed verification hash\n2. **Previous hashes reference existing revisions**: All `previous_hash` values point to revisions in the tree (except genesis)\n3. **No circular references**: Following `previous_hash` links eventually reaches genesis\n4. **Signatures are valid**: All signature revisions have valid cryptographic signatures\n5. **File index matches**: All hashes in file_index correspond to content referenced in revisions\n\n## Use Cases\n\n### Document Management\n\nStore a document's complete revision history:\n- Genesis: Initial document creation\n- Updates: Each modification as new object revision\n- Signatures: Approvals from stakeholders\n- Witnesses: Blockchain timestamps for legal proof\n\n### Multi-Document Projects\n\nUse link revisions to connect related Aqua Trees:\n- Main project tree links to component trees\n- Each component has its own revision history\n- Verification cascades through linked trees\n\n### Credential Issuance\n\nIssue verifiable credentials:\n- Genesis: Credential data (degree, certificate, license)\n- Signature: Issuing authority signs\n- Witness: Blockchain timestamp for verification\n- File index: Maps credential hash to recipient identifier\n\n## Performance Considerations\n\n### Lookup Performance\n\n- Hash-based lookup: O(1)\n- Finding children: O(n) where n is number of revisions\n- Full chain traversal: O(m) where m is chain length\n\n### Optimization Strategies\n\nFor large trees:\n1. **Index children separately**: Maintain a `children` map for each revision\n2. **Cache traversals**: Store pre-computed chain paths\n3. **Lazy loading**: Load only needed revisions for verification\n4. **Prune old revisions**: Archive historical revisions separately\n\n## Related Documentation\n\n- [Revision Types](/schema_reference/revision) - Overview of all revision types\n- [Object Revision](/schema_reference/object_revision) - Genesis and data revisions\n- [Signature Revision](/schema_reference/signing_revision) - Cryptographic signatures\n- [Witness Revision](/schema_reference/witness_revision) - Blockchain anchoring\n- [Link Revision](/schema_reference/link_revision) - Connecting trees\n- [File Index](/schema_reference/file_index) - Content hash mapping"])</script><script>self.__next_f.push([1,"19:T1b19,"])</script><script>self.__next_f.push([1,"\n\n\n**Aqua Protocol** is an open, private, and decentralized solution for data accountability and governance. Built with modern cryptographic standards, Aqua enables you to verify data integrity and provenance without relying on centralized authorities.\n\n\u003cCallout type=\"info\"\u003e\n**Powered by Cryptography, Not Blockchain**\n\nAqua Protocol is made possible by crypto as in _cryptography_! While it can use Ethereum for timestamping, the protocol itself neither is nor requires blockchain technology. It's a privacy-preserving, open-source protocol built on modern cryptographic methods.\n\n\u003cBadge icon=\"circle-check\" color=\"green\"\u003e\n Account \u0026 Verify Data in Seconds\n\u003c/Badge\u003e\n\u003c/Callout\u003e\n\n\n\n## What is Aqua Protocol?\n\nThe Aqua Protocol is a foundational framework for building distributed trust networks. By leveraging hash-chains, cryptographic signatures, and optional blockchain timestamping, Aqua enables scalable, trustless verification of data integrity and provenance. It empowers developers and innovators to create applications that certify, attest, and secure data in an open and decentralized way.\n\n\u003cCard title=\"Core Idea\"\n  icon=\"rocket\"\n  href=\"/quickstart\"\n  horizontal\n\u003e\n  Building trust through cryptographic proof and verifiable data structures.\n\u003c/Card\u003e\n\nTrust can be built by relying on hashing and encryption mechanisms or by delegating to a mutually trusted party. Aqua Protocol handles both scenarios, giving you flexibility in how you establish and verify trust.\n\n\n\n## How It Works\n\nAt its core, Aqua creates portable hash-chains called **AquaTrees** that record a gapless history of data revisions. These trees can be timestamped on Ethereum for immutability, exchanged across services, and verified automatically. Whether securing documents, systems, or identities, Aqua liberates the certification process from institutional gatekeepers, making trust accessible through open cryptographic standards.\n\n### Key Features\n\n- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is immediately detectable\n- **Multi-Party Signatures**: Collect signatures from multiple parties for authentication and non-repudiation\n- **Blockchain Timestamping**: Optional anchoring to Ethereum, Nostr, or TSA for provable timestamps\n- **Portable Verification**: AquaTrees can be exchanged, stored, and verified anywhere\n- **Privacy-Preserving**: Only hashes are stored on-chain, keeping your data private\n\n## Try Aquafier\n\nWant to see Aqua Protocol in action? Try **Aquafier**, our reference implementation that lets you upload, verify, and notarize any file:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Aquafier (Production)\"\n    icon=\"globe\"\n    href=\"https://aquafier.inblock.io\"\n  \u003e\n    Try the live demo - upload and notarize files instantly\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Aquafier (Testing)\"\n    icon=\"flask\"\n    href=\"https://dev.inblock.io\"\n  \u003e\n    Experiment in the development environment\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Getting Started\n\n\u003cCallout type=\"tip\"\u003eNew to Aqua Protocol? Here are the best places to start:\u003c/Callout\u003e\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Quick Start Guide\"\n    icon=\"rocket\"\n    href=\"/quickstart\"\n  \u003e\n    Get up and running with Aqua Protocol in minutes\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Understand the Schema\"\n    icon=\"brain\"\n    href=\"/schema_reference/introduction\"\n  \u003e\n    Learn about the components that make up the protocol\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Explore Examples\"\n    icon=\"code\"\n    href=\"https://github.com/inblockio/aqua-examples\"\n  \u003e\n    Browse curated examples in different programming languages\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Developer Tools\"\n    icon=\"wrench\"\n    href=\"/dev_tools/aqua_sdk\"\n  \u003e\n    Get started with our SDK, CLI, and development tools\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Use Cases\"\n    icon=\"lightbulb\"\n    href=\"/use_cases/introduction\"\n  \u003e\n    Discover real-world applications and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"View the Code\"\n    icon=\"github\"\n    href=\"https://github.com/inblockio\"\n  \u003e\n    Dive into the source code and contribute\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## The Vision of Aqua\n\nAqua Protocol is still evolving, and we're discovering the full scope of its potential. Here's what Aqua represents:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"An Open Framework\"\n    icon=\"book-open\"\n  \u003e\n    Enabling private, decentralized solutions for general data notarization and verification\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Verifiable Data Structure\"\n    icon=\"shield-check\"\n  \u003e\n    Linking and certifying data with cryptographic precision through AquaTrees\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Protocol for Provenance\"\n    icon=\"fingerprint\"\n  \u003e\n    Ensuring clear attribution and integrity of data origins across systems\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Foundation for Trust\"\n    icon=\"handshake\"\n  \u003e\n    Powering distributed networks where trust is built-in, not assumed\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Current Version\n\n**Aqua Protocol v4** (Beta) - Built with Rust, featuring:\n- Template system with JSON Schema validation\n- Enhanced revision types and canonicalization\n- Cross-platform support via WASM\n- Improved scalability and flexibility\n\n**Aqua Protocol v3** (Stable) - Production-ready JavaScript/TypeScript SDK\n\n\u003cCallout type=\"info\"\u003e\nWe're excited to see where this journey takes us and invite you to explore, build, and contribute to the future of decentralized trust with Aqua Protocol!\n\u003c/Callout\u003e\n\n## Community \u0026 Contributions\n\nAqua Protocol is open source and community-driven. We welcome:\n\n- **Feedback**: Share your thoughts and suggestions\n- **Bug Reports**: Help us improve by reporting issues\n- **Code Contributions**: Submit pull requests and improvements\n- **Documentation**: Help make Aqua more accessible\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"GitHub Repositories\"\n    icon=\"github\"\n    href=\"https://github.com/inblockio\"\n  \u003e\n    Browse our open-source code and contribute\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Example Projects\"\n    icon=\"code-branch\"\n    href=\"https://github.com/inblockio/aqua-examples\"\n  \u003e\n    Explore complete examples and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Follow Updates\"\n    icon=\"twitter\"\n    href=\"https://x.com/inblockio\"\n  \u003e\n    Stay updated with announcements and progress\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Get Support\"\n    icon=\"envelope\"\n    href=\"mailto:info@inblock.io\"\n  \u003e\n    Need help? Reach out to our team\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Next Steps\n\nReady to dive deeper?\n\n1. **Start Building**: Follow the [Quick Start Guide](/quickstart) to create your first Aqua chain\n2. **Understand the Protocol**: Read the [Schema Reference](/schema_reference/introduction) for technical details\n3. **Explore Use Cases**: See how others are using Aqua in [real-world applications](/use_cases/introduction)\n4. **Join the Community**: Connect with developers on [GitHub](https://github.com/inblockio)\n\n---\n\n\u003cCallout type=\"info\"\u003e\n**Need Help?**\n\nEmail us at [info@inblock.io](mailto:info@inblock.io) to talk to our team, or open an issue on GitHub for technical questions.\n\u003c/Callout\u003e\n\n\n"])</script><script>self.__next_f.push([1,"1a:T1b19,"])</script><script>self.__next_f.push([1,"\n\n\n**Aqua Protocol** is an open, private, and decentralized solution for data accountability and governance. Built with modern cryptographic standards, Aqua enables you to verify data integrity and provenance without relying on centralized authorities.\n\n\u003cCallout type=\"info\"\u003e\n**Powered by Cryptography, Not Blockchain**\n\nAqua Protocol is made possible by crypto as in _cryptography_! While it can use Ethereum for timestamping, the protocol itself neither is nor requires blockchain technology. It's a privacy-preserving, open-source protocol built on modern cryptographic methods.\n\n\u003cBadge icon=\"circle-check\" color=\"green\"\u003e\n Account \u0026 Verify Data in Seconds\n\u003c/Badge\u003e\n\u003c/Callout\u003e\n\n\n\n## What is Aqua Protocol?\n\nThe Aqua Protocol is a foundational framework for building distributed trust networks. By leveraging hash-chains, cryptographic signatures, and optional blockchain timestamping, Aqua enables scalable, trustless verification of data integrity and provenance. It empowers developers and innovators to create applications that certify, attest, and secure data in an open and decentralized way.\n\n\u003cCard title=\"Core Idea\"\n  icon=\"rocket\"\n  href=\"/quickstart\"\n  horizontal\n\u003e\n  Building trust through cryptographic proof and verifiable data structures.\n\u003c/Card\u003e\n\nTrust can be built by relying on hashing and encryption mechanisms or by delegating to a mutually trusted party. Aqua Protocol handles both scenarios, giving you flexibility in how you establish and verify trust.\n\n\n\n## How It Works\n\nAt its core, Aqua creates portable hash-chains called **AquaTrees** that record a gapless history of data revisions. These trees can be timestamped on Ethereum for immutability, exchanged across services, and verified automatically. Whether securing documents, systems, or identities, Aqua liberates the certification process from institutional gatekeepers, making trust accessible through open cryptographic standards.\n\n### Key Features\n\n- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is immediately detectable\n- **Multi-Party Signatures**: Collect signatures from multiple parties for authentication and non-repudiation\n- **Blockchain Timestamping**: Optional anchoring to Ethereum, Nostr, or TSA for provable timestamps\n- **Portable Verification**: AquaTrees can be exchanged, stored, and verified anywhere\n- **Privacy-Preserving**: Only hashes are stored on-chain, keeping your data private\n\n## Try Aquafier\n\nWant to see Aqua Protocol in action? Try **Aquafier**, our reference implementation that lets you upload, verify, and notarize any file:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Aquafier (Production)\"\n    icon=\"globe\"\n    href=\"https://aquafier.inblock.io\"\n  \u003e\n    Try the live demo - upload and notarize files instantly\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Aquafier (Testing)\"\n    icon=\"flask\"\n    href=\"https://dev.inblock.io\"\n  \u003e\n    Experiment in the development environment\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Getting Started\n\n\u003cCallout type=\"tip\"\u003eNew to Aqua Protocol? Here are the best places to start:\u003c/Callout\u003e\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Quick Start Guide\"\n    icon=\"rocket\"\n    href=\"/quickstart\"\n  \u003e\n    Get up and running with Aqua Protocol in minutes\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Understand the Schema\"\n    icon=\"brain\"\n    href=\"/schema_reference/introduction\"\n  \u003e\n    Learn about the components that make up the protocol\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Explore Examples\"\n    icon=\"code\"\n    href=\"https://github.com/inblockio/aqua-examples\"\n  \u003e\n    Browse curated examples in different programming languages\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Developer Tools\"\n    icon=\"wrench\"\n    href=\"/dev_tools/aqua_sdk\"\n  \u003e\n    Get started with our SDK, CLI, and development tools\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Use Cases\"\n    icon=\"lightbulb\"\n    href=\"/use_cases/introduction\"\n  \u003e\n    Discover real-world applications and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"View the Code\"\n    icon=\"github\"\n    href=\"https://github.com/inblockio\"\n  \u003e\n    Dive into the source code and contribute\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## The Vision of Aqua\n\nAqua Protocol is still evolving, and we're discovering the full scope of its potential. Here's what Aqua represents:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"An Open Framework\"\n    icon=\"book-open\"\n  \u003e\n    Enabling private, decentralized solutions for general data notarization and verification\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Verifiable Data Structure\"\n    icon=\"shield-check\"\n  \u003e\n    Linking and certifying data with cryptographic precision through AquaTrees\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Protocol for Provenance\"\n    icon=\"fingerprint\"\n  \u003e\n    Ensuring clear attribution and integrity of data origins across systems\n  \u003c/Card\u003e\n\n  \u003cCard title=\"A Foundation for Trust\"\n    icon=\"handshake\"\n  \u003e\n    Powering distributed networks where trust is built-in, not assumed\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Current Version\n\n**Aqua Protocol v4** (Beta) - Built with Rust, featuring:\n- Template system with JSON Schema validation\n- Enhanced revision types and canonicalization\n- Cross-platform support via WASM\n- Improved scalability and flexibility\n\n**Aqua Protocol v3** (Stable) - Production-ready JavaScript/TypeScript SDK\n\n\u003cCallout type=\"info\"\u003e\nWe're excited to see where this journey takes us and invite you to explore, build, and contribute to the future of decentralized trust with Aqua Protocol!\n\u003c/Callout\u003e\n\n## Community \u0026 Contributions\n\nAqua Protocol is open source and community-driven. We welcome:\n\n- **Feedback**: Share your thoughts and suggestions\n- **Bug Reports**: Help us improve by reporting issues\n- **Code Contributions**: Submit pull requests and improvements\n- **Documentation**: Help make Aqua more accessible\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"GitHub Repositories\"\n    icon=\"github\"\n    href=\"https://github.com/inblockio\"\n  \u003e\n    Browse our open-source code and contribute\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Example Projects\"\n    icon=\"code-branch\"\n    href=\"https://github.com/inblockio/aqua-examples\"\n  \u003e\n    Explore complete examples and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Follow Updates\"\n    icon=\"twitter\"\n    href=\"https://x.com/inblockio\"\n  \u003e\n    Stay updated with announcements and progress\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Get Support\"\n    icon=\"envelope\"\n    href=\"mailto:info@inblock.io\"\n  \u003e\n    Need help? Reach out to our team\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Next Steps\n\nReady to dive deeper?\n\n1. **Start Building**: Follow the [Quick Start Guide](/quickstart) to create your first Aqua chain\n2. **Understand the Protocol**: Read the [Schema Reference](/schema_reference/introduction) for technical details\n3. **Explore Use Cases**: See how others are using Aqua in [real-world applications](/use_cases/introduction)\n4. **Join the Community**: Connect with developers on [GitHub](https://github.com/inblockio)\n\n---\n\n\u003cCallout type=\"info\"\u003e\n**Need Help?**\n\nEmail us at [info@inblock.io](mailto:info@inblock.io) to talk to our team, or open an issue on GitHub for technical questions.\n\u003c/Callout\u003e\n\n\n"])</script><script>self.__next_f.push([1,"1b:T2e36,"])</script><script>self.__next_f.push([1,"\n## Choose Your SDK\n\n\u003cTabs defaultValue=\"js\"\u003e\n  \u003cTab label=\"js\"\u003e\n    **Stable** - Production-ready SDK for Node.js, Web, and React Native\n\n    Best for: Web applications, existing JavaScript projects\n  \u003c/Tab\u003e\n\n  \u003cTab label=\"rust\"\u003e\n    **Beta** - Template system, WASM support, cross-platform\n\n    Best for: New projects, performance-critical applications\n  \u003c/Tab\u003e\n\u003c/Tabs\u003e\n\n---\n\n## JavaScript/TypeScript Quick Start (v3)\n\n\u003cCallout type=\"info\"\u003e\n### Prerequisites\n- Node.js version 19 or higher\n- npm, yarn, or pnpm package manager\n\u003c/Callout \u003e\n\n\u003cCallout type=\"note\"\u003e\nWe recommend using TypeScript to enjoy type definitions and better development experience.\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Install the SDK\"\u003e\n    Create a new project or add to an existing one:\n\n    ```bash\n    # Create new project (optional)\n    mkdir my-aqua-project\n    cd my-aqua-project\n    npm init -y\n\n    # Install Aqua SDK\n    npm install aqua-js-sdk\n\n    # For TypeScript projects, also install type support\n    npm install --save-dev typescript @types/node\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Create Your First Aqua Chain\"\u003e\n    Create a file called `index.ts` (or `index.js`):\n\n    ```typescript\n    import Aquafier, { FileObject } from 'aqua-js-sdk';\n\n    async function main() {\n        // Initialize Aquafier\n        const aquafier = new Aquafier();\n\n        // Create a file object to notarize\n        const fileObject: FileObject = {\n            fileName: \"hello.txt\",\n            fileContent: \"Hello, Aqua Protocol!\",\n            path: \"./hello.txt\"\n        };\n\n        // Create genesis revision (notarize the file)\n        console.log(\"Creating Aqua chain...\");\n        const result = await aquafier.createGenesisRevision(fileObject);\n\n        if (result.isOk()) {\n            console.log(\"‚úì Success! Aqua chain created.\");\n            console.log(\"Aqua Tree:\", JSON.stringify(result.data.aquaTree, null, 2));\n\n            // The aquaTree contains your notarized file\n            const aquaTree = result.data.aquaTree;\n            console.log(\"\\nYou can now:\");\n            console.log(\"- Sign this chain\");\n            console.log(\"- Witness it on blockchain\");\n            console.log(\"- Verify it anytime\");\n        } else {\n            console.error(\"‚úó Error:\", result.error);\n        }\n    }\n\n    main().catch(console.error);\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Run Your Code\"\u003e\n    ```bash\n    # For TypeScript\n    npx tsx index.ts\n\n    # Or compile and run\n    npx tsc index.ts\n    node index.js\n\n    # For plain JavaScript\n    node index.js\n    ```\n\n    You should see output showing your Aqua chain was created successfully!\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Next: Add a Signature (Optional)\"\u003e\n    Extend your code to add a cryptographic signature:\n\n    ```typescript\n    // ... after creating genesis ...\n\n    if (result.isOk()) {\n        const aquaTree = result.data.aquaTree;\n\n        // Sign with MetaMask (will prompt in browser)\n        const wrapper = {\n            aquaTree: aquaTree,\n            fileObject: fileObject,\n            revision: \"\"\n        };\n\n        console.log(\"\\nAdding signature...\");\n        const signedResult = await aquafier.signAquaTree(\n            wrapper,\n            \"metamask\",  // or \"cli\", \"did\", \"p12\"\n            {},          // credentials\n            true         // auto-increment\n        );\n\n        if (signedResult.isOk()) {\n            console.log(\"‚úì Signature added!\");\n        }\n    }\n    ```\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\n---\n\n## Rust Quick Start (v4)\n\n\u003cCallout type=\"info\"\u003e\n\n### Prerequisites\n- Rust 1.70 or higher\n- Cargo package manager\n\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Create a New Project\"\u003e\n    ```bash\n    # Create a new Rust binary project\n    cargo new my-aqua-project\n    cd my-aqua-project\n\n    # Or for a library\n    cargo new --lib my-aqua-lib\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Add Aqua SDK Dependency\"\u003e\n    Add the Aqua SDK to your `Cargo.toml`:\n\n    ```toml\n    [dependencies]\n    aqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }\n    tokio = { version = \"1\", features = [\"full\"] }\n    serde_json = \"1.0\"\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Create Your First Aqua Chain\"\u003e\n    Update `src/main.rs`:\n\n    ```rust\n    use aqua_rs_sdk::primitives::Method;\n    use aqua_rs_sdk::schema::file_data::FileData;\n    use aqua_rs_sdk::Aquafier;\n    use std::path::PathBuf;\n\n    #[tokio::main]\n    async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        println!(\"Creating Aqua chain...\");\n\n        // Read file content\n        let filename = \"test.txt\".to_string();\n        let file_content = tokio::fs::read(\u0026filename).await?;\n\n        // Create file data\n        let file_data = FileData::new(\n            filename.clone(),\n            file_content,\n            PathBuf::from(format!(\"./{}\", filename)),\n        );\n\n        // Initialize Aquafier\n        let aquafier = Aquafier::new(None, None);\n\n        // Create genesis revision (notarize the file)\n        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n        match result {\n            Ok(tree) =\u003e {\n                println!(\"‚úì Aqua chain created successfully!\");\n                println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n\n                println!(\"\\nYou can now:\");\n                println!(\"- Add a signature revision\");\n                println!(\"- Witness on blockchain\");\n                println!(\"- Verify the chain\");\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error: {:#?}\", e);\n            }\n        }\n\n        Ok(())\n    }\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Build and Run\"\u003e\n    ```bash\n    cargo build\n    cargo run\n    ```\n\n    You should see confirmation that your object revision was created!\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\n---\n\n## CLI Tool Quick Start\n\n\u003cCallout type=\"info\"\u003e\n### Prerequisites\n- Rust and Cargo installed\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Install the CLI\"\u003e\n    ```bash\n    # Clone and build\n    git clone https://github.com/inblockio/aqua-cli-rs\n    cd aqua-cli-rs\n    cargo build --release\n\n    # The binary will be at target/release/aqua-cli\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Verify an Aqua Chain\"\u003e\n    ```bash\n    ./target/release/aqua-cli verify --file chain.aqua.json\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Get Help\"\u003e\n    ```bash\n    ./target/release/aqua-cli --help\n    ```\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\nSee the [CLI documentation](/dev_tools/aqua_cli) for more commands.\n\n---\n\n## Troubleshooting\n\n\u003cAccordion Group\u003e\n  \u003cAccordionItem  title=\"Node.js: Module not found error\"\u003e\n    **Issue**: `Cannot find module 'aqua-js-sdk'`\n\n    **Solutions**:\n    1. Ensure you ran `npm install aqua-js-sdk`\n    2. Check you're in the correct directory with `package.json`\n    3. Try deleting `node_modules` and `package-lock.json`, then run `npm install` again\n    4. For TypeScript, ensure you have `@types/node` installed\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"TypeScript: Type errors\"\u003e\n    **Issue**: TypeScript compilation errors\n\n    **Solutions**:\n    1. Ensure you have TypeScript installed: `npm install --save-dev typescript`\n    2. Create or update `tsconfig.json`:\n       ```json\n       {\n         \"compilerOptions\": {\n           \"target\": \"ES2020\",\n           \"module\": \"commonjs\",\n           \"esModuleInterop\": true,\n           \"strict\": true\n         }\n       }\n       ```\n    3. Use `tsx` for direct TypeScript execution: `npm install --save-dev tsx`\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"Rust: Compilation errors\"\u003e\n    **Issue**: Build fails with dependency errors\n\n    **Solutions**:\n    1. Update Rust: `rustup update`\n    2. Clean and rebuild: `cargo clean \u0026\u0026 cargo build`\n    3. Check you're using Rust 1.70 or higher: `rustc --version`\n    4. Ensure your `Cargo.toml` has the correct repository URL\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"MetaMask: Not detecting in Node.js\"\u003e\n    **Issue**: MetaMask signing doesn't work\n\n    **Solution**: MetaMask works in browser environments only. For Node.js:\n    - Use CLI signing with mnemonic in `credentials.json`\n    - Or use DID or P12 signing methods\n    - See [Development Guide](/development) for details\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"Witnessing: Network errors\"\u003e\n    **Issue**: Ethereum witness fails\n\n    **Solutions**:\n    1. Ensure you have ETH in your wallet (testnet ETH for Sepolia/Holesky)\n    2. Get testnet ETH from faucets:\n       - Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)\n       - Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)\n    3. Check network connectivity\n    4. Verify your Alchemy API key is correct\n  \u003c/AccordionItem \u003e\n\u003c/Accordion\u003e\n\n\n---\n\n## What You've Learned\n\nCongratulations! You've created your first Aqua chain. Here's what you accomplished:\n\n‚úÖ Installed an Aqua SDK (JavaScript or Rust)\u003cbr/\u003e\n‚úÖ Created a genesis revision (notarized data)\u003cbr/\u003e\n‚úÖ Understood the basic Aqua workflow\u003cbr/\u003e\n‚úÖ Ready to add signatures and witnesses\u003cbr/\u003e\n\n## Next Steps\n\nNow that you have the basics, dive deeper into Aqua Protocol's features:\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"Signing Revisions\" icon=\"signature\" href=\"/schema_reference/signing_revision\"\u003e\n    Add cryptographic signatures with RSA, Ethereum, or DID methods\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Witnessing\" icon=\"clock\" href=\"/schema_reference/witness_revision\"\u003e\n    Anchor your chains to Ethereum, TSA, or Nostr for timestamps\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Linking Chains\" icon=\"link\" href=\"/schema_reference/link_revision\"\u003e\n    Connect multiple Aqua Trees to build complex provenance graphs\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Using Templates\" icon=\"table\" href=\"/schema_reference/template_revision\"\u003e\n    Define data schemas with JSON Schema validation (v4 only)\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Development Guide\" icon=\"code\" href=\"/development\"\u003e\n    Complete guide for signing methods, witnessing, and advanced usage\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Schema Reference\" icon=\"book\" href=\"/schema_reference/introduction\"\u003e\n    Detailed technical specifications for all revision types\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Use Cases\" icon=\"lightbulb\" href=\"/use_cases/introduction\"\u003e\n    Explore real-world applications and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples\" icon=\"github\" href=\"https://github.com/inblockio/aqua-examples\"\u003e\n    Browse complete working examples in multiple languages\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n## Complete Workflow Example\n\nWant to see the full workflow including signing and witnessing?\n\n\u003cTabs defaultValue=\"js\"\u003e\n  \u003cTab label=\"js\"\u003e\n    Check out the [complete JavaScript example](https://github.com/inblockio/aqua-js-sdk/tree/master/examples) in the SDK repository.\n  \u003c/Tab\u003e\n\n  \u003cTab label=\"rust\"\u003e\n    Check out the [Rust SDK documentation](/dev_tools/aqua_sdk) for complete examples.\n  \u003c/Tab\u003e\n\u003c/Tabs\u003e\n\n## Try Aquafier\n\nNot ready to code yet? Try our web-based demo:\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"Aquafier Demo\" icon=\"globe\" href=\"https://aquafier.inblock.io\"\u003e\n    Upload and notarize files through a web interface\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Test Environment\" icon=\"bug-off\" href=\"https://dev.inblock.io\"\u003e\n    Experiment safely in the development environment\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n## Get Help\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"GitHub Issues\" icon=\"github\" href=\"https://github.com/inblockio\"\u003e\n    Report bugs or ask questions on GitHub\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Email Support\" icon=\"mail\" href=\"mailto:info@inblock.io\"\u003e\n    Contact our team for assistance\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Documentation\" icon=\"book\" href=\"/\"\u003e\n    Browse comprehensive guides and references\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Community\" icon=\"users\" href=\"https://github.com/inblockio/aqua-examples/discussions\"\u003e\n    Join discussions with other developers\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n---\n\n\u003cCallout type=\"note\" \u003e\n**Ready to build?** Start with the [Development Guide](/development) for detailed instructions on signing, witnessing, and advanced features.\n\u003c/Callout  \u003e\n"])</script><script>self.__next_f.push([1,"1c:T2e36,"])</script><script>self.__next_f.push([1,"\n## Choose Your SDK\n\n\u003cTabs defaultValue=\"js\"\u003e\n  \u003cTab label=\"js\"\u003e\n    **Stable** - Production-ready SDK for Node.js, Web, and React Native\n\n    Best for: Web applications, existing JavaScript projects\n  \u003c/Tab\u003e\n\n  \u003cTab label=\"rust\"\u003e\n    **Beta** - Template system, WASM support, cross-platform\n\n    Best for: New projects, performance-critical applications\n  \u003c/Tab\u003e\n\u003c/Tabs\u003e\n\n---\n\n## JavaScript/TypeScript Quick Start (v3)\n\n\u003cCallout type=\"info\"\u003e\n### Prerequisites\n- Node.js version 19 or higher\n- npm, yarn, or pnpm package manager\n\u003c/Callout \u003e\n\n\u003cCallout type=\"note\"\u003e\nWe recommend using TypeScript to enjoy type definitions and better development experience.\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Install the SDK\"\u003e\n    Create a new project or add to an existing one:\n\n    ```bash\n    # Create new project (optional)\n    mkdir my-aqua-project\n    cd my-aqua-project\n    npm init -y\n\n    # Install Aqua SDK\n    npm install aqua-js-sdk\n\n    # For TypeScript projects, also install type support\n    npm install --save-dev typescript @types/node\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Create Your First Aqua Chain\"\u003e\n    Create a file called `index.ts` (or `index.js`):\n\n    ```typescript\n    import Aquafier, { FileObject } from 'aqua-js-sdk';\n\n    async function main() {\n        // Initialize Aquafier\n        const aquafier = new Aquafier();\n\n        // Create a file object to notarize\n        const fileObject: FileObject = {\n            fileName: \"hello.txt\",\n            fileContent: \"Hello, Aqua Protocol!\",\n            path: \"./hello.txt\"\n        };\n\n        // Create genesis revision (notarize the file)\n        console.log(\"Creating Aqua chain...\");\n        const result = await aquafier.createGenesisRevision(fileObject);\n\n        if (result.isOk()) {\n            console.log(\"‚úì Success! Aqua chain created.\");\n            console.log(\"Aqua Tree:\", JSON.stringify(result.data.aquaTree, null, 2));\n\n            // The aquaTree contains your notarized file\n            const aquaTree = result.data.aquaTree;\n            console.log(\"\\nYou can now:\");\n            console.log(\"- Sign this chain\");\n            console.log(\"- Witness it on blockchain\");\n            console.log(\"- Verify it anytime\");\n        } else {\n            console.error(\"‚úó Error:\", result.error);\n        }\n    }\n\n    main().catch(console.error);\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Run Your Code\"\u003e\n    ```bash\n    # For TypeScript\n    npx tsx index.ts\n\n    # Or compile and run\n    npx tsc index.ts\n    node index.js\n\n    # For plain JavaScript\n    node index.js\n    ```\n\n    You should see output showing your Aqua chain was created successfully!\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Next: Add a Signature (Optional)\"\u003e\n    Extend your code to add a cryptographic signature:\n\n    ```typescript\n    // ... after creating genesis ...\n\n    if (result.isOk()) {\n        const aquaTree = result.data.aquaTree;\n\n        // Sign with MetaMask (will prompt in browser)\n        const wrapper = {\n            aquaTree: aquaTree,\n            fileObject: fileObject,\n            revision: \"\"\n        };\n\n        console.log(\"\\nAdding signature...\");\n        const signedResult = await aquafier.signAquaTree(\n            wrapper,\n            \"metamask\",  // or \"cli\", \"did\", \"p12\"\n            {},          // credentials\n            true         // auto-increment\n        );\n\n        if (signedResult.isOk()) {\n            console.log(\"‚úì Signature added!\");\n        }\n    }\n    ```\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\n---\n\n## Rust Quick Start (v4)\n\n\u003cCallout type=\"info\"\u003e\n\n### Prerequisites\n- Rust 1.70 or higher\n- Cargo package manager\n\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Create a New Project\"\u003e\n    ```bash\n    # Create a new Rust binary project\n    cargo new my-aqua-project\n    cd my-aqua-project\n\n    # Or for a library\n    cargo new --lib my-aqua-lib\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Add Aqua SDK Dependency\"\u003e\n    Add the Aqua SDK to your `Cargo.toml`:\n\n    ```toml\n    [dependencies]\n    aqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }\n    tokio = { version = \"1\", features = [\"full\"] }\n    serde_json = \"1.0\"\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Create Your First Aqua Chain\"\u003e\n    Update `src/main.rs`:\n\n    ```rust\n    use aqua_rs_sdk::primitives::Method;\n    use aqua_rs_sdk::schema::file_data::FileData;\n    use aqua_rs_sdk::Aquafier;\n    use std::path::PathBuf;\n\n    #[tokio::main]\n    async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        println!(\"Creating Aqua chain...\");\n\n        // Read file content\n        let filename = \"test.txt\".to_string();\n        let file_content = tokio::fs::read(\u0026filename).await?;\n\n        // Create file data\n        let file_data = FileData::new(\n            filename.clone(),\n            file_content,\n            PathBuf::from(format!(\"./{}\", filename)),\n        );\n\n        // Initialize Aquafier\n        let aquafier = Aquafier::new(None, None);\n\n        // Create genesis revision (notarize the file)\n        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n        match result {\n            Ok(tree) =\u003e {\n                println!(\"‚úì Aqua chain created successfully!\");\n                println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n\n                println!(\"\\nYou can now:\");\n                println!(\"- Add a signature revision\");\n                println!(\"- Witness on blockchain\");\n                println!(\"- Verify the chain\");\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error: {:#?}\", e);\n            }\n        }\n\n        Ok(())\n    }\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Build and Run\"\u003e\n    ```bash\n    cargo build\n    cargo run\n    ```\n\n    You should see confirmation that your object revision was created!\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\n---\n\n## CLI Tool Quick Start\n\n\u003cCallout type=\"info\"\u003e\n### Prerequisites\n- Rust and Cargo installed\n\u003c/Callout\u003e\n\n\u003cSteps\u003e\n  \u003cStep title=\"Install the CLI\"\u003e\n    ```bash\n    # Clone and build\n    git clone https://github.com/inblockio/aqua-cli-rs\n    cd aqua-cli-rs\n    cargo build --release\n\n    # The binary will be at target/release/aqua-cli\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Verify an Aqua Chain\"\u003e\n    ```bash\n    ./target/release/aqua-cli verify --file chain.aqua.json\n    ```\n  \u003c/Step\u003e\n\n  \u003cStep title=\"Get Help\"\u003e\n    ```bash\n    ./target/release/aqua-cli --help\n    ```\n  \u003c/Step\u003e\n\u003c/Steps\u003e\n\nSee the [CLI documentation](/dev_tools/aqua_cli) for more commands.\n\n---\n\n## Troubleshooting\n\n\u003cAccordion Group\u003e\n  \u003cAccordionItem  title=\"Node.js: Module not found error\"\u003e\n    **Issue**: `Cannot find module 'aqua-js-sdk'`\n\n    **Solutions**:\n    1. Ensure you ran `npm install aqua-js-sdk`\n    2. Check you're in the correct directory with `package.json`\n    3. Try deleting `node_modules` and `package-lock.json`, then run `npm install` again\n    4. For TypeScript, ensure you have `@types/node` installed\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"TypeScript: Type errors\"\u003e\n    **Issue**: TypeScript compilation errors\n\n    **Solutions**:\n    1. Ensure you have TypeScript installed: `npm install --save-dev typescript`\n    2. Create or update `tsconfig.json`:\n       ```json\n       {\n         \"compilerOptions\": {\n           \"target\": \"ES2020\",\n           \"module\": \"commonjs\",\n           \"esModuleInterop\": true,\n           \"strict\": true\n         }\n       }\n       ```\n    3. Use `tsx` for direct TypeScript execution: `npm install --save-dev tsx`\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"Rust: Compilation errors\"\u003e\n    **Issue**: Build fails with dependency errors\n\n    **Solutions**:\n    1. Update Rust: `rustup update`\n    2. Clean and rebuild: `cargo clean \u0026\u0026 cargo build`\n    3. Check you're using Rust 1.70 or higher: `rustc --version`\n    4. Ensure your `Cargo.toml` has the correct repository URL\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"MetaMask: Not detecting in Node.js\"\u003e\n    **Issue**: MetaMask signing doesn't work\n\n    **Solution**: MetaMask works in browser environments only. For Node.js:\n    - Use CLI signing with mnemonic in `credentials.json`\n    - Or use DID or P12 signing methods\n    - See [Development Guide](/development) for details\n  \u003c/AccordionItem \u003e\n\n  \u003cAccordionItem  title=\"Witnessing: Network errors\"\u003e\n    **Issue**: Ethereum witness fails\n\n    **Solutions**:\n    1. Ensure you have ETH in your wallet (testnet ETH for Sepolia/Holesky)\n    2. Get testnet ETH from faucets:\n       - Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)\n       - Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)\n    3. Check network connectivity\n    4. Verify your Alchemy API key is correct\n  \u003c/AccordionItem \u003e\n\u003c/Accordion\u003e\n\n\n---\n\n## What You've Learned\n\nCongratulations! You've created your first Aqua chain. Here's what you accomplished:\n\n‚úÖ Installed an Aqua SDK (JavaScript or Rust)\u003cbr/\u003e\n‚úÖ Created a genesis revision (notarized data)\u003cbr/\u003e\n‚úÖ Understood the basic Aqua workflow\u003cbr/\u003e\n‚úÖ Ready to add signatures and witnesses\u003cbr/\u003e\n\n## Next Steps\n\nNow that you have the basics, dive deeper into Aqua Protocol's features:\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"Signing Revisions\" icon=\"signature\" href=\"/schema_reference/signing_revision\"\u003e\n    Add cryptographic signatures with RSA, Ethereum, or DID methods\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Witnessing\" icon=\"clock\" href=\"/schema_reference/witness_revision\"\u003e\n    Anchor your chains to Ethereum, TSA, or Nostr for timestamps\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Linking Chains\" icon=\"link\" href=\"/schema_reference/link_revision\"\u003e\n    Connect multiple Aqua Trees to build complex provenance graphs\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Using Templates\" icon=\"table\" href=\"/schema_reference/template_revision\"\u003e\n    Define data schemas with JSON Schema validation (v4 only)\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Development Guide\" icon=\"code\" href=\"/development\"\u003e\n    Complete guide for signing methods, witnessing, and advanced usage\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Schema Reference\" icon=\"book\" href=\"/schema_reference/introduction\"\u003e\n    Detailed technical specifications for all revision types\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Use Cases\" icon=\"lightbulb\" href=\"/use_cases/introduction\"\u003e\n    Explore real-world applications and implementation patterns\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples\" icon=\"github\" href=\"https://github.com/inblockio/aqua-examples\"\u003e\n    Browse complete working examples in multiple languages\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n## Complete Workflow Example\n\nWant to see the full workflow including signing and witnessing?\n\n\u003cTabs defaultValue=\"js\"\u003e\n  \u003cTab label=\"js\"\u003e\n    Check out the [complete JavaScript example](https://github.com/inblockio/aqua-js-sdk/tree/master/examples) in the SDK repository.\n  \u003c/Tab\u003e\n\n  \u003cTab label=\"rust\"\u003e\n    Check out the [Rust SDK documentation](/dev_tools/aqua_sdk) for complete examples.\n  \u003c/Tab\u003e\n\u003c/Tabs\u003e\n\n## Try Aquafier\n\nNot ready to code yet? Try our web-based demo:\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"Aquafier Demo\" icon=\"globe\" href=\"https://aquafier.inblock.io\"\u003e\n    Upload and notarize files through a web interface\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Test Environment\" icon=\"bug-off\" href=\"https://dev.inblock.io\"\u003e\n    Experiment safely in the development environment\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n## Get Help\n\n\u003cCardGrid  cols={2}\u003e\n  \u003cCard title=\"GitHub Issues\" icon=\"github\" href=\"https://github.com/inblockio\"\u003e\n    Report bugs or ask questions on GitHub\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Email Support\" icon=\"mail\" href=\"mailto:info@inblock.io\"\u003e\n    Contact our team for assistance\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Documentation\" icon=\"book\" href=\"/\"\u003e\n    Browse comprehensive guides and references\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Community\" icon=\"users\" href=\"https://github.com/inblockio/aqua-examples/discussions\"\u003e\n    Join discussions with other developers\n  \u003c/Card\u003e\n\u003c/CardGrid \u003e\n\n---\n\n\u003cCallout type=\"note\" \u003e\n**Ready to build?** Start with the [Development Guide](/development) for detailed instructions on signing, witnessing, and advanced features.\n\u003c/Callout  \u003e\n"])</script><script>self.__next_f.push([1,"1d:T240c,"])</script><script>self.__next_f.push([1,"\n# File Index\n\nThe **File Index** is a component of the Aqua Tree that maps content hashes to human-readable filenames. It provides context about what each hash represents, making Aqua Trees more understandable and navigable.\n\n## Purpose\n\nWhen content is hashed (documents, images, data files), the resulting hash is a cryptographic string that provides no information about the original content. The file index solves this by maintaining a mapping between:\n\n- **Content hashes**: SHA3-256 hashes of file content\n- **Filenames**: Human-readable names that describe the content\n\nThis enables users and applications to understand what content each hash represents without needing to store or transmit the actual content.\n\n## Structure\n\nThe file index is a simple key-value object:\n\n```json\n{\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"document.pdf\",\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"test.txt\",\n    \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\": \"image.png\"\n  }\n}\n```\n\n### Field Format\n\n| Component | Description | Format |\n|-----------|-------------|--------|\n| **Key** | Content hash | Hex string prefixed with `0x`, typically 64 characters (SHA3-256) |\n| **Value** | Filename | String, typically includes file extension |\n\n## Hash Sources\n\nFile index entries can reference hashes from several sources:\n\n### 1. Object Revision Payloads\n\nWhen an object revision contains content:\n\n```json\n{\n  \"revisions\": {\n    \"0xrev_hash...\": {\n      \"payload\": {\n        \"hash\": \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\",\n        \"payload_type\": \"application/pdf\",\n        \"descriptor\": \"Contract Document\"\n      }\n    }\n  },\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"contract.pdf\"\n  }\n}\n```\n\n### 2. Linked External Trees\n\nWhen link revisions reference other Aqua Trees:\n\n```json\n{\n  \"revisions\": {\n    \"0xlink_hash...\": {\n      \"revision_type\": \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\",\n      \"links\": [\n        {\n          \"verification_hash\": \"0xexternal_tree_hash...\",\n          \"content_hash\": \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\"\n        }\n      ]\n    }\n  },\n  \"file_index\": {\n    \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\": \"component_tree.aqua.json\"\n  }\n}\n```\n\n### 3. Template Content\n\nWhen template revisions define schemas:\n\n```json\n{\n  \"file_index\": {\n    \"0xtemplate_hash...\": \"user_credential_schema.json\"\n  }\n}\n```\n\n## Complete Example\n\nHere's a complete Aqua Tree showing how file_index integrates:\n\n```json\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"application/pdf\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Sales Contract\"\n      }\n    },\n    \"0xsig_hash...\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x...\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"sales_contract_2024.pdf\"\n  }\n}\n```\n\n## Benefits\n\n### 1. Human Readability\n\nUsers can understand what content is in the tree without decoding hashes:\n\n```json\n\"file_index\": {\n  \"0xabc...\": \"proposal.docx\",\n  \"0xdef...\": \"budget.xlsx\",\n  \"0x123...\": \"diagram.png\"\n}\n```\n\nInstead of just seeing cryptographic hashes, users see meaningful filenames.\n\n### 2. Content Discovery\n\nApplications can list available content:\n\n```typescript\nconst filenames = Object.values(aquaTree.file_index);\nconsole.log(\"Available files:\", filenames);\n// Output: [\"proposal.docx\", \"budget.xlsx\", \"diagram.png\"]\n```\n\n### 3. Reverse Lookup\n\nFind the hash for a known filename:\n\n```typescript\nfunction findHashByFilename(aquaTree, filename) {\n  return Object.entries(aquaTree.file_index)\n    .find(([_, name]) =\u003e name === filename)?.[0];\n}\n\nconst hash = findHashByFilename(tree, \"contract.pdf\");\n```\n\n### 4. Linked Tree Context\n\nWhen trees link to external trees, the file index identifies them:\n\n```json\n\"file_index\": {\n  \"0xhash1...\": \"main_document.pdf\",\n  \"0xhash2...\": \"appendix_a.aqua.json\",  // External tree\n  \"0xhash3...\": \"appendix_b.aqua.json\"   // External tree\n}\n```\n\n## Best Practices\n\n### Descriptive Filenames\n\nUse clear, descriptive names with appropriate extensions:\n\n```json\n// Good\n\"file_index\": {\n  \"0xabc...\": \"employment_contract_john_doe_2024.pdf\",\n  \"0xdef...\": \"diploma_computer_science_2024.pdf\"\n}\n\n// Avoid\n\"file_index\": {\n  \"0xabc...\": \"file1.dat\",\n  \"0xdef...\": \"doc.bin\"\n}\n```\n\n### Include Extensions\n\nAlways include file extensions to indicate content type:\n\n```json\n\"file_index\": {\n  \"0xabc...\": \"document.pdf\",      // PDF document\n  \"0xdef...\": \"image.png\",          // PNG image\n  \"0x123...\": \"data.json\",          // JSON data\n  \"0x456...\": \"archive.zip\",        // Compressed archive\n  \"0x789...\": \"video.mp4\"           // Video file\n}\n```\n\n### Unique Names\n\nEnsure filenames are unique within a tree to avoid ambiguity:\n\n```json\n// Good - unique names\n\"file_index\": {\n  \"0xabc...\": \"contract_v1.pdf\",\n  \"0xdef...\": \"contract_v2.pdf\"\n}\n\n// Avoid - duplicate names\n\"file_index\": {\n  \"0xabc...\": \"contract.pdf\",\n  \"0xdef...\": \"contract.pdf\"  // Ambiguous!\n}\n```\n\n### External Tree Naming\n\nFor linked external trees, use the `.aqua.json` extension:\n\n```json\n\"file_index\": {\n  \"0xhash...\": \"component_a.aqua.json\",\n  \"0xhash...\": \"dependency_b.aqua.json\"\n}\n```\n\n## Optional Nature\n\nWhile the file index is a standard component of Aqua Trees, entries are **optional**:\n\n- Not all hashes need file index entries\n- The tree remains valid without file_index\n- Applications can function using hashes alone\n\nHowever, including file index entries significantly improves usability.\n\n## Validation\n\nThe file index should be validated for:\n\n### 1. Hash Format\n\nAll keys must be valid hex strings:\n\n```typescript\nfunction isValidHash(hash: string): boolean {\n  return /^0x[0-9a-fA-F]{64}$/.test(hash);\n}\n```\n\n### 2. Referenced Hashes\n\nHashes in file_index should appear in revisions:\n\n```typescript\nfunction validateFileIndex(aquaTree) {\n  const referencedHashes = new Set();\n\n  // Collect all content hashes from revisions\n  Object.values(aquaTree.revisions).forEach(rev =\u003e {\n    if (rev.payload?.hash) {\n      referencedHashes.add(rev.payload.hash);\n    }\n    if (rev.links) {\n      rev.links.forEach(link =\u003e referencedHashes.add(link.content_hash));\n    }\n  });\n\n  // Check file_index entries\n  for (const hash of Object.keys(aquaTree.file_index)) {\n    if (!referencedHashes.has(hash)) {\n      console.warn(`Orphaned file_index entry: ${hash}`);\n    }\n  }\n}\n```\n\n### 3. Filename Validity\n\nFilenames should not contain invalid characters:\n\n```typescript\nfunction isValidFilename(filename: string): boolean {\n  // Avoid: null bytes, path separators, control characters\n  return !/[\\x00\\/\\\\]/.test(filename);\n}\n```\n\n## Use Cases\n\n### Document Management Systems\n\nTrack document names across revisions:\n\n```json\n\"file_index\": {\n  \"0xv1...\": \"proposal_draft_v1.docx\",\n  \"0xv2...\": \"proposal_draft_v2.docx\",\n  \"0xfinal...\": \"proposal_final.docx\"\n}\n```\n\n### Multi-File Projects\n\nReference multiple files in a project:\n\n```json\n\"file_index\": {\n  \"0xreadme...\": \"README.md\",\n  \"0xcode...\": \"main.rs\",\n  \"0xconfig...\": \"config.toml\",\n  \"0xdocs...\": \"documentation.pdf\"\n}\n```\n\n### Supply Chain Tracking\n\nIdentify product-related documents:\n\n```json\n\"file_index\": {\n  \"0xcert...\": \"organic_certification.pdf\",\n  \"0xinspect...\": \"quality_inspection_report.pdf\",\n  \"0xship...\": \"shipping_manifest.pdf\"\n}\n```\n\n### Credential Systems\n\nMap credential hashes to recipient identifiers:\n\n```json\n\"file_index\": {\n  \"0xdiploma...\": \"diploma_john_doe_2024.pdf\",\n  \"0xtranscript...\": \"transcript_john_doe_2024.pdf\"\n}\n```\n\n## Storage Considerations\n\n### Size Impact\n\nEach file index entry adds approximately 100-150 bytes:\n- 64-character hash: ~66 bytes\n- Filename: 20-50 bytes typical\n- JSON overhead: ~20 bytes\n\nFor large trees, this is minimal compared to revision data.\n\n### Compression\n\nFile index compresses well with gzip due to repetitive patterns:\n- Hash prefixes (`0x`)\n- Common file extensions (`.pdf`, `.json`)\n\n## Related Documentation\n\n- [Aqua Tree](/schema_reference/aqua_tree) - Complete tree structure\n- [Object Revision](/schema_reference/object_revision) - Revisions containing content hashes\n- [Link Revision](/schema_reference/link_revision) - Linking to external trees\n- [Template Revision](/schema_reference/template_revision) - Schema definitions\n"])</script><script>self.__next_f.push([1,"1e:T240c,"])</script><script>self.__next_f.push([1,"\n# File Index\n\nThe **File Index** is a component of the Aqua Tree that maps content hashes to human-readable filenames. It provides context about what each hash represents, making Aqua Trees more understandable and navigable.\n\n## Purpose\n\nWhen content is hashed (documents, images, data files), the resulting hash is a cryptographic string that provides no information about the original content. The file index solves this by maintaining a mapping between:\n\n- **Content hashes**: SHA3-256 hashes of file content\n- **Filenames**: Human-readable names that describe the content\n\nThis enables users and applications to understand what content each hash represents without needing to store or transmit the actual content.\n\n## Structure\n\nThe file index is a simple key-value object:\n\n```json\n{\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"document.pdf\",\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"test.txt\",\n    \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\": \"image.png\"\n  }\n}\n```\n\n### Field Format\n\n| Component | Description | Format |\n|-----------|-------------|--------|\n| **Key** | Content hash | Hex string prefixed with `0x`, typically 64 characters (SHA3-256) |\n| **Value** | Filename | String, typically includes file extension |\n\n## Hash Sources\n\nFile index entries can reference hashes from several sources:\n\n### 1. Object Revision Payloads\n\nWhen an object revision contains content:\n\n```json\n{\n  \"revisions\": {\n    \"0xrev_hash...\": {\n      \"payload\": {\n        \"hash\": \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\",\n        \"payload_type\": \"application/pdf\",\n        \"descriptor\": \"Contract Document\"\n      }\n    }\n  },\n  \"file_index\": {\n    \"0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28\": \"contract.pdf\"\n  }\n}\n```\n\n### 2. Linked External Trees\n\nWhen link revisions reference other Aqua Trees:\n\n```json\n{\n  \"revisions\": {\n    \"0xlink_hash...\": {\n      \"revision_type\": \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\",\n      \"links\": [\n        {\n          \"verification_hash\": \"0xexternal_tree_hash...\",\n          \"content_hash\": \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\"\n        }\n      ]\n    }\n  },\n  \"file_index\": {\n    \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\": \"component_tree.aqua.json\"\n  }\n}\n```\n\n### 3. Template Content\n\nWhen template revisions define schemas:\n\n```json\n{\n  \"file_index\": {\n    \"0xtemplate_hash...\": \"user_credential_schema.json\"\n  }\n}\n```\n\n## Complete Example\n\nHere's a complete Aqua Tree showing how file_index integrates:\n\n```json\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"application/pdf\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Sales Contract\"\n      }\n    },\n    \"0xsig_hash...\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x...\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"sales_contract_2024.pdf\"\n  }\n}\n```\n\n## Benefits\n\n### 1. Human Readability\n\nUsers can understand what content is in the tree without decoding hashes:\n\n```json\n\"file_index\": {\n  \"0xabc...\": \"proposal.docx\",\n  \"0xdef...\": \"budget.xlsx\",\n  \"0x123...\": \"diagram.png\"\n}\n```\n\nInstead of just seeing cryptographic hashes, users see meaningful filenames.\n\n### 2. Content Discovery\n\nApplications can list available content:\n\n```typescript\nconst filenames = Object.values(aquaTree.file_index);\nconsole.log(\"Available files:\", filenames);\n// Output: [\"proposal.docx\", \"budget.xlsx\", \"diagram.png\"]\n```\n\n### 3. Reverse Lookup\n\nFind the hash for a known filename:\n\n```typescript\nfunction findHashByFilename(aquaTree, filename) {\n  return Object.entries(aquaTree.file_index)\n    .find(([_, name]) =\u003e name === filename)?.[0];\n}\n\nconst hash = findHashByFilename(tree, \"contract.pdf\");\n```\n\n### 4. Linked Tree Context\n\nWhen trees link to external trees, the file index identifies them:\n\n```json\n\"file_index\": {\n  \"0xhash1...\": \"main_document.pdf\",\n  \"0xhash2...\": \"appendix_a.aqua.json\",  // External tree\n  \"0xhash3...\": \"appendix_b.aqua.json\"   // External tree\n}\n```\n\n## Best Practices\n\n### Descriptive Filenames\n\nUse clear, descriptive names with appropriate extensions:\n\n```json\n// Good\n\"file_index\": {\n  \"0xabc...\": \"employment_contract_john_doe_2024.pdf\",\n  \"0xdef...\": \"diploma_computer_science_2024.pdf\"\n}\n\n// Avoid\n\"file_index\": {\n  \"0xabc...\": \"file1.dat\",\n  \"0xdef...\": \"doc.bin\"\n}\n```\n\n### Include Extensions\n\nAlways include file extensions to indicate content type:\n\n```json\n\"file_index\": {\n  \"0xabc...\": \"document.pdf\",      // PDF document\n  \"0xdef...\": \"image.png\",          // PNG image\n  \"0x123...\": \"data.json\",          // JSON data\n  \"0x456...\": \"archive.zip\",        // Compressed archive\n  \"0x789...\": \"video.mp4\"           // Video file\n}\n```\n\n### Unique Names\n\nEnsure filenames are unique within a tree to avoid ambiguity:\n\n```json\n// Good - unique names\n\"file_index\": {\n  \"0xabc...\": \"contract_v1.pdf\",\n  \"0xdef...\": \"contract_v2.pdf\"\n}\n\n// Avoid - duplicate names\n\"file_index\": {\n  \"0xabc...\": \"contract.pdf\",\n  \"0xdef...\": \"contract.pdf\"  // Ambiguous!\n}\n```\n\n### External Tree Naming\n\nFor linked external trees, use the `.aqua.json` extension:\n\n```json\n\"file_index\": {\n  \"0xhash...\": \"component_a.aqua.json\",\n  \"0xhash...\": \"dependency_b.aqua.json\"\n}\n```\n\n## Optional Nature\n\nWhile the file index is a standard component of Aqua Trees, entries are **optional**:\n\n- Not all hashes need file index entries\n- The tree remains valid without file_index\n- Applications can function using hashes alone\n\nHowever, including file index entries significantly improves usability.\n\n## Validation\n\nThe file index should be validated for:\n\n### 1. Hash Format\n\nAll keys must be valid hex strings:\n\n```typescript\nfunction isValidHash(hash: string): boolean {\n  return /^0x[0-9a-fA-F]{64}$/.test(hash);\n}\n```\n\n### 2. Referenced Hashes\n\nHashes in file_index should appear in revisions:\n\n```typescript\nfunction validateFileIndex(aquaTree) {\n  const referencedHashes = new Set();\n\n  // Collect all content hashes from revisions\n  Object.values(aquaTree.revisions).forEach(rev =\u003e {\n    if (rev.payload?.hash) {\n      referencedHashes.add(rev.payload.hash);\n    }\n    if (rev.links) {\n      rev.links.forEach(link =\u003e referencedHashes.add(link.content_hash));\n    }\n  });\n\n  // Check file_index entries\n  for (const hash of Object.keys(aquaTree.file_index)) {\n    if (!referencedHashes.has(hash)) {\n      console.warn(`Orphaned file_index entry: ${hash}`);\n    }\n  }\n}\n```\n\n### 3. Filename Validity\n\nFilenames should not contain invalid characters:\n\n```typescript\nfunction isValidFilename(filename: string): boolean {\n  // Avoid: null bytes, path separators, control characters\n  return !/[\\x00\\/\\\\]/.test(filename);\n}\n```\n\n## Use Cases\n\n### Document Management Systems\n\nTrack document names across revisions:\n\n```json\n\"file_index\": {\n  \"0xv1...\": \"proposal_draft_v1.docx\",\n  \"0xv2...\": \"proposal_draft_v2.docx\",\n  \"0xfinal...\": \"proposal_final.docx\"\n}\n```\n\n### Multi-File Projects\n\nReference multiple files in a project:\n\n```json\n\"file_index\": {\n  \"0xreadme...\": \"README.md\",\n  \"0xcode...\": \"main.rs\",\n  \"0xconfig...\": \"config.toml\",\n  \"0xdocs...\": \"documentation.pdf\"\n}\n```\n\n### Supply Chain Tracking\n\nIdentify product-related documents:\n\n```json\n\"file_index\": {\n  \"0xcert...\": \"organic_certification.pdf\",\n  \"0xinspect...\": \"quality_inspection_report.pdf\",\n  \"0xship...\": \"shipping_manifest.pdf\"\n}\n```\n\n### Credential Systems\n\nMap credential hashes to recipient identifiers:\n\n```json\n\"file_index\": {\n  \"0xdiploma...\": \"diploma_john_doe_2024.pdf\",\n  \"0xtranscript...\": \"transcript_john_doe_2024.pdf\"\n}\n```\n\n## Storage Considerations\n\n### Size Impact\n\nEach file index entry adds approximately 100-150 bytes:\n- 64-character hash: ~66 bytes\n- Filename: 20-50 bytes typical\n- JSON overhead: ~20 bytes\n\nFor large trees, this is minimal compared to revision data.\n\n### Compression\n\nFile index compresses well with gzip due to repetitive patterns:\n- Hash prefixes (`0x`)\n- Common file extensions (`.pdf`, `.json`)\n\n## Related Documentation\n\n- [Aqua Tree](/schema_reference/aqua_tree) - Complete tree structure\n- [Object Revision](/schema_reference/object_revision) - Revisions containing content hashes\n- [Link Revision](/schema_reference/link_revision) - Linking to external trees\n- [Template Revision](/schema_reference/template_revision) - Schema definitions\n"])</script><script>self.__next_f.push([1,"1f:T3a85,"])</script><script>self.__next_f.push([1,"\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\nWe recommend completing the [Quick Start Guide](/quickstart) before diving into development details.\n\u003c/Callout\u003e\n\n## Choose Your SDK\n\nAqua Protocol offers SDKs for different use cases:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Rust SDK (v4)\" icon=\"code\" href=\"/dev_tools/aqua_sdk\"\u003e\n    **Beta** - Template system, WASM support, cross-platform\n\n    Best for: New projects, performance-critical applications\n  \u003c/Card\u003e\n\n  \u003cCard title=\"JavaScript SDK (v3)\" icon=\"code\" href=\"/previous_versions/version_3/tooling\"\u003e\n    **Stable** - Production-ready, Node.js/Web/React Native\n\n    Best for: Web applications, existing JavaScript projects\n  \u003c/Card\u003e\n\n  \u003cCard title=\"CLI Tool (v4)\" icon=\"terminal\" href=\"/dev_tools/aqua_cli\"\u003e\n    Command-line tool for quick operations\n\n    Best for: Testing, CI/CD, scripting\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Aquafier API (v3)\" icon=\"globe\" href=\"/dev_tools/aquafier_api\"\u003e\n    Web-based API for notarization\n\n    Best for: No-code integration, demos\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Signing Methods\n\nAqua Protocol supports multiple signature types for different use cases:\n\n| Method | Protocol Version | Use Case | Trust Model |\n|--------|-----------------|----------|-------------|\n| **DID (JWS)** | v3, v4 | Decentralized identities | W3C DID standard |\n| **Ethereum (EIP-191)** | v3, v4 | Blockchain-native apps | Ethereum addresses |\n| **RSA** | v4 only | Traditional PKI | Certificate authorities |\n| **P12 Certificates** | v3 only | Enterprise/legal docs | Certificate authorities |\n\n\n### Signing Setup Details\n\n\u003cAccordion title=\"DID Signature (W3C Decentralized Identifiers)\"\u003e\n**What you need**: A DID key pair\n\n**How to generate**:\n\n**Option 1: Using JavaScript**\n```bash\nnpm install @digitalcredentials/did-method-key\n```\n\n```javascript\nimport { Ed25519VerificationKey2020 } from '@digitalcredentials/ed25519-verification-key-2020';\nimport { X25519KeyAgreementKey2020 } from '@digitalcredentials/x25519-key-agreement-key-2020';\n\nconst keyPair = await Ed25519VerificationKey2020.generate();\nconst did = `did:key:${keyPair.publicKeyMultibase}`;\nconsole.log('DID:', did);\nconsole.log('Private Key:', keyPair.privateKeyMultibase);\n```\n\n**Option 2: Online Generator**\n- Visit [EBSI DID Generator](https://hub.ebsi.eu/tools/did-generator)\n- Click \"Generate Keys\"\n- Save your DID and private key securely\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Ethereum Signature (EIP-191)\"\u003e\n**What you need**: Ethereum wallet with private key or mnemonic\n\n**Two supported methods**:\n\n**1. MetaMask Browser Extension** (Recommended for development)\n- Install [MetaMask](https://metamask.io/) in your browser\n- Create or import a wallet\n- The SDK will prompt for signature when needed\n\n**2. Mnemonic/Private Key in Credentials File**\n\nCreate a `credentials.json` file:\n```json\n{\n  \"mnemonic\": \"your twelve word mnemonic phrase here...\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\nOr with private key:\n```json\n{\n  \"private_key\": \"0xYourPrivateKeyHex\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n\u003cCallout type=\"warning\" title=\"Security\"\u003e\nNever commit credentials.json to version control! Add it to `.gitignore`.\n\u003c/Callout\u003e\n\nCheck your SDK documentation ([Rust SDK](/dev_tools/aqua_sdk) | [JavaScript SDK](/previous_versions/version_3/tooling)) for how to pass credentials.\n\n**Protocol Support**: v3, v4\n\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"RSA Signature (v4 only)\"\u003e\n**What you need**: RSA key pair (2048-bit or higher)\n\n**Generate RSA keys**:\n\n```bash\n# Generate private key (2048-bit)\nopenssl genrsa -out private.pem 2048\n\n# Extract public key\nopenssl rsa -in private.pem -pubout -out public.pem\n\n# View keys\ncat private.pem\ncat public.pem\n```\n\n**For production**: Use keys from your organization's PKI infrastructure or certificate authority.\n\n**Protocol Support**: v4 only\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"P12 Certificate Signature (v3 only)\"\u003e\n**What you need**: PKCS#12 certificate file (.p12/.pfx) with password\n\n**For Development** (self-signed certificate):\n\n```bash\n# Generate private key\nopenssl genrsa -out private.key 2048\n\n# Create certificate signing request\nopenssl req -new -key private.key -out certificate.csr\n\n# For Windows/Git Bash, specify config:\n# openssl req -new -key private.key -out certificate.csr -config \"C:\\Program Files\\Git\\usr\\ssl\\openssl.cnf\"\n\n# Generate self-signed certificate (valid for 365 days)\nopenssl x509 -req -days 365 -in certificate.csr -signkey private.key -out certificate.crt\n\n# Create P12 file (you'll be prompted for export password)\nopenssl pkcs12 -export -out certificate.p12 -inkey private.key -in certificate.crt\n```\n\n**Convert to Base64** (required for SDK):\n```bash\n# macOS/Linux\nbase64 -i certificate.p12 -o certificate_base64.txt\n\n# Windows (PowerShell)\n[Convert]::ToBase64String([IO.File]::ReadAllBytes(\"certificate.p12\")) | Out-File certificate_base64.txt\n\n# Linux alternative\nbase64 certificate.p12 \u003e certificate_base64.txt\n```\n\n**For Production** (trusted certificate):\n\n **1. Purchase from Certificate Authority**:\n   - DigiCert, Sectigo, GlobalSign, etc.\n   - Request \"Code Signing\" or \"Document Signing\" certificate\n   - They'll provide a .p12/.pfx file directly\n\n**2. If you receive separate files** (.crt + .key + intermediate):\n   ```bash\n   openssl pkcs12 -export -out certificate.p12 \\\n       -inkey privatekey.key \\\n       -in certificate.crt \\\n       -certfile intermediate.crt\n   ```\n\n**Usage in SDK**:\n```json\n{\n  \"p12_content\": \"base64_encoded_p12_content_here\",\n  \"p12_password\": \"your_export_password\"\n}\n```\n\n**Protocol Support**: v3 only\n\u003c/Accordion\u003e\n\n## Witnessing Methods\n\nWitnessing anchors your Aqua revisions to external timestamping services for provable timestamps:\n\n| Method | Networks | Cost | Verification |\n|--------|----------|------|--------------|\n| **Ethereum** | Mainnet, Sepolia, Holesky | Gas fees (testnet: free) | Blockchain explorer |\n| **TSA** | RFC 3161 services | Free (public TSAs) | TSA verification |\n| **Nostr** | Nostr relays | Free | Nostr event verification |\n\n### Witnessing Setup Details\n\n\u003cAccordion title=\"TSA Witness (Time-Stamp Authority - RFC 3161)\"\u003e\n**What you need**: A TSA service URL\n\n**Free Public TSA Services**:\n\n```bash\n# DigiCert\nhttp://timestamp.digicert.com\n\n# Sectigo (formerly Comodo)\nhttp://timestamp.sectigo.com\nhttp://timestamp.comodoca.com\n\n# GlobalSign\nhttp://timestamp.globalsign.com/scripts/timstamp.dll\nhttp://timestamp.globalsign.com/tsa/r6advanced1\n\n# Entrust\nhttp://timestamp.entrust.net/TSS/RFC3161sha2TS\n```\n\n**Usage**: Simply provide the TSA URL to your SDK when witnessing.\n\n**Benefits**:\n- No blockchain required\n- Widely accepted standard (RFC 3161)\n- Free for most public TSAs\n- Instant timestamps\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Ethereum Witness\"\u003e\n**What you need**:\n1. Ethereum wallet (MetaMask or mnemonic/private key)\n2. ETH for gas fees (mainnet) or testnet ETH (Sepolia/Holesky)\n3. Alchemy API key for witness verification\n\n**Networks Supported**:\n- **Mainnet**: Production use, requires real ETH for gas\n- **Sepolia**: Testnet, free test ETH from faucets\n- **Holesky**: Testnet, free test ETH from faucets\n\n**Wallet Setup** (same as signing):\n\n**Option 1: MetaMask**\n- Install [MetaMask](https://metamask.io/)\n- Ensure you're on the correct network (mainnet/sepolia/holesky)\n- Have sufficient ETH for gas fees\n\n**Option 2: Credentials File**\n```json\n{\n  \"mnemonic\": \"your twelve word mnemonic phrase here...\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n**Get Test ETH** (for testnets):\n- Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)\n- Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)\n\n**Alchemy API Key** (for verification):\n1. Visit [alchemy.com](https://www.alchemy.com/)\n2. Create free account\n3. Create new app\n4. Copy API key\n5. [Detailed guide](https://www.alchemy.com/docs/how-to-create-access-keys)\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Nostr Witness\"\u003e\n**What you need**: Nostr secret key (nsec)\n\n**How to get a Nostr key**:\n\n**Option 1: Nostr Client App**\n1. Download a Nostr app:\n   - [Damus](https://damus.io/) (iOS)\n   - [Amethyst](https://github.com/vitorpamplona/amethyst) (Android)\n   - [Primal](https://primal.net/) (Web/Mobile)\n2. Create new account or log in\n3. App generates a key pair automatically\n4. Your secret key starts with `nsec1...`\n5. **Save it securely** - you'll need it for witnessing\n\n**Option 2: Web Generator**\n- Visit [nostr.com](https://nostr.com) or [nostrtool.com](https://nostrtool.com)\n- Click \"Generate Keys\"\n- Save your secret key (`nsec1...`)\n\n\u003cCallout type=\"warning\" title=\"Security\"\u003e\nYour Nostr secret key is permanent. Anyone with it can post as you on Nostr relays. Keep it secure!\n\u003c/Callout\u003e\n\n**Benefits**:\n- Fully decentralized (no blockchain fees)\n- Censorship-resistant\n- Fast propagation across relays\n- Free to use\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\n\n## JavaScript SDK Usage (v3)\n\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\n- Node.js version 19 or higher\n- Install aqua-js-sdk: `npm install aqua-js-sdk`\n\u003c/Callout\u003e\n\n### Complete Workflow Example\n\nFollow these steps to notarize a file, sign it, and witness it using the JavaScript SDK (v3):\n\n\u003cSteps\u003e\n\u003cStep title=\"Create Genesis Revision\"\u003e\n\n```typescript\nimport Aquafier, { FileObject } from 'aqua-js-sdk';\nimport { readFileSync } from 'fs';\n\n// Read file content\nconst testFileContent = readFileSync(\"./test.txt\", 'utf-8');\n\n// Create file object\nconst aquaFileObject: FileObject = {\n    fileName: \"test.txt\",\n    fileContent: testFileContent,\n    path: \"./test.txt\"\n};\n\n// Initialize Aquafier\nconst aquafier = new Aquafier();\n\n// Create genesis revision (notarize the file)\nconst genesisResult = await aquafier.createGenesisRevision(aquaFileObject);\n\nif (genesisResult.isOk()) {\n    console.log(\"Genesis created successfully!\");\n    console.log(\"Aqua Tree:\", genesisResult.data.aquaTree);\n} else {\n    console.error(\"Error creating genesis:\", genesisResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Sign the Aqua Tree\"\u003e\n\n```typescript\nimport { AquaTreeWrapper, CredentialsData } from 'aqua-js-sdk';\n\n// Prepare credentials (for MetaMask, can be empty object)\nconst creds: CredentialsData = {};\n\n// Or for CLI signing with mnemonic:\n// const creds: CredentialsData = {\n//     mnemonic: \"your twelve word mnemonic here\",\n//     wallet_address: \"0xYourAddress\"\n// };\n\n// Create wrapper (empty string for revision means sign latest)\nconst aquaWrapper: AquaTreeWrapper = {\n    aquaTree: genesisResult.data.aquaTree,\n    fileObject: aquaFileObject,\n    revision: \"\"  // Sign latest revision\n};\n\n// Sign with MetaMask (or use \"cli\", \"did\", \"p12\")\nconst signedResult = await aquafier.signAquaTree(\n    aquaWrapper,\n    \"metamask\",  // Signature type\n    creds,\n    true         // Auto-increment\n);\n\nif (signedResult.isOk()) {\n    console.log(\"Signature added successfully!\");\n} else {\n    console.error(\"Signing failed:\", signedResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Witness on Blockchain\"\u003e\n\n```typescript\n// Update wrapper with signed tree\nconst witnessWrapper: AquaTreeWrapper = {\n    aquaTree: signedResult.data.aquaTree,\n    fileObject: aquaFileObject,\n    revision: \"\"  // Witness latest revision\n};\n\n// Witness on Ethereum Sepolia testnet\nconst witnessResult = await aquafier.witnessAquaTree(\n    witnessWrapper,\n    \"eth\",        // Witness type (eth, tsa, or nostr)\n    \"sepolia\",    // Network (sepolia, mainnet, holesky)\n    \"metamask\",   // Signing method\n    creds,\n    true          // Auto-increment\n);\n\nif (witnessResult.isOk()) {\n    console.log(\"Witnessing successful!\");\n    console.log(\"Transaction:\", witnessResult.data.witness_transaction_hash);\n} else {\n    console.error(\"Witnessing failed:\", witnessResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Verify the Aqua Tree\"\u003e\n\n```typescript\n// Fetch aqua tree from storage, database, or state\nconst aquaTree = witnessResult.data.aquaTree;\n\n// Prepare credentials for verification (needs Alchemy key for Ethereum witness)\nconst verifyCreds: CredentialsData = {\n    alchemy_key: \"your_alchemy_api_key\"\n};\n\n// Verify the complete tree\nconst verificationResult = await aquafier.verifyAquaTree(\n    aquaTree,\n    [aquaFileObject],  // Array of file objects\n    verifyCreds\n);\n\nif (verificationResult.isOk()) {\n    console.log(\"‚úì Verification successful!\");\n    console.log(\"Details:\", JSON.stringify(verificationResult.data, null, 2));\n} else {\n    console.log(\"‚úó Verification failed!\");\n    console.log(\"Details:\", JSON.stringify(verificationResult.data, null, 2));\n}\n```\n\u003c/Step\u003e\n\u003c/Steps\u003e\n\n### More Examples\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Complete Examples\" icon=\"github\" href=\"https://github.com/inblockio/aqua-js-sdk/tree/master/examples\"\u003e\n    Browse full working examples in the repository\n  \u003c/Card\u003e\n\n  \u003cCard title=\"API Documentation\" icon=\"book\" href=\"/previous_versions/version_3/tooling\"\u003e\n    Detailed API reference for JavaScript SDK\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Rust SDK Usage (v4)\n\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\n- Rust 1.70 or higher\n- Add to Cargo.toml: `aqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }`\n\u003c/Callout\u003e\n\n### Quick Example\n\n```rust\nuse aqua_rs_sdk::primitives::Method;\nuse aqua_rs_sdk::schema::file_data::FileData;\nuse aqua_rs_sdk::Aquafier;\nuse std::path::PathBuf;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Read file content\n    let filename = \"test.txt\".to_string();\n    let file_content = tokio::fs::read(\u0026filename).await?;\n\n    // Create file data\n    let file_data = FileData::new(\n        filename.clone(),\n        file_content,\n        PathBuf::from(format!(\"./{}\", filename)),\n    );\n\n    // Initialize Aquafier\n    let aquafier = Aquafier::new(None, None);\n\n    // Create genesis revision (notarize the file)\n    let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n    match result {\n        Ok(tree) =\u003e {\n            println!(\"‚úì Aqua chain created successfully!\");\n            println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Error: {:#?}\", e);\n        }\n    }\n\n    Ok(())\n}\n```\n\n### More Resources\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Rust SDK Guide\" icon=\"code\" href=\"/dev_tools/aqua_sdk\"\u003e\n    Complete guide for the Rust SDK\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Schema Reference\" icon=\"book\" href=\"/schema_reference/introduction\"\u003e\n    v4 protocol specifications\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Next Steps\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Use Cases\" icon=\"lightbulb\" href=\"/use_cases/introduction\"\u003e\n    Explore real-world applications\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Quick Start\" icon=\"rocket\" href=\"/quickstart\"\u003e\n    Build your first Aqua application\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples Repository\" icon=\"code\" href=\"https://github.com/inblockio/aqua-examples\"\u003e\n    Browse complete examples\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Get Support\" icon=\"mail\" href=\"mailto:info@inblock.io\"\u003e\n    Need help? Contact our team\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e"])</script><script>self.__next_f.push([1,"20:T3a85,"])</script><script>self.__next_f.push([1,"\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\nWe recommend completing the [Quick Start Guide](/quickstart) before diving into development details.\n\u003c/Callout\u003e\n\n## Choose Your SDK\n\nAqua Protocol offers SDKs for different use cases:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Rust SDK (v4)\" icon=\"code\" href=\"/dev_tools/aqua_sdk\"\u003e\n    **Beta** - Template system, WASM support, cross-platform\n\n    Best for: New projects, performance-critical applications\n  \u003c/Card\u003e\n\n  \u003cCard title=\"JavaScript SDK (v3)\" icon=\"code\" href=\"/previous_versions/version_3/tooling\"\u003e\n    **Stable** - Production-ready, Node.js/Web/React Native\n\n    Best for: Web applications, existing JavaScript projects\n  \u003c/Card\u003e\n\n  \u003cCard title=\"CLI Tool (v4)\" icon=\"terminal\" href=\"/dev_tools/aqua_cli\"\u003e\n    Command-line tool for quick operations\n\n    Best for: Testing, CI/CD, scripting\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Aquafier API (v3)\" icon=\"globe\" href=\"/dev_tools/aquafier_api\"\u003e\n    Web-based API for notarization\n\n    Best for: No-code integration, demos\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Signing Methods\n\nAqua Protocol supports multiple signature types for different use cases:\n\n| Method | Protocol Version | Use Case | Trust Model |\n|--------|-----------------|----------|-------------|\n| **DID (JWS)** | v3, v4 | Decentralized identities | W3C DID standard |\n| **Ethereum (EIP-191)** | v3, v4 | Blockchain-native apps | Ethereum addresses |\n| **RSA** | v4 only | Traditional PKI | Certificate authorities |\n| **P12 Certificates** | v3 only | Enterprise/legal docs | Certificate authorities |\n\n\n### Signing Setup Details\n\n\u003cAccordion title=\"DID Signature (W3C Decentralized Identifiers)\"\u003e\n**What you need**: A DID key pair\n\n**How to generate**:\n\n**Option 1: Using JavaScript**\n```bash\nnpm install @digitalcredentials/did-method-key\n```\n\n```javascript\nimport { Ed25519VerificationKey2020 } from '@digitalcredentials/ed25519-verification-key-2020';\nimport { X25519KeyAgreementKey2020 } from '@digitalcredentials/x25519-key-agreement-key-2020';\n\nconst keyPair = await Ed25519VerificationKey2020.generate();\nconst did = `did:key:${keyPair.publicKeyMultibase}`;\nconsole.log('DID:', did);\nconsole.log('Private Key:', keyPair.privateKeyMultibase);\n```\n\n**Option 2: Online Generator**\n- Visit [EBSI DID Generator](https://hub.ebsi.eu/tools/did-generator)\n- Click \"Generate Keys\"\n- Save your DID and private key securely\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Ethereum Signature (EIP-191)\"\u003e\n**What you need**: Ethereum wallet with private key or mnemonic\n\n**Two supported methods**:\n\n**1. MetaMask Browser Extension** (Recommended for development)\n- Install [MetaMask](https://metamask.io/) in your browser\n- Create or import a wallet\n- The SDK will prompt for signature when needed\n\n**2. Mnemonic/Private Key in Credentials File**\n\nCreate a `credentials.json` file:\n```json\n{\n  \"mnemonic\": \"your twelve word mnemonic phrase here...\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\nOr with private key:\n```json\n{\n  \"private_key\": \"0xYourPrivateKeyHex\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n\u003cCallout type=\"warning\" title=\"Security\"\u003e\nNever commit credentials.json to version control! Add it to `.gitignore`.\n\u003c/Callout\u003e\n\nCheck your SDK documentation ([Rust SDK](/dev_tools/aqua_sdk) | [JavaScript SDK](/previous_versions/version_3/tooling)) for how to pass credentials.\n\n**Protocol Support**: v3, v4\n\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"RSA Signature (v4 only)\"\u003e\n**What you need**: RSA key pair (2048-bit or higher)\n\n**Generate RSA keys**:\n\n```bash\n# Generate private key (2048-bit)\nopenssl genrsa -out private.pem 2048\n\n# Extract public key\nopenssl rsa -in private.pem -pubout -out public.pem\n\n# View keys\ncat private.pem\ncat public.pem\n```\n\n**For production**: Use keys from your organization's PKI infrastructure or certificate authority.\n\n**Protocol Support**: v4 only\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"P12 Certificate Signature (v3 only)\"\u003e\n**What you need**: PKCS#12 certificate file (.p12/.pfx) with password\n\n**For Development** (self-signed certificate):\n\n```bash\n# Generate private key\nopenssl genrsa -out private.key 2048\n\n# Create certificate signing request\nopenssl req -new -key private.key -out certificate.csr\n\n# For Windows/Git Bash, specify config:\n# openssl req -new -key private.key -out certificate.csr -config \"C:\\Program Files\\Git\\usr\\ssl\\openssl.cnf\"\n\n# Generate self-signed certificate (valid for 365 days)\nopenssl x509 -req -days 365 -in certificate.csr -signkey private.key -out certificate.crt\n\n# Create P12 file (you'll be prompted for export password)\nopenssl pkcs12 -export -out certificate.p12 -inkey private.key -in certificate.crt\n```\n\n**Convert to Base64** (required for SDK):\n```bash\n# macOS/Linux\nbase64 -i certificate.p12 -o certificate_base64.txt\n\n# Windows (PowerShell)\n[Convert]::ToBase64String([IO.File]::ReadAllBytes(\"certificate.p12\")) | Out-File certificate_base64.txt\n\n# Linux alternative\nbase64 certificate.p12 \u003e certificate_base64.txt\n```\n\n**For Production** (trusted certificate):\n\n **1. Purchase from Certificate Authority**:\n   - DigiCert, Sectigo, GlobalSign, etc.\n   - Request \"Code Signing\" or \"Document Signing\" certificate\n   - They'll provide a .p12/.pfx file directly\n\n**2. If you receive separate files** (.crt + .key + intermediate):\n   ```bash\n   openssl pkcs12 -export -out certificate.p12 \\\n       -inkey privatekey.key \\\n       -in certificate.crt \\\n       -certfile intermediate.crt\n   ```\n\n**Usage in SDK**:\n```json\n{\n  \"p12_content\": \"base64_encoded_p12_content_here\",\n  \"p12_password\": \"your_export_password\"\n}\n```\n\n**Protocol Support**: v3 only\n\u003c/Accordion\u003e\n\n## Witnessing Methods\n\nWitnessing anchors your Aqua revisions to external timestamping services for provable timestamps:\n\n| Method | Networks | Cost | Verification |\n|--------|----------|------|--------------|\n| **Ethereum** | Mainnet, Sepolia, Holesky | Gas fees (testnet: free) | Blockchain explorer |\n| **TSA** | RFC 3161 services | Free (public TSAs) | TSA verification |\n| **Nostr** | Nostr relays | Free | Nostr event verification |\n\n### Witnessing Setup Details\n\n\u003cAccordion title=\"TSA Witness (Time-Stamp Authority - RFC 3161)\"\u003e\n**What you need**: A TSA service URL\n\n**Free Public TSA Services**:\n\n```bash\n# DigiCert\nhttp://timestamp.digicert.com\n\n# Sectigo (formerly Comodo)\nhttp://timestamp.sectigo.com\nhttp://timestamp.comodoca.com\n\n# GlobalSign\nhttp://timestamp.globalsign.com/scripts/timstamp.dll\nhttp://timestamp.globalsign.com/tsa/r6advanced1\n\n# Entrust\nhttp://timestamp.entrust.net/TSS/RFC3161sha2TS\n```\n\n**Usage**: Simply provide the TSA URL to your SDK when witnessing.\n\n**Benefits**:\n- No blockchain required\n- Widely accepted standard (RFC 3161)\n- Free for most public TSAs\n- Instant timestamps\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Ethereum Witness\"\u003e\n**What you need**:\n1. Ethereum wallet (MetaMask or mnemonic/private key)\n2. ETH for gas fees (mainnet) or testnet ETH (Sepolia/Holesky)\n3. Alchemy API key for witness verification\n\n**Networks Supported**:\n- **Mainnet**: Production use, requires real ETH for gas\n- **Sepolia**: Testnet, free test ETH from faucets\n- **Holesky**: Testnet, free test ETH from faucets\n\n**Wallet Setup** (same as signing):\n\n**Option 1: MetaMask**\n- Install [MetaMask](https://metamask.io/)\n- Ensure you're on the correct network (mainnet/sepolia/holesky)\n- Have sufficient ETH for gas fees\n\n**Option 2: Credentials File**\n```json\n{\n  \"mnemonic\": \"your twelve word mnemonic phrase here...\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n**Get Test ETH** (for testnets):\n- Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)\n- Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)\n\n**Alchemy API Key** (for verification):\n1. Visit [alchemy.com](https://www.alchemy.com/)\n2. Create free account\n3. Create new app\n4. Copy API key\n5. [Detailed guide](https://www.alchemy.com/docs/how-to-create-access-keys)\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\u003cAccordion title=\"Nostr Witness\"\u003e\n**What you need**: Nostr secret key (nsec)\n\n**How to get a Nostr key**:\n\n**Option 1: Nostr Client App**\n1. Download a Nostr app:\n   - [Damus](https://damus.io/) (iOS)\n   - [Amethyst](https://github.com/vitorpamplona/amethyst) (Android)\n   - [Primal](https://primal.net/) (Web/Mobile)\n2. Create new account or log in\n3. App generates a key pair automatically\n4. Your secret key starts with `nsec1...`\n5. **Save it securely** - you'll need it for witnessing\n\n**Option 2: Web Generator**\n- Visit [nostr.com](https://nostr.com) or [nostrtool.com](https://nostrtool.com)\n- Click \"Generate Keys\"\n- Save your secret key (`nsec1...`)\n\n\u003cCallout type=\"warning\" title=\"Security\"\u003e\nYour Nostr secret key is permanent. Anyone with it can post as you on Nostr relays. Keep it secure!\n\u003c/Callout\u003e\n\n**Benefits**:\n- Fully decentralized (no blockchain fees)\n- Censorship-resistant\n- Fast propagation across relays\n- Free to use\n\n**Protocol Support**: v3, v4\n\u003c/Accordion\u003e\n\n\n\n## JavaScript SDK Usage (v3)\n\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\n- Node.js version 19 or higher\n- Install aqua-js-sdk: `npm install aqua-js-sdk`\n\u003c/Callout\u003e\n\n### Complete Workflow Example\n\nFollow these steps to notarize a file, sign it, and witness it using the JavaScript SDK (v3):\n\n\u003cSteps\u003e\n\u003cStep title=\"Create Genesis Revision\"\u003e\n\n```typescript\nimport Aquafier, { FileObject } from 'aqua-js-sdk';\nimport { readFileSync } from 'fs';\n\n// Read file content\nconst testFileContent = readFileSync(\"./test.txt\", 'utf-8');\n\n// Create file object\nconst aquaFileObject: FileObject = {\n    fileName: \"test.txt\",\n    fileContent: testFileContent,\n    path: \"./test.txt\"\n};\n\n// Initialize Aquafier\nconst aquafier = new Aquafier();\n\n// Create genesis revision (notarize the file)\nconst genesisResult = await aquafier.createGenesisRevision(aquaFileObject);\n\nif (genesisResult.isOk()) {\n    console.log(\"Genesis created successfully!\");\n    console.log(\"Aqua Tree:\", genesisResult.data.aquaTree);\n} else {\n    console.error(\"Error creating genesis:\", genesisResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Sign the Aqua Tree\"\u003e\n\n```typescript\nimport { AquaTreeWrapper, CredentialsData } from 'aqua-js-sdk';\n\n// Prepare credentials (for MetaMask, can be empty object)\nconst creds: CredentialsData = {};\n\n// Or for CLI signing with mnemonic:\n// const creds: CredentialsData = {\n//     mnemonic: \"your twelve word mnemonic here\",\n//     wallet_address: \"0xYourAddress\"\n// };\n\n// Create wrapper (empty string for revision means sign latest)\nconst aquaWrapper: AquaTreeWrapper = {\n    aquaTree: genesisResult.data.aquaTree,\n    fileObject: aquaFileObject,\n    revision: \"\"  // Sign latest revision\n};\n\n// Sign with MetaMask (or use \"cli\", \"did\", \"p12\")\nconst signedResult = await aquafier.signAquaTree(\n    aquaWrapper,\n    \"metamask\",  // Signature type\n    creds,\n    true         // Auto-increment\n);\n\nif (signedResult.isOk()) {\n    console.log(\"Signature added successfully!\");\n} else {\n    console.error(\"Signing failed:\", signedResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Witness on Blockchain\"\u003e\n\n```typescript\n// Update wrapper with signed tree\nconst witnessWrapper: AquaTreeWrapper = {\n    aquaTree: signedResult.data.aquaTree,\n    fileObject: aquaFileObject,\n    revision: \"\"  // Witness latest revision\n};\n\n// Witness on Ethereum Sepolia testnet\nconst witnessResult = await aquafier.witnessAquaTree(\n    witnessWrapper,\n    \"eth\",        // Witness type (eth, tsa, or nostr)\n    \"sepolia\",    // Network (sepolia, mainnet, holesky)\n    \"metamask\",   // Signing method\n    creds,\n    true          // Auto-increment\n);\n\nif (witnessResult.isOk()) {\n    console.log(\"Witnessing successful!\");\n    console.log(\"Transaction:\", witnessResult.data.witness_transaction_hash);\n} else {\n    console.error(\"Witnessing failed:\", witnessResult.error);\n}\n```\n\u003c/Step\u003e\n\n\u003cStep title=\"Verify the Aqua Tree\"\u003e\n\n```typescript\n// Fetch aqua tree from storage, database, or state\nconst aquaTree = witnessResult.data.aquaTree;\n\n// Prepare credentials for verification (needs Alchemy key for Ethereum witness)\nconst verifyCreds: CredentialsData = {\n    alchemy_key: \"your_alchemy_api_key\"\n};\n\n// Verify the complete tree\nconst verificationResult = await aquafier.verifyAquaTree(\n    aquaTree,\n    [aquaFileObject],  // Array of file objects\n    verifyCreds\n);\n\nif (verificationResult.isOk()) {\n    console.log(\"‚úì Verification successful!\");\n    console.log(\"Details:\", JSON.stringify(verificationResult.data, null, 2));\n} else {\n    console.log(\"‚úó Verification failed!\");\n    console.log(\"Details:\", JSON.stringify(verificationResult.data, null, 2));\n}\n```\n\u003c/Step\u003e\n\u003c/Steps\u003e\n\n### More Examples\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Complete Examples\" icon=\"github\" href=\"https://github.com/inblockio/aqua-js-sdk/tree/master/examples\"\u003e\n    Browse full working examples in the repository\n  \u003c/Card\u003e\n\n  \u003cCard title=\"API Documentation\" icon=\"book\" href=\"/previous_versions/version_3/tooling\"\u003e\n    Detailed API reference for JavaScript SDK\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Rust SDK Usage (v4)\n\n\u003cCallout type=\"info\" title=\"Prerequisites\"\u003e\n- Rust 1.70 or higher\n- Add to Cargo.toml: `aqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }`\n\u003c/Callout\u003e\n\n### Quick Example\n\n```rust\nuse aqua_rs_sdk::primitives::Method;\nuse aqua_rs_sdk::schema::file_data::FileData;\nuse aqua_rs_sdk::Aquafier;\nuse std::path::PathBuf;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Read file content\n    let filename = \"test.txt\".to_string();\n    let file_content = tokio::fs::read(\u0026filename).await?;\n\n    // Create file data\n    let file_data = FileData::new(\n        filename.clone(),\n        file_content,\n        PathBuf::from(format!(\"./{}\", filename)),\n    );\n\n    // Initialize Aquafier\n    let aquafier = Aquafier::new(None, None);\n\n    // Create genesis revision (notarize the file)\n    let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n    match result {\n        Ok(tree) =\u003e {\n            println!(\"‚úì Aqua chain created successfully!\");\n            println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Error: {:#?}\", e);\n        }\n    }\n\n    Ok(())\n}\n```\n\n### More Resources\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Rust SDK Guide\" icon=\"code\" href=\"/dev_tools/aqua_sdk\"\u003e\n    Complete guide for the Rust SDK\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Schema Reference\" icon=\"book\" href=\"/schema_reference/introduction\"\u003e\n    v4 protocol specifications\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Next Steps\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Use Cases\" icon=\"lightbulb\" href=\"/use_cases/introduction\"\u003e\n    Explore real-world applications\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Quick Start\" icon=\"rocket\" href=\"/quickstart\"\u003e\n    Build your first Aqua application\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples Repository\" icon=\"code\" href=\"https://github.com/inblockio/aqua-examples\"\u003e\n    Browse complete examples\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Get Support\" icon=\"mail\" href=\"mailto:info@inblock.io\"\u003e\n    Need help? Contact our team\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e"])</script><script>self.__next_f.push([1,"21:T348e,"])</script><script>self.__next_f.push([1,"\n\nThis section provides the complete technical specification for Aqua Protocol v4. Here you'll find detailed documentation on data structures, revision types, validation rules, and implementation requirements.\n\n## What is Aqua Protocol?\n\nAqua Protocol is a cryptographic protocol for creating verifiable, timestamped chains of revisions with signatures and blockchain anchoring. It enables:\n\n- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is detectable\n- **Multi-Party Signatures**: Multiple parties can sign revisions for authentication\n- **Blockchain Timestamping**: Anchor revisions to Ethereum, Nostr, or TSA for provable timestamps\n- **Provenance Tracking**: Link revisions to track data flow and transformations\n- **Template Validation**: Enforce data schemas with JSON Schema\n\n## Core Data Structure\n\nWhen you notarize content with Aqua Protocol, the output is a JSON file called an **Aqua Tree**.\n\n### Aqua Tree Structure\n\n```json\n{\n  \"revisions\": {\n    \"0xhash1...\": { /* revision object */ },\n    \"0xhash2...\": { /* revision object */ }\n  },\n  \"file_index\": {\n    \"0xcontenthash1...\": \"document.pdf\",\n    \"0xcontenthash2...\": \"image.png\"\n  }\n}\n```\n\nThe Aqua Tree contains two primary components:\n\n- **[Revisions](/schema_reference/revision)**: Map of verification hashes to revision objects\n- **[File Index](/schema_reference/file_index)**: Map of content hashes to filenames\n\nSee the [Aqua Tree documentation](/schema_reference/aqua_tree) for complete details.\n\n## Revision Types\n\nAqua Protocol v4 defines five revision types, each serving a specific purpose:\n\n### 1. Object Revision\n**Purpose**: Store data content (documents, files, structured data)\n\n**Use for**:\n- Genesis revisions (first revision in a chain)\n- Document updates and modifications\n- Data snapshots\n\n**Learn more**: [Object Revision Reference](/schema_reference/object_revision)\n\n### 2. Template Revision\n**Purpose**: Define data schemas and validation rules\n\n**Use for**:\n- Enforcing data structure with JSON Schema\n- Creating reusable data models\n- Validating object revision content\n\n**Learn more**: [Template Revision Reference](/schema_reference/template_revision)\n\n### 3. Signature Revision\n**Purpose**: Add cryptographic signatures for authentication\n\n**Use for**:\n- Proving authorship and authorization\n- Multi-party approval workflows\n- Non-repudiation\n\n**Signature Types**:\n- **RSA**: Traditional RSA signatures\n- **EIP-191**: Ethereum-style signatures\n- **DID:JWS**: Decentralized identifier signatures\n\n**Learn more**: [Signature Revision Reference](/schema_reference/signing_revision)\n\n### 4. Witness Revision\n**Purpose**: Anchor revisions to blockchain for timestamping\n\n**Use for**:\n- Proving existence at specific time\n- Creating tamper-proof timestamps\n- Regulatory compliance\n\n**Networks Supported**:\n- Ethereum (mainnet, Sepolia, Holesky)\n- Nostr\n- TSA (RFC 3161 Timestamping Authorities)\n\n**Learn more**: [Witness Revision Reference](/schema_reference/witness_revision)\n\n### 5. Link Revision\n**Purpose**: Connect to other Aqua Trees\n\n**Use for**:\n- Referencing dependencies\n- Building composite documents\n- Creating provenance graphs\n\n**Learn more**: [Link Revision Reference](/schema_reference/link_revision)\n\n## Common Revision Fields\n\nAll revision types share these common fields:\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revision_type` | string | Yes | Hash identifying the revision type |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when revision was created |\n| `version` | string | Yes | Protocol version: `https://aqua-protocol.org/docs/v4/schema` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `previous_hash` | string | No | Hash of previous revision (absent in genesis) |\n\nAdditional fields depend on the specific revision type.\n\n## Canonicalization Methods\n\nAqua Protocol v4 supports two methods for computing revision hashes:\n\n### Scalar Method\n**Best for**: Simple, straightforward hashing\n\n```json\n{\n  \"method\": \"scalar\",\n  // Content hashed as-is\n}\n```\n\nThe entire revision is serialized and hashed directly.\n\n### Tree Method\n**Best for**: Selective disclosure, large content\n\n```json\n{\n  \"method\": \"tree\",\n  \"leaves\": [\n    \"0xleaf1hash...\",\n    \"0xleaf2hash...\"\n  ]\n}\n```\n\nContent is broken into leaves, each hashed separately, then combined in a Merkle tree.\n\n## Verification Hash\n\nEach revision has a **verification hash** computed from its canonical form using SHA3-256:\n\n```\nverification_hash = SHA3-256(canonical_revision_json)\n```\n\nThis hash serves as:\n- Unique identifier for the revision\n- Key in the revisions map\n- Reference in `previous_hash` fields\n- Proof of integrity\n\n## Revision Chains\n\nRevisions form chains through `previous_hash` references:\n\n```\nGenesis (no previous_hash)\n    ‚Üì\nRevision A (previous_hash ‚Üí Genesis)\n    ‚Üì\nSignature B (previous_hash ‚Üí Revision A)\n    ‚Üì\nWitness C (previous_hash ‚Üí Signature B)\n```\n\n### Genesis Revision\n\nThe first revision in a chain:\n- Has no `previous_hash` field (or `previous_hash: null`)\n- Typically an object or template revision\n- Establishes the chain's starting point\n\n### Subsequent Revisions\n\nAll revisions after genesis:\n- Must have `previous_hash` pointing to an existing revision\n- Build upon the chain's history\n- Can be any revision type\n\n## Example: Complete Aqua Tree\n\nHere's a minimal example showing a document with signature and witness:\n\n```json\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"application/pdf\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Contract Document\"\n      }\n    },\n    \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"nonce\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d\",\n      \"local_timestamp\": 1704067260,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x8c9d0e1f...\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    },\n    \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\": {\n      \"revision_type\": \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\",\n      \"nonce\": \"0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e\",\n      \"local_timestamp\": 1704067320,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"merkle_root\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n      \"timestamp\": 1704067320,\n      \"network\": \"sepolia\",\n      \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      \"transaction_hash\": \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\",\n      \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n      \"merkle_proof\": []\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"contract.pdf\"\n  }\n}\n```\n\nThis tree contains:\n1. **Object Revision** (genesis): Document content hash\n2. **Signature Revision**: EIP-191 signature from wallet\n3. **Witness Revision**: Ethereum Sepolia timestamp\n\n## Built-in Templates\n\nAqua Protocol v4 includes several built-in templates:\n\n| Template | Purpose | Hash |\n|----------|---------|------|\n| **Object** | Generic object revision | `0x742b74c87ccd7bfc...` |\n| **Template** | Template definition | `0x9c2f4e6a8c0b1d3f...` |\n| **Signature** | Signature revision | `0x8e5b2f9c4d3a1e7b...` |\n| **Witness** | Witness revision | `0x1c3e5a7b9d2f4e6a...` |\n| **Link** | Link revision | `0x4a6c8e0b2d4f6a8c...` |\n| **File** | File content | `0x5b7d9f1a3c5e7b9d...` |\n| **Domain** | Domain name | `0x6c8e0b2d4f6a8c0b...` |\n| **Email** | Email address | `0x7d9f1a3c5e7b9d2f...` |\n\nEach built-in template has a specific hash that serves as its `revision_type` identifier.\n\n## Hash Format\n\nAll hashes in Aqua Protocol v4 use consistent formatting:\n\n- **Algorithm**: SHA3-256 (FIPS 202)\n- **Format**: Hex string prefixed with `0x`\n- **Length**: 66 characters (`0x` + 64 hex digits)\n- **Example**: `0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`\n\n## Timestamp Format\n\nTimestamps use Unix epoch format:\n\n- **Type**: Integer (seconds since January 1, 1970 UTC)\n- **Example**: `1704067200` = January 1, 2024 00:00:00 UTC\n\n## Validation Rules\n\nAn Aqua Tree is valid if:\n\n1. **All revisions have valid hashes**: Computed hash matches the key\n2. **Previous hashes exist**: All `previous_hash` values reference existing revisions (except genesis)\n3. **No cycles**: Following `previous_hash` eventually reaches genesis\n4. **Signatures verify**: All signature revisions have valid cryptographic signatures\n5. **Templates validate**: Object revisions with templates match their schema\n6. **Witnesses exist**: Witness revisions reference valid blockchain transactions\n\n## Schema Version\n\nAll revisions in Aqua Protocol v4 use:\n\n```json\n{\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\"\n}\n```\n\nThis identifies the protocol version and schema specification.\n\n## Implementation Guidelines\n\n### Creating Revisions\n\n1. **Generate nonce**: Create random 16-byte hex string\n2. **Set timestamp**: Use current Unix timestamp\n3. **Add content**: Include revision-specific fields\n4. **Set previous_hash**: Reference prior revision (if not genesis)\n5. **Compute hash**: Canonicalize and hash the revision\n6. **Use hash as key**: Store in revisions map with hash as key\n\n### Verifying Chains\n\n1. **Find genesis**: Locate revision with no `previous_hash`\n2. **Traverse chain**: Follow `previous_hash` references\n3. **Verify hashes**: Recompute and compare each verification hash\n4. **Check signatures**: Validate all cryptographic signatures\n5. **Verify witnesses**: Check blockchain transactions\n6. **Validate templates**: Ensure object data matches schemas\n\n## File Storage\n\nAqua Trees are typically stored as JSON files:\n\n```bash\ndocument.aqua.json\ncontract-2024-01-01.aqua.json\n```\n\nThe `.aqua.json` extension identifies Aqua Protocol files.\n\n## Use Cases\n\nAqua Protocol v4 schema supports diverse applications:\n\n- **Document Notarization**: Legal documents, contracts, agreements\n- **Supply Chain**: Product tracking, provenance verification\n- **Credentials**: Diplomas, certificates, licenses\n- **Data Integrity**: Scientific data, audit logs, compliance records\n- **Multi-Party Workflows**: Approvals, reviews, collaborative editing\n\n## Navigation\n\nExplore the detailed specifications for each component:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Aqua Tree\" icon=\"tree\" href=\"/schema_reference/aqua_tree\"\u003e\n    Root data structure containing revisions and file index\n  \u003c/Card\u003e\n\n  \u003cCard title=\"File Index\" icon=\"folder\" href=\"/schema_reference/file_index\"\u003e\n    Mapping content hashes to filenames\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Revision Types\" icon=\"code-branch\" href=\"/schema_reference/revision\"\u003e\n    Overview of all revision types\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Object Revision\" icon=\"file\" href=\"/schema_reference/object_revision\"\u003e\n    Store document and data content\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Template Revision\" icon=\"table\" href=\"/schema_reference/template_revision\"\u003e\n    Define schemas with JSON Schema\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Signature Revision\" icon=\"signature\" href=\"/schema_reference/signing_revision\"\u003e\n    Add cryptographic signatures\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Witness Revision\" icon=\"clock\" href=\"/schema_reference/witness_revision\"\u003e\n    Blockchain timestamping\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Link Revision\" icon=\"link\" href=\"/schema_reference/link_revision\"\u003e\n    Connect to other Aqua Trees\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Additional Resources\n\n- [Quick Start Guide](/quickstart) - Get started with Aqua Protocol\n- [Version 4 Introduction](/previous_versions/version_4/version_4) - Overview of v4 features\n- [Use Cases](/use_cases/introduction) - Real-world applications\n- [Aqua SDK](/dev_tools/aqua_sdk) - Rust SDK for implementation\n- [Aqua CLI](/dev_tools/aqua_cli) - Command-line tool\n\n## Version History\n\n**Current Version**: 4.0.0 (Beta)\n\nAqua Protocol v4 introduces:\n- Template system with JSON Schema validation\n- Enhanced revision type system\n- Improved canonicalization methods\n- Better support for complex data structures\n\nFor previous versions, see:\n- [Version 3 Documentation](/previous_versions/version_3/introduction) - JavaScript SDK (Stable)\n- [Version 2 Documentation](/previous_versions/version_2/introduction) - Legacy\n- [Version 1 Documentation](/previous_versions/version_1/introduction) - Legacy\n"])</script><script>self.__next_f.push([1,"22:T348e,"])</script><script>self.__next_f.push([1,"\n\nThis section provides the complete technical specification for Aqua Protocol v4. Here you'll find detailed documentation on data structures, revision types, validation rules, and implementation requirements.\n\n## What is Aqua Protocol?\n\nAqua Protocol is a cryptographic protocol for creating verifiable, timestamped chains of revisions with signatures and blockchain anchoring. It enables:\n\n- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is detectable\n- **Multi-Party Signatures**: Multiple parties can sign revisions for authentication\n- **Blockchain Timestamping**: Anchor revisions to Ethereum, Nostr, or TSA for provable timestamps\n- **Provenance Tracking**: Link revisions to track data flow and transformations\n- **Template Validation**: Enforce data schemas with JSON Schema\n\n## Core Data Structure\n\nWhen you notarize content with Aqua Protocol, the output is a JSON file called an **Aqua Tree**.\n\n### Aqua Tree Structure\n\n```json\n{\n  \"revisions\": {\n    \"0xhash1...\": { /* revision object */ },\n    \"0xhash2...\": { /* revision object */ }\n  },\n  \"file_index\": {\n    \"0xcontenthash1...\": \"document.pdf\",\n    \"0xcontenthash2...\": \"image.png\"\n  }\n}\n```\n\nThe Aqua Tree contains two primary components:\n\n- **[Revisions](/schema_reference/revision)**: Map of verification hashes to revision objects\n- **[File Index](/schema_reference/file_index)**: Map of content hashes to filenames\n\nSee the [Aqua Tree documentation](/schema_reference/aqua_tree) for complete details.\n\n## Revision Types\n\nAqua Protocol v4 defines five revision types, each serving a specific purpose:\n\n### 1. Object Revision\n**Purpose**: Store data content (documents, files, structured data)\n\n**Use for**:\n- Genesis revisions (first revision in a chain)\n- Document updates and modifications\n- Data snapshots\n\n**Learn more**: [Object Revision Reference](/schema_reference/object_revision)\n\n### 2. Template Revision\n**Purpose**: Define data schemas and validation rules\n\n**Use for**:\n- Enforcing data structure with JSON Schema\n- Creating reusable data models\n- Validating object revision content\n\n**Learn more**: [Template Revision Reference](/schema_reference/template_revision)\n\n### 3. Signature Revision\n**Purpose**: Add cryptographic signatures for authentication\n\n**Use for**:\n- Proving authorship and authorization\n- Multi-party approval workflows\n- Non-repudiation\n\n**Signature Types**:\n- **RSA**: Traditional RSA signatures\n- **EIP-191**: Ethereum-style signatures\n- **DID:JWS**: Decentralized identifier signatures\n\n**Learn more**: [Signature Revision Reference](/schema_reference/signing_revision)\n\n### 4. Witness Revision\n**Purpose**: Anchor revisions to blockchain for timestamping\n\n**Use for**:\n- Proving existence at specific time\n- Creating tamper-proof timestamps\n- Regulatory compliance\n\n**Networks Supported**:\n- Ethereum (mainnet, Sepolia, Holesky)\n- Nostr\n- TSA (RFC 3161 Timestamping Authorities)\n\n**Learn more**: [Witness Revision Reference](/schema_reference/witness_revision)\n\n### 5. Link Revision\n**Purpose**: Connect to other Aqua Trees\n\n**Use for**:\n- Referencing dependencies\n- Building composite documents\n- Creating provenance graphs\n\n**Learn more**: [Link Revision Reference](/schema_reference/link_revision)\n\n## Common Revision Fields\n\nAll revision types share these common fields:\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revision_type` | string | Yes | Hash identifying the revision type |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when revision was created |\n| `version` | string | Yes | Protocol version: `https://aqua-protocol.org/docs/v4/schema` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `previous_hash` | string | No | Hash of previous revision (absent in genesis) |\n\nAdditional fields depend on the specific revision type.\n\n## Canonicalization Methods\n\nAqua Protocol v4 supports two methods for computing revision hashes:\n\n### Scalar Method\n**Best for**: Simple, straightforward hashing\n\n```json\n{\n  \"method\": \"scalar\",\n  // Content hashed as-is\n}\n```\n\nThe entire revision is serialized and hashed directly.\n\n### Tree Method\n**Best for**: Selective disclosure, large content\n\n```json\n{\n  \"method\": \"tree\",\n  \"leaves\": [\n    \"0xleaf1hash...\",\n    \"0xleaf2hash...\"\n  ]\n}\n```\n\nContent is broken into leaves, each hashed separately, then combined in a Merkle tree.\n\n## Verification Hash\n\nEach revision has a **verification hash** computed from its canonical form using SHA3-256:\n\n```\nverification_hash = SHA3-256(canonical_revision_json)\n```\n\nThis hash serves as:\n- Unique identifier for the revision\n- Key in the revisions map\n- Reference in `previous_hash` fields\n- Proof of integrity\n\n## Revision Chains\n\nRevisions form chains through `previous_hash` references:\n\n```\nGenesis (no previous_hash)\n    ‚Üì\nRevision A (previous_hash ‚Üí Genesis)\n    ‚Üì\nSignature B (previous_hash ‚Üí Revision A)\n    ‚Üì\nWitness C (previous_hash ‚Üí Signature B)\n```\n\n### Genesis Revision\n\nThe first revision in a chain:\n- Has no `previous_hash` field (or `previous_hash: null`)\n- Typically an object or template revision\n- Establishes the chain's starting point\n\n### Subsequent Revisions\n\nAll revisions after genesis:\n- Must have `previous_hash` pointing to an existing revision\n- Build upon the chain's history\n- Can be any revision type\n\n## Example: Complete Aqua Tree\n\nHere's a minimal example showing a document with signature and witness:\n\n```json\n{\n  \"revisions\": {\n    \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\": {\n      \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n      \"local_timestamp\": 1704067200,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"payload\": {\n        \"payload_type\": \"application/pdf\",\n        \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n        \"hash_type\": \"FIPS_202-SHA3-256\",\n        \"descriptor\": \"Contract Document\"\n      }\n    },\n    \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\": {\n      \"revision_type\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"nonce\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d\",\n      \"local_timestamp\": 1704067260,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n      \"signature_type\": \"eip191\",\n      \"signature\": \"0x8c9d0e1f...\",\n      \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n    },\n    \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\": {\n      \"revision_type\": \"0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f\",\n      \"nonce\": \"0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e\",\n      \"local_timestamp\": 1704067320,\n      \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n      \"method\": \"scalar\",\n      \"hash_type\": \"FIPS_202-SHA3-256\",\n      \"previous_hash\": \"0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\",\n      \"merkle_root\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n      \"timestamp\": 1704067320,\n      \"network\": \"sepolia\",\n      \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      \"transaction_hash\": \"0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9\",\n      \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n      \"merkle_proof\": []\n    }\n  },\n  \"file_index\": {\n    \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\": \"contract.pdf\"\n  }\n}\n```\n\nThis tree contains:\n1. **Object Revision** (genesis): Document content hash\n2. **Signature Revision**: EIP-191 signature from wallet\n3. **Witness Revision**: Ethereum Sepolia timestamp\n\n## Built-in Templates\n\nAqua Protocol v4 includes several built-in templates:\n\n| Template | Purpose | Hash |\n|----------|---------|------|\n| **Object** | Generic object revision | `0x742b74c87ccd7bfc...` |\n| **Template** | Template definition | `0x9c2f4e6a8c0b1d3f...` |\n| **Signature** | Signature revision | `0x8e5b2f9c4d3a1e7b...` |\n| **Witness** | Witness revision | `0x1c3e5a7b9d2f4e6a...` |\n| **Link** | Link revision | `0x4a6c8e0b2d4f6a8c...` |\n| **File** | File content | `0x5b7d9f1a3c5e7b9d...` |\n| **Domain** | Domain name | `0x6c8e0b2d4f6a8c0b...` |\n| **Email** | Email address | `0x7d9f1a3c5e7b9d2f...` |\n\nEach built-in template has a specific hash that serves as its `revision_type` identifier.\n\n## Hash Format\n\nAll hashes in Aqua Protocol v4 use consistent formatting:\n\n- **Algorithm**: SHA3-256 (FIPS 202)\n- **Format**: Hex string prefixed with `0x`\n- **Length**: 66 characters (`0x` + 64 hex digits)\n- **Example**: `0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`\n\n## Timestamp Format\n\nTimestamps use Unix epoch format:\n\n- **Type**: Integer (seconds since January 1, 1970 UTC)\n- **Example**: `1704067200` = January 1, 2024 00:00:00 UTC\n\n## Validation Rules\n\nAn Aqua Tree is valid if:\n\n1. **All revisions have valid hashes**: Computed hash matches the key\n2. **Previous hashes exist**: All `previous_hash` values reference existing revisions (except genesis)\n3. **No cycles**: Following `previous_hash` eventually reaches genesis\n4. **Signatures verify**: All signature revisions have valid cryptographic signatures\n5. **Templates validate**: Object revisions with templates match their schema\n6. **Witnesses exist**: Witness revisions reference valid blockchain transactions\n\n## Schema Version\n\nAll revisions in Aqua Protocol v4 use:\n\n```json\n{\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\"\n}\n```\n\nThis identifies the protocol version and schema specification.\n\n## Implementation Guidelines\n\n### Creating Revisions\n\n1. **Generate nonce**: Create random 16-byte hex string\n2. **Set timestamp**: Use current Unix timestamp\n3. **Add content**: Include revision-specific fields\n4. **Set previous_hash**: Reference prior revision (if not genesis)\n5. **Compute hash**: Canonicalize and hash the revision\n6. **Use hash as key**: Store in revisions map with hash as key\n\n### Verifying Chains\n\n1. **Find genesis**: Locate revision with no `previous_hash`\n2. **Traverse chain**: Follow `previous_hash` references\n3. **Verify hashes**: Recompute and compare each verification hash\n4. **Check signatures**: Validate all cryptographic signatures\n5. **Verify witnesses**: Check blockchain transactions\n6. **Validate templates**: Ensure object data matches schemas\n\n## File Storage\n\nAqua Trees are typically stored as JSON files:\n\n```bash\ndocument.aqua.json\ncontract-2024-01-01.aqua.json\n```\n\nThe `.aqua.json` extension identifies Aqua Protocol files.\n\n## Use Cases\n\nAqua Protocol v4 schema supports diverse applications:\n\n- **Document Notarization**: Legal documents, contracts, agreements\n- **Supply Chain**: Product tracking, provenance verification\n- **Credentials**: Diplomas, certificates, licenses\n- **Data Integrity**: Scientific data, audit logs, compliance records\n- **Multi-Party Workflows**: Approvals, reviews, collaborative editing\n\n## Navigation\n\nExplore the detailed specifications for each component:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Aqua Tree\" icon=\"tree\" href=\"/schema_reference/aqua_tree\"\u003e\n    Root data structure containing revisions and file index\n  \u003c/Card\u003e\n\n  \u003cCard title=\"File Index\" icon=\"folder\" href=\"/schema_reference/file_index\"\u003e\n    Mapping content hashes to filenames\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Revision Types\" icon=\"code-branch\" href=\"/schema_reference/revision\"\u003e\n    Overview of all revision types\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Object Revision\" icon=\"file\" href=\"/schema_reference/object_revision\"\u003e\n    Store document and data content\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Template Revision\" icon=\"table\" href=\"/schema_reference/template_revision\"\u003e\n    Define schemas with JSON Schema\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Signature Revision\" icon=\"signature\" href=\"/schema_reference/signing_revision\"\u003e\n    Add cryptographic signatures\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Witness Revision\" icon=\"clock\" href=\"/schema_reference/witness_revision\"\u003e\n    Blockchain timestamping\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Link Revision\" icon=\"link\" href=\"/schema_reference/link_revision\"\u003e\n    Connect to other Aqua Trees\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Additional Resources\n\n- [Quick Start Guide](/quickstart) - Get started with Aqua Protocol\n- [Version 4 Introduction](/previous_versions/version_4/version_4) - Overview of v4 features\n- [Use Cases](/use_cases/introduction) - Real-world applications\n- [Aqua SDK](/dev_tools/aqua_sdk) - Rust SDK for implementation\n- [Aqua CLI](/dev_tools/aqua_cli) - Command-line tool\n\n## Version History\n\n**Current Version**: 4.0.0 (Beta)\n\nAqua Protocol v4 introduces:\n- Template system with JSON Schema validation\n- Enhanced revision type system\n- Improved canonicalization methods\n- Better support for complex data structures\n\nFor previous versions, see:\n- [Version 3 Documentation](/previous_versions/version_3/introduction) - JavaScript SDK (Stable)\n- [Version 2 Documentation](/previous_versions/version_2/introduction) - Legacy\n- [Version 1 Documentation](/previous_versions/version_1/introduction) - Legacy\n"])</script><script>self.__next_f.push([1,"23:T13d0,"])</script><script>self.__next_f.push([1,"\n# Aqua Protocol v4\n\nAqua Protocol v4 is the latest version of the protocol, introducing significant improvements in structure, flexibility, and capabilities. This version is currently in beta.\n\n## Overview\n\nAqua Protocol v4 provides a robust framework for creating cryptographically verifiable chains of revisions. Each revision in a chain can represent different types of operations, from storing data to signing, witnessing, and linking to other chains.\n\n## Core Concepts\n\n### Revisions\n\nA revision is the fundamental unit in Aqua Protocol. There are five types of revisions in v4:\n\n1. **Object Revision** - Stores data with an associated template\n2. **Template Revision** - Defines the schema for object revisions\n3. **Signature Revision** - Adds cryptographic signatures to verify authenticity\n4. **Witness Revision** - Provides timestamped proof of existence via blockchain\n5. **Link Revision** - Creates verifiable connections to other revision chains\n\n### Revision Chains\n\nRevisions form chains by referencing previous revisions through cryptographic hashes. The first revision in a chain is called the \"genesis revision\" and has no previous revision reference.\n\n### Methods\n\nAqua Protocol v4 supports two canonicalization methods:\n\n- **scalar**: Direct JSON canonicalization (default for most use cases)\n- **tree**: Merkle tree-based canonicalization for large datasets\n\n### Hash Types\n\nCurrently, v4 supports:\n- **FIPS_202-SHA3-256**: SHA-3 256-bit hashing algorithm\n\n## Common Fields\n\nAll revision types share these common fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `version` | string | Protocol version URL: `https://aqua-protocol.org/docs/v4/schema` |\n| `revision_type` | string/RevisionLink | Type identifier for the revision |\n| `nonce` | string | Random 16-byte hex string (prefixed with `0x`) for uniqueness |\n| `local_timestamp` | number | Unix timestamp when the revision was created |\n| `method` | string | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Hashing algorithm: `\"FIPS_202-SHA3-256\"` |\n| `previous_revision` | string | Hash reference to the previous revision (optional for genesis) |\n\n## Schema Structure\n\nThe v4 schema is designed to be:\n\n- **Extensible**: New revision types can be added without breaking existing chains\n- **Verifiable**: Every revision can be independently verified through hash computation\n- **Composable**: Chains can link to other chains, creating complex data structures\n- **Flexible**: Templates allow custom data structures while maintaining validation\n\n## Key Improvements from Previous Versions\n\n### 1. Unified Revision Structure\nAll revision types follow a consistent structure with common fields, making implementation and validation simpler.\n\n### 2. Template-Based Validation\nObject revisions reference templates via hash, ensuring data conformity to predefined schemas.\n\n### 3. Multiple Signature Types\nSupport for RSA, Ethereum (EIP-191), and DID-based signatures provides flexibility for different use cases.\n\n### 4. Enhanced Witnessing\nImproved witness structure with detailed transaction information and merkle proof support.\n\n### 5. Explicit Linking\nLink revisions create verifiable connections between separate revision chains.\n\n## Getting Started\n\nTo understand the v4 schema in detail, visit the [Schema Reference](/schema_reference/introduction) section, where each revision type is documented with examples and field specifications.\n\n## Tooling\n\n### Aqua RS SDK\n\nThe official Rust SDK for Aqua Protocol v4 provides:\n- Type-safe revision creation and validation\n- Cryptographic operations (signing, hashing)\n- Witnessing capabilities (Ethereum, Nostr, TSA)\n- WASM compilation for web applications\n\n**Repository**: [github.com/inblockio/aqua-rs-sdk](https://github.com/inblockio/aqua-rs-sdk)\n\n**Installation:**\n```bash\n# For Rust projects\ncargo add aqua-rs-sdk\n\n# For WASM builds\nwasm-pack build --target web --no-default-features --features wasm\n```\n\n### CLI Tools\n\nCommand-line utilities built on the v4 SDK enable:\n- Creating and validating revision chains\n- Signing revisions with various methods\n- Witnessing to blockchain networks\n- Verifying complete chains\n\n## Use Cases\n\nAqua Protocol v4 is designed for:\n\n- **Document Integrity**: Verifiable audit trails for documents and data\n- **Supply Chain**: Tracking provenance and authenticity\n- **Digital Identity**: Self-sovereign identity with verifiable credentials\n- **Notarization**: Timestamped proof of existence\n- **Data Provenance**: Complete history tracking with cryptographic guarantees\n- **Decentralized Attestations**: Peer-to-peer verification without central authorities\n\n## Next Steps\n\n- Explore the [Schema Reference](/schema_reference/introduction) to understand each revision type\n- Review example revision chains in the SDK repository\n- Try the CLI tools to create your first revision chain\n- Read about specific use cases and implementation patterns\n\nFor questions or feedback about v4, please visit the [Aqua Protocol GitHub repository](https://github.com/inblockio).\n"])</script><script>self.__next_f.push([1,"24:T13d0,"])</script><script>self.__next_f.push([1,"\n# Aqua Protocol v4\n\nAqua Protocol v4 is the latest version of the protocol, introducing significant improvements in structure, flexibility, and capabilities. This version is currently in beta.\n\n## Overview\n\nAqua Protocol v4 provides a robust framework for creating cryptographically verifiable chains of revisions. Each revision in a chain can represent different types of operations, from storing data to signing, witnessing, and linking to other chains.\n\n## Core Concepts\n\n### Revisions\n\nA revision is the fundamental unit in Aqua Protocol. There are five types of revisions in v4:\n\n1. **Object Revision** - Stores data with an associated template\n2. **Template Revision** - Defines the schema for object revisions\n3. **Signature Revision** - Adds cryptographic signatures to verify authenticity\n4. **Witness Revision** - Provides timestamped proof of existence via blockchain\n5. **Link Revision** - Creates verifiable connections to other revision chains\n\n### Revision Chains\n\nRevisions form chains by referencing previous revisions through cryptographic hashes. The first revision in a chain is called the \"genesis revision\" and has no previous revision reference.\n\n### Methods\n\nAqua Protocol v4 supports two canonicalization methods:\n\n- **scalar**: Direct JSON canonicalization (default for most use cases)\n- **tree**: Merkle tree-based canonicalization for large datasets\n\n### Hash Types\n\nCurrently, v4 supports:\n- **FIPS_202-SHA3-256**: SHA-3 256-bit hashing algorithm\n\n## Common Fields\n\nAll revision types share these common fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `version` | string | Protocol version URL: `https://aqua-protocol.org/docs/v4/schema` |\n| `revision_type` | string/RevisionLink | Type identifier for the revision |\n| `nonce` | string | Random 16-byte hex string (prefixed with `0x`) for uniqueness |\n| `local_timestamp` | number | Unix timestamp when the revision was created |\n| `method` | string | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Hashing algorithm: `\"FIPS_202-SHA3-256\"` |\n| `previous_revision` | string | Hash reference to the previous revision (optional for genesis) |\n\n## Schema Structure\n\nThe v4 schema is designed to be:\n\n- **Extensible**: New revision types can be added without breaking existing chains\n- **Verifiable**: Every revision can be independently verified through hash computation\n- **Composable**: Chains can link to other chains, creating complex data structures\n- **Flexible**: Templates allow custom data structures while maintaining validation\n\n## Key Improvements from Previous Versions\n\n### 1. Unified Revision Structure\nAll revision types follow a consistent structure with common fields, making implementation and validation simpler.\n\n### 2. Template-Based Validation\nObject revisions reference templates via hash, ensuring data conformity to predefined schemas.\n\n### 3. Multiple Signature Types\nSupport for RSA, Ethereum (EIP-191), and DID-based signatures provides flexibility for different use cases.\n\n### 4. Enhanced Witnessing\nImproved witness structure with detailed transaction information and merkle proof support.\n\n### 5. Explicit Linking\nLink revisions create verifiable connections between separate revision chains.\n\n## Getting Started\n\nTo understand the v4 schema in detail, visit the [Schema Reference](/schema_reference/introduction) section, where each revision type is documented with examples and field specifications.\n\n## Tooling\n\n### Aqua RS SDK\n\nThe official Rust SDK for Aqua Protocol v4 provides:\n- Type-safe revision creation and validation\n- Cryptographic operations (signing, hashing)\n- Witnessing capabilities (Ethereum, Nostr, TSA)\n- WASM compilation for web applications\n\n**Repository**: [github.com/inblockio/aqua-rs-sdk](https://github.com/inblockio/aqua-rs-sdk)\n\n**Installation:**\n```bash\n# For Rust projects\ncargo add aqua-rs-sdk\n\n# For WASM builds\nwasm-pack build --target web --no-default-features --features wasm\n```\n\n### CLI Tools\n\nCommand-line utilities built on the v4 SDK enable:\n- Creating and validating revision chains\n- Signing revisions with various methods\n- Witnessing to blockchain networks\n- Verifying complete chains\n\n## Use Cases\n\nAqua Protocol v4 is designed for:\n\n- **Document Integrity**: Verifiable audit trails for documents and data\n- **Supply Chain**: Tracking provenance and authenticity\n- **Digital Identity**: Self-sovereign identity with verifiable credentials\n- **Notarization**: Timestamped proof of existence\n- **Data Provenance**: Complete history tracking with cryptographic guarantees\n- **Decentralized Attestations**: Peer-to-peer verification without central authorities\n\n## Next Steps\n\n- Explore the [Schema Reference](/schema_reference/introduction) to understand each revision type\n- Review example revision chains in the SDK repository\n- Try the CLI tools to create your first revision chain\n- Read about specific use cases and implementation patterns\n\nFor questions or feedback about v4, please visit the [Aqua Protocol GitHub repository](https://github.com/inblockio).\n"])</script><script>self.__next_f.push([1,"25:Tca8,"])</script><script>self.__next_f.push([1,"\n\nThe Aqua CLI is a command-line tool for creating, signing, witnessing, and verifying Aqua Protocol chains. Built with Rust, it provides a simple interface for working with Aqua chains without writing code.\n\n## Features\n\n- **Chain Validation**: Verify Aqua chain integrity and signatures\n- **Signing**: Add cryptographic signatures to revisions\n- **Witnessing**: Anchor chains to Ethereum networks (mainnet, Sepolia, Holesky)\n- **Batch Operations**: Process multiple chains efficiently\n- **Environment Configuration**: Flexible configuration via environment variables\n\n## Installation\n\n### From Source\n\n```bash\ngit clone https://github.com/inblockio/aqua-cli-rs\ncd aqua-cli-rs\ncargo build --release\n```\n\nThe binary will be available at `target/release/aqua-cli`\n\n### Local Development\n\n```bash\ncargo build\ncd target/debug\n./aqua-cli --help\n```\n\n## Configuration\n\nConfigure the CLI using environment variables:\n\n```bash\n# Optional: Domain identifier (auto-generated if not specified)\nexport aqua_domain=\"your_domain\"\n\n# Network for witnessing (default: sepolia)\nexport aqua_network=\"sepolia\"  # or \"holesky\" or \"mainnet\"\n\n# Verification platform (default: none)\nexport verification_platform=\"alchemy\"  # or \"infura\" or \"self\"\n\n# Blockchain for witnessing (default: none)\nexport chain=\"sepolia\"  # or \"mainnet\" or \"holesky\"\n\n# API key for Alchemy or Infura\nexport api_key=\"your_api_key\"\n\n# Path to keys file for signing\nexport keys_file=\"path/to/keys.json\"\n```\n\n## Basic Usage\n\nGet started with the CLI:\n\n```bash\n# Display help\n./aqua-cli --help\n\n# Verify an Aqua chain\n./aqua-cli verify --file chain.aqua.json\n\n# Sign a chain\n./aqua-cli sign --file chain.aqua.json --keys keys.json\n\n# Witness a chain on Sepolia testnet\n./aqua-cli witness --file chain.aqua.json --network sepolia\n```\n\n## Keys File Format\n\nCreate a `keys.json` file for signing operations:\n\n```json\n{\n  \"private_key\": \"your_private_key_hex\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n**Security Note**: Use a wallet without MetaMask for CLI operations. Keep your keys file secure and never commit it to version control.\n\n## Versioning\n\nEnsure the CLI version matches your Aqua Protocol version:\n- Use CLI version `4.0.x` for Aqua Protocol v4 chains\n- Use CLI version `3.x.x` for Aqua Protocol v3 chains\n\n## Testing\n\nThe repository includes a test script for verifying functionality:\n\n```bash\n# Grant execution permissions\nchmod +x test_aqua_cli.sh\n\n# Run tests\n./test_aqua_cli.sh\n```\n\n## Use Cases\n\n- **Quick Verification**: Validate chain integrity without building applications\n- **CI/CD Integration**: Automate verification in deployment pipelines\n- **Batch Processing**: Process multiple chains in scripts\n- **Development Testing**: Quickly test chain creation and verification\n- **System Administration**: Manage Aqua chains from the command line\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aqua-cli-rs](https://github.com/inblockio/aqua-cli-rs)\n\n## Documentation\n\nFor more information about Aqua Protocol v4:\n- [Version 4 Introduction](/previous_versions/version_4/version_4)\n- [Schema Reference](/schema_reference/introduction)\n\n## Version\n\n**Current Version**: 4.0.0\n\nBuilt using the [Aqua Rust SDK](/dev_tools/aqua_sdk) for Aqua Protocol v4 support.\n"])</script><script>self.__next_f.push([1,"26:Tca8,"])</script><script>self.__next_f.push([1,"\n\nThe Aqua CLI is a command-line tool for creating, signing, witnessing, and verifying Aqua Protocol chains. Built with Rust, it provides a simple interface for working with Aqua chains without writing code.\n\n## Features\n\n- **Chain Validation**: Verify Aqua chain integrity and signatures\n- **Signing**: Add cryptographic signatures to revisions\n- **Witnessing**: Anchor chains to Ethereum networks (mainnet, Sepolia, Holesky)\n- **Batch Operations**: Process multiple chains efficiently\n- **Environment Configuration**: Flexible configuration via environment variables\n\n## Installation\n\n### From Source\n\n```bash\ngit clone https://github.com/inblockio/aqua-cli-rs\ncd aqua-cli-rs\ncargo build --release\n```\n\nThe binary will be available at `target/release/aqua-cli`\n\n### Local Development\n\n```bash\ncargo build\ncd target/debug\n./aqua-cli --help\n```\n\n## Configuration\n\nConfigure the CLI using environment variables:\n\n```bash\n# Optional: Domain identifier (auto-generated if not specified)\nexport aqua_domain=\"your_domain\"\n\n# Network for witnessing (default: sepolia)\nexport aqua_network=\"sepolia\"  # or \"holesky\" or \"mainnet\"\n\n# Verification platform (default: none)\nexport verification_platform=\"alchemy\"  # or \"infura\" or \"self\"\n\n# Blockchain for witnessing (default: none)\nexport chain=\"sepolia\"  # or \"mainnet\" or \"holesky\"\n\n# API key for Alchemy or Infura\nexport api_key=\"your_api_key\"\n\n# Path to keys file for signing\nexport keys_file=\"path/to/keys.json\"\n```\n\n## Basic Usage\n\nGet started with the CLI:\n\n```bash\n# Display help\n./aqua-cli --help\n\n# Verify an Aqua chain\n./aqua-cli verify --file chain.aqua.json\n\n# Sign a chain\n./aqua-cli sign --file chain.aqua.json --keys keys.json\n\n# Witness a chain on Sepolia testnet\n./aqua-cli witness --file chain.aqua.json --network sepolia\n```\n\n## Keys File Format\n\nCreate a `keys.json` file for signing operations:\n\n```json\n{\n  \"private_key\": \"your_private_key_hex\",\n  \"wallet_address\": \"0xYourEthereumAddress\"\n}\n```\n\n**Security Note**: Use a wallet without MetaMask for CLI operations. Keep your keys file secure and never commit it to version control.\n\n## Versioning\n\nEnsure the CLI version matches your Aqua Protocol version:\n- Use CLI version `4.0.x` for Aqua Protocol v4 chains\n- Use CLI version `3.x.x` for Aqua Protocol v3 chains\n\n## Testing\n\nThe repository includes a test script for verifying functionality:\n\n```bash\n# Grant execution permissions\nchmod +x test_aqua_cli.sh\n\n# Run tests\n./test_aqua_cli.sh\n```\n\n## Use Cases\n\n- **Quick Verification**: Validate chain integrity without building applications\n- **CI/CD Integration**: Automate verification in deployment pipelines\n- **Batch Processing**: Process multiple chains in scripts\n- **Development Testing**: Quickly test chain creation and verification\n- **System Administration**: Manage Aqua chains from the command line\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aqua-cli-rs](https://github.com/inblockio/aqua-cli-rs)\n\n## Documentation\n\nFor more information about Aqua Protocol v4:\n- [Version 4 Introduction](/previous_versions/version_4/version_4)\n- [Schema Reference](/schema_reference/introduction)\n\n## Version\n\n**Current Version**: 4.0.0\n\nBuilt using the [Aqua Rust SDK](/dev_tools/aqua_sdk) for Aqua Protocol v4 support.\n"])</script><script>self.__next_f.push([1,"27:Tefa,"])</script><script>self.__next_f.push([1,"This Page contains sdk details of version 4 of the Aqua Protocol.To Use version 3 which is stable visit [quickstart](/quickstart)\nThe Aqua SDK is a Rust library that provides the core functionality for creating, signing, witnessing, and verifying Aqua Protocol chains. It supports Aqua Protocol v4 and includes WebAssembly (WASM) bindings for cross-platform compatibility.\n\n## Features\n\n- **Create Aqua Chains**: Build revision chains with objects, templates, signatures, witnesses, and links\n- **Template System**: Define and validate structured data using JSON Schema\n- **Multiple Signature Methods**: Support for RSA, Ethereum EIP-191, and DID:JWS signatures\n- **Blockchain Witnessing**: Anchor revisions to Ethereum (mainnet, Sepolia, Holesky), Nostr, or TSA\n- **Chain Verification**: Cryptographically verify complete revision chains\n- **Cross-Platform**: WASM support enables use in web browsers, Node.js, and native applications\n\n## Installation\n\nAdd the SDK to your Rust project:\n\n```toml cargo.toml\n[dependencies]\naqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }\n```\n\n## Quick Example\n\n```rust main.rs\n    use aqua_rs_sdk::primitives::Method;\n    use aqua_rs_sdk::schema::file_data::FileData;\n    use aqua_rs_sdk::Aquafier;\n    use std::path::PathBuf;\n\n    #[tokio::main]\n    async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        println!(\"Creating Aqua chain...\");\n\n        // Read file content\n        let filename = \"test.txt\".to_string();\n        let file_content = tokio::fs::read(\u0026filename).await?;\n\n        // Create file data\n        let file_data = FileData::new(\n            filename.clone(),\n            file_content,\n            PathBuf::from(format!(\"./{}\", filename)),\n        );\n\n        // Initialize Aquafier\n        let aquafier = Aquafier::new(None, None);\n\n        // Create genesis revision (notarize the file)\n        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n        match result {\n            Ok(tree) =\u003e {\n                println!(\"‚úì Aqua chain created successfully!\");\n                println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n\n                println!(\"\\nYou can now:\");\n                println!(\"- Add a signature revision\");\n                println!(\"- Witness on blockchain\");\n                println!(\"- Verify the chain\");\n\n                // Sign the revision\n                // let signature = sign_revision(\u0026object_revision, \u0026signing_key)?;\n\n                // Witness on blockchain\n                // let witness = witness_revision(\u0026signature, EthereumNetwork::Sepolia)?;\n\n                // Verify the complete chain\n                // let is_valid = verify_chain(\u0026aqua_chain)?;\n\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error: {:#?}\", e);\n            }\n        }\n\n        Ok(())\n    }\n\n\n```\n\n## Use Cases\n\n- **Application Integration**: Embed Aqua Protocol directly into your Rust applications\n- **Custom Tools**: Build specialized tools for specific workflows\n- **Smart Contracts**: Integrate with blockchain applications using WASM\n- **Web Applications**: Use WASM bindings to run in browsers\n- **Server Applications**: Build backend services with native Rust performance\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aqua-verifier-rs](https://github.com/inblockio/aqua-rs-sdk)\n\n## Documentation\n\nFor detailed API documentation, examples, and guides:\n- [Version 4 Introduction](/previous_versions/version_4/version_4)\n- [Schema Reference](/schema_reference/introduction)\n- [API Documentation](https://docs.rs/aqua-rs-sdk)\n\n## Version\n\n**Current Version**: 4.0.0 (Beta)\n\nThe SDK implements Aqua Protocol v4 with the template system and enhanced revision types. For production-stable implementations, consider the [JavaScript SDK (v3)](/previous_versions/version_3/tooling).\n"])</script><script>self.__next_f.push([1,"28:Tefa,"])</script><script>self.__next_f.push([1,"This Page contains sdk details of version 4 of the Aqua Protocol.To Use version 3 which is stable visit [quickstart](/quickstart)\nThe Aqua SDK is a Rust library that provides the core functionality for creating, signing, witnessing, and verifying Aqua Protocol chains. It supports Aqua Protocol v4 and includes WebAssembly (WASM) bindings for cross-platform compatibility.\n\n## Features\n\n- **Create Aqua Chains**: Build revision chains with objects, templates, signatures, witnesses, and links\n- **Template System**: Define and validate structured data using JSON Schema\n- **Multiple Signature Methods**: Support for RSA, Ethereum EIP-191, and DID:JWS signatures\n- **Blockchain Witnessing**: Anchor revisions to Ethereum (mainnet, Sepolia, Holesky), Nostr, or TSA\n- **Chain Verification**: Cryptographically verify complete revision chains\n- **Cross-Platform**: WASM support enables use in web browsers, Node.js, and native applications\n\n## Installation\n\nAdd the SDK to your Rust project:\n\n```toml cargo.toml\n[dependencies]\naqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }\n```\n\n## Quick Example\n\n```rust main.rs\n    use aqua_rs_sdk::primitives::Method;\n    use aqua_rs_sdk::schema::file_data::FileData;\n    use aqua_rs_sdk::Aquafier;\n    use std::path::PathBuf;\n\n    #[tokio::main]\n    async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        println!(\"Creating Aqua chain...\");\n\n        // Read file content\n        let filename = \"test.txt\".to_string();\n        let file_content = tokio::fs::read(\u0026filename).await?;\n\n        // Create file data\n        let file_data = FileData::new(\n            filename.clone(),\n            file_content,\n            PathBuf::from(format!(\"./{}\", filename)),\n        );\n\n        // Initialize Aquafier\n        let aquafier = Aquafier::new(None, None);\n\n        // Create genesis revision (notarize the file)\n        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);\n\n        match result {\n            Ok(tree) =\u003e {\n                println!(\"‚úì Aqua chain created successfully!\");\n                println!(\"{}\", serde_json::to_string_pretty(\u0026tree)?);\n\n                println!(\"\\nYou can now:\");\n                println!(\"- Add a signature revision\");\n                println!(\"- Witness on blockchain\");\n                println!(\"- Verify the chain\");\n\n                // Sign the revision\n                // let signature = sign_revision(\u0026object_revision, \u0026signing_key)?;\n\n                // Witness on blockchain\n                // let witness = witness_revision(\u0026signature, EthereumNetwork::Sepolia)?;\n\n                // Verify the complete chain\n                // let is_valid = verify_chain(\u0026aqua_chain)?;\n\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error: {:#?}\", e);\n            }\n        }\n\n        Ok(())\n    }\n\n\n```\n\n## Use Cases\n\n- **Application Integration**: Embed Aqua Protocol directly into your Rust applications\n- **Custom Tools**: Build specialized tools for specific workflows\n- **Smart Contracts**: Integrate with blockchain applications using WASM\n- **Web Applications**: Use WASM bindings to run in browsers\n- **Server Applications**: Build backend services with native Rust performance\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aqua-verifier-rs](https://github.com/inblockio/aqua-rs-sdk)\n\n## Documentation\n\nFor detailed API documentation, examples, and guides:\n- [Version 4 Introduction](/previous_versions/version_4/version_4)\n- [Schema Reference](/schema_reference/introduction)\n- [API Documentation](https://docs.rs/aqua-rs-sdk)\n\n## Version\n\n**Current Version**: 4.0.0 (Beta)\n\nThe SDK implements Aqua Protocol v4 with the template system and enhanced revision types. For production-stable implementations, consider the [JavaScript SDK (v3)](/previous_versions/version_3/tooling).\n"])</script><script>self.__next_f.push([1,"29:T1289,"])</script><script>self.__next_f.push([1,"\n\nAquafier is a web-based reference implementation of Aqua Protocol v3, providing a user-friendly interface and HTTP API for digital content signing, provenance verification, and integrity validation. It demonstrates how Aqua Protocol features can be integrated into modern web applications.\n\n## Overview\n\nAquafier combines a Fastify backend with React frontend to deliver a complete solution for document notarization and verification. It's designed as both a production tool and a reference implementation for developers building Aqua-based applications.\n\n## Features\n\n- **Digital Content Signing**: Sign documents and data with multiple signature methods\n- **Provenance Verification**: Track and verify document history and authenticity\n- **Integrity Validation**: Cryptographically verify document integrity\n- **Web Interface**: User-friendly React interface for non-technical users\n- **HTTP API**: RESTful API for programmatic access\n- **Multi-Party Workflows**: Support for documents requiring multiple signatures\n\n## Technology Stack\n\n**Backend**:\n- Fastify (Node.js web framework)\n- Prisma ORM\n- PostgreSQL database\n- Aqua JavaScript SDK (v3)\n\n**Frontend**:\n- React with TypeScript\n- Chakra UI components\n- End-to-end testing with Playwright\n\n## Hosted Instances\n\n**Production**: [aquafier.inblock.io](https://aquafier.inblock.io/)\n- Stable production environment\n- For live document notarization and verification\n\n**Development/Testing**: [dev.inblock.io](https://dev.inblock.io/)\n- Testing environment for new features\n- Use for development and experimentation\n\n## Use Cases\n\n- **Document Notarization**: Notarize legal documents, contracts, and agreements\n- **Certificate Issuance**: Issue verifiable certificates and credentials\n- **Multi-Party Signing**: Collect signatures from multiple parties\n- **Audit Trail Creation**: Build immutable audit trails for compliance\n- **Proof of Concept**: Demonstrate Aqua Protocol capabilities\n- **API Integration**: Integrate notarization into existing systems\n\n## API Access\n\nAquafier provides a RESTful HTTP API for programmatic access. Developers can integrate notarization and verification into their applications without building infrastructure from scratch.\n\nCommon API operations:\n- Create genesis revisions\n- Add signatures to existing chains\n- Witness chains on blockchain\n- Verify chain integrity\n- Retrieve chain history\n\n## Development\n\nAquafier-JS is open source and can be self-hosted for custom deployments.\n\n### Requirements\n- Docker and Docker Compose\n- PostgreSQL database\n- Node.js environment\n\n### Deployment\n\nDeploy using Docker Compose:\n\n```bash\n# Prepare environment file\ncp deployment/.env.sample .env\n\n# Start services\ndocker compose -f deployment/docker-compose-prod.yml up -d\n```\n\n**Deployment Options**:\n- **Local**: No proxy, exposed ports for development\n- **Dev**: With Let's Encrypt SSL and DNS\n- **Prod**: Production configuration with SSL\n\n### Configuration\n\nKey environment variables:\n\n```bash\n# Database\nDATABASE_URL=postgres://user:password@host:port/database\n\n# Server\nHOST=0.0.0.0\nPORT=3000\n\n# Frontend/Backend URLs (for proxy)\nFRONTEND_URL=https://your-domain.com\nBACKEND_URL=https://api.your-domain.com\n\n# Twilio (optional, for SMS verification)\nTWILIO_ACCOUNT_SID=your_sid\nTWILIO_AUTH_TOKEN=your_token\n```\n\n## Architecture\n\nAquafier's modular architecture makes it suitable as a foundation for custom applications:\n\n- **API Layer**: RESTful endpoints for all Aqua operations\n- **Service Layer**: Business logic for chain management\n- **Data Layer**: Prisma ORM with PostgreSQL\n- **Storage**: File system or S3-compatible storage\n- **Backup**: Automated backup with configurable retention\n\n## Protocol Version\n\n**Aqua Protocol v3**: Aquafier implements the stable JavaScript SDK\n\nFor v3 technical details:\n- [Version 3 Introduction](/previous_versions/version_3/introduction)\n- [Version 3 Concepts](/previous_versions/version_3/concepts)\n- [Version 3 SDK](/previous_versions/version_3/tooling)\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aquafier-js](https://github.com/inblockio/aquafier-js)\n\n## Development Team\n\n- Tim Bansemer - Project Manager\n- Arthur Kamau - Developer\n- Dalmas Nyaboga Ogembo - Developer\n- Florian Zeps - DevOps\n\n## Getting Started\n\n1. Visit [aquafier.inblock.io](https://aquafier.inblock.io/) to use the hosted version\n2. Try the [dev environment](https://dev.inblock.io/) for testing\n3. Explore the API documentation for programmatic integration\n4. Check the [GitHub repository](https://github.com/inblockio/aquafier-js) for self-hosting\n\nFor building custom applications, consider using the [Aqua JavaScript SDK](/previous_versions/version_3/tooling) directly or the [Aqua Rust SDK](/dev_tools/aqua_sdk) for v4 features.\n"])</script><script>self.__next_f.push([1,"2a:T1289,"])</script><script>self.__next_f.push([1,"\n\nAquafier is a web-based reference implementation of Aqua Protocol v3, providing a user-friendly interface and HTTP API for digital content signing, provenance verification, and integrity validation. It demonstrates how Aqua Protocol features can be integrated into modern web applications.\n\n## Overview\n\nAquafier combines a Fastify backend with React frontend to deliver a complete solution for document notarization and verification. It's designed as both a production tool and a reference implementation for developers building Aqua-based applications.\n\n## Features\n\n- **Digital Content Signing**: Sign documents and data with multiple signature methods\n- **Provenance Verification**: Track and verify document history and authenticity\n- **Integrity Validation**: Cryptographically verify document integrity\n- **Web Interface**: User-friendly React interface for non-technical users\n- **HTTP API**: RESTful API for programmatic access\n- **Multi-Party Workflows**: Support for documents requiring multiple signatures\n\n## Technology Stack\n\n**Backend**:\n- Fastify (Node.js web framework)\n- Prisma ORM\n- PostgreSQL database\n- Aqua JavaScript SDK (v3)\n\n**Frontend**:\n- React with TypeScript\n- Chakra UI components\n- End-to-end testing with Playwright\n\n## Hosted Instances\n\n**Production**: [aquafier.inblock.io](https://aquafier.inblock.io/)\n- Stable production environment\n- For live document notarization and verification\n\n**Development/Testing**: [dev.inblock.io](https://dev.inblock.io/)\n- Testing environment for new features\n- Use for development and experimentation\n\n## Use Cases\n\n- **Document Notarization**: Notarize legal documents, contracts, and agreements\n- **Certificate Issuance**: Issue verifiable certificates and credentials\n- **Multi-Party Signing**: Collect signatures from multiple parties\n- **Audit Trail Creation**: Build immutable audit trails for compliance\n- **Proof of Concept**: Demonstrate Aqua Protocol capabilities\n- **API Integration**: Integrate notarization into existing systems\n\n## API Access\n\nAquafier provides a RESTful HTTP API for programmatic access. Developers can integrate notarization and verification into their applications without building infrastructure from scratch.\n\nCommon API operations:\n- Create genesis revisions\n- Add signatures to existing chains\n- Witness chains on blockchain\n- Verify chain integrity\n- Retrieve chain history\n\n## Development\n\nAquafier-JS is open source and can be self-hosted for custom deployments.\n\n### Requirements\n- Docker and Docker Compose\n- PostgreSQL database\n- Node.js environment\n\n### Deployment\n\nDeploy using Docker Compose:\n\n```bash\n# Prepare environment file\ncp deployment/.env.sample .env\n\n# Start services\ndocker compose -f deployment/docker-compose-prod.yml up -d\n```\n\n**Deployment Options**:\n- **Local**: No proxy, exposed ports for development\n- **Dev**: With Let's Encrypt SSL and DNS\n- **Prod**: Production configuration with SSL\n\n### Configuration\n\nKey environment variables:\n\n```bash\n# Database\nDATABASE_URL=postgres://user:password@host:port/database\n\n# Server\nHOST=0.0.0.0\nPORT=3000\n\n# Frontend/Backend URLs (for proxy)\nFRONTEND_URL=https://your-domain.com\nBACKEND_URL=https://api.your-domain.com\n\n# Twilio (optional, for SMS verification)\nTWILIO_ACCOUNT_SID=your_sid\nTWILIO_AUTH_TOKEN=your_token\n```\n\n## Architecture\n\nAquafier's modular architecture makes it suitable as a foundation for custom applications:\n\n- **API Layer**: RESTful endpoints for all Aqua operations\n- **Service Layer**: Business logic for chain management\n- **Data Layer**: Prisma ORM with PostgreSQL\n- **Storage**: File system or S3-compatible storage\n- **Backup**: Automated backup with configurable retention\n\n## Protocol Version\n\n**Aqua Protocol v3**: Aquafier implements the stable JavaScript SDK\n\nFor v3 technical details:\n- [Version 3 Introduction](/previous_versions/version_3/introduction)\n- [Version 3 Concepts](/previous_versions/version_3/concepts)\n- [Version 3 SDK](/previous_versions/version_3/tooling)\n\n## Repository\n\n**GitHub**: [github.com/inblockio/aquafier-js](https://github.com/inblockio/aquafier-js)\n\n## Development Team\n\n- Tim Bansemer - Project Manager\n- Arthur Kamau - Developer\n- Dalmas Nyaboga Ogembo - Developer\n- Florian Zeps - DevOps\n\n## Getting Started\n\n1. Visit [aquafier.inblock.io](https://aquafier.inblock.io/) to use the hosted version\n2. Try the [dev environment](https://dev.inblock.io/) for testing\n3. Explore the API documentation for programmatic integration\n4. Check the [GitHub repository](https://github.com/inblockio/aquafier-js) for self-hosting\n\nFor building custom applications, consider using the [Aqua JavaScript SDK](/previous_versions/version_3/tooling) directly or the [Aqua Rust SDK](/dev_tools/aqua_sdk) for v4 features.\n"])</script><script>self.__next_f.push([1,"2b:T4217,"])</script><script>self.__next_f.push([1,"\n# Link Revision\n\nA Link Revision creates verifiable connections between separate revision chains. It allows you to establish relationships, dependencies, or references between different objects, effectively creating a graph structure of interconnected chains. Link revisions are essential for composing complex data structures and maintaining provenance across multiple chains.\n\n## Overview\n\nLink revisions enable:\n- **Chain Composition**: Connect multiple independent chains together\n- **Dependency Tracking**: Express that one chain depends on others\n- **Multi-Party Collaboration**: Combine contributions from different parties\n- **Provenance Graphs**: Build complex data relationship structures\n- **Verification Aggregation**: Group related chains for batch verification\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the previous revision in this chain |\n| `revision_type` | string | Yes | Always `\"link\"` for link revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the link was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `link_verification_hashes` | array | Yes | Array of revision hashes being linked to |\n\n### Field Details\n\n#### link_verification_hashes\n- **Type**: Array of hex strings\n- **Format**: Each element is a lowercase hex string prefixed with `0x`\n- **Purpose**: References to other revision chains\n- **Minimum**: Can be empty array (though typically contains at least one link)\n- **Maximum**: No strict limit, but practical limits depend on implementation\n- **Order**: Order may be significant depending on use case\n\n## Example\n\n### Basic Link Revision\n\nLinking to two other chains:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n    \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\"\n  ]\n}\n```\n\n### Single Link\n\nLinking to a single chain:\n\n```json\n{\n  \"previous_revision\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\"\n  ]\n}\n```\n\n### Multiple Links (Aggregation)\n\nAggregating many chains:\n\n```json\n{\n  \"previous_revision\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0xa1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x1111111111111111111111111111111111111111111111111111111111111111\",\n    \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n    \"0x3333333333333333333333333333333333333333333333333333333333333333\",\n    \"0x4444444444444444444444444444444444444444444444444444444444444444\",\n    \"0x5555555555555555555555555555555555555555555555555555555555555555\"\n  ]\n}\n```\n\n## Validation Rules\n\nA Link Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"link\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Link Array**: `link_verification_hashes` is a valid array\n5. **Link Format**: Each element in the array is a valid hex string with `0x` prefix\n6. **Link Targets**: Each referenced revision should exist and be verifiable (optional strict validation)\n7. **No Duplicates**: Typically shouldn't contain duplicate hashes (application-specific)\n8. **Hash Verification**: The computed hash of the link revision is correct\n\n## Common Use Cases\n\n### 1. Document Dependencies\n\nLink a document to its source materials:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Contract[Contract Document - Object]\n      Link[Link Revision]\n      Ref1[Reference Doc 1]\n      Ref2[Reference Doc 2]\n      Ref3[Reference Doc 3]\n\n      Contract --\u003e Link\n      Link -.-\u003e|references| Ref1\n      Link -.-\u003e|references| Ref2\n      Link -.-\u003e|references| Ref3\n  `}\n  caption=\"Document dependencies using link revision\"\n/\u003e\n\n### 2. Multi-Party Signing\n\nCombine independent signatures:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Doc[Document Object]\n      SigA[Signature - Alice]\n      SigB[Signature - Bob]\n      SigC[Signature - Carol]\n      Link[Link Revision]\n      Witness[Witness - Timestamp all]\n\n      Doc --\u003e SigA\n      Doc --\u003e SigB\n      Doc --\u003e SigC\n      SigA --\u003e Link\n      SigB --\u003e Link\n      SigC --\u003e Link\n      Link --\u003e Witness\n  `}\n  caption=\"Multi-party signing with link revision\"\n/\u003e\n\n### 3. Bill of Materials\n\nLink a product to its components:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Product[Product Object]\n      Link[Link Revision]\n      Comp1[Component 1 Chain]\n      Comp2[Component 2 Chain]\n      Comp3[Component 3 Chain]\n\n      Product --\u003e Link\n      Link -.-\u003e|references| Comp1\n      Link -.-\u003e|references| Comp2\n      Link -.-\u003e|references| Comp3\n  `}\n  caption=\"Bill of materials with component chains\"\n/\u003e\n\nEach component has its own provenance chain.\n\n### 4. Credential Bundling\n\nGroup related credentials:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Profile[Profile Object]\n      Link[Link Revision]\n      Email[Email Credential]\n      Domain[Domain Credential]\n      GitHub[GitHub Credential]\n\n      Profile --\u003e Link\n      Link -.-\u003e|references| Email\n      Link -.-\u003e|references| Domain\n      Link -.-\u003e|references| GitHub\n  `}\n  caption=\"Credential bundling with link revision\"\n/\u003e\n\n### 5. Supply Chain Aggregation\n\nCombine supply chain events:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Tracking[Shipment Tracking]\n      Link[Link Revision]\n      Manufacturer[Manufacturer Chain]\n      Shipper[Shipper Chain]\n      Customs[Customs Chain]\n      Final[Final Delivery Confirmation]\n\n      Tracking --\u003e Link\n      Link -.-\u003e|references| Manufacturer\n      Link -.-\u003e|references| Shipper\n      Link -.-\u003e|references| Customs\n      Link --\u003e Final\n  `}\n  caption=\"Supply chain aggregation\"\n/\u003e\n\n### 6. Academic Citation\n\nLink a paper to cited works:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Paper[Research Paper - Object]\n      Link[Link Revision]\n      Cite1[Citation 1 Chain]\n      Cite2[Citation 2 Chain]\n      CiteN[Citation N Chain]\n\n      Paper --\u003e Link\n      Link -.-\u003e|references| Cite1\n      Link -.-\u003e|references| Cite2\n      Link -.-\u003e|references| CiteN\n  `}\n  caption=\"Academic citation with link revision\"\n/\u003e\n\n### 7. Version History\n\nLink to previous versions:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      V3[Document v3 - Object]\n      Link[Link Revision]\n      V1[Document v1 Final]\n      V2[Document v2 Final]\n\n      V3 --\u003e Link\n      Link -.-\u003e|references| V1\n      Link -.-\u003e|references| V2\n  `}\n  caption=\"Version history with link revision\"\n/\u003e\n\n### 8. Approval Workflow Merge\n\nMerge parallel approval processes:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Draft[Document Draft]\n      ReviewA[Review A]\n      ReviewB[Review B]\n      ApproveA[Approve A]\n      ApproveB[Approve B]\n      Link[Link Revision]\n      Final[Final Version]\n\n      Draft --\u003e ReviewA\n      Draft --\u003e ReviewB\n      ReviewA --\u003e ApproveA\n      ReviewB --\u003e ApproveB\n      ApproveA --\u003e Link\n      ApproveB --\u003e Link\n      Link --\u003e Final\n  `}\n  caption=\"Approval workflow merge with link revision\"\n/\u003e\n\n## Link Patterns\n\n### Pattern 1: Linear Dependency Chain\n\n\u003cMermaid\n  chart={`\n    graph LR\n      A[Object A]\n      LinkAB[Link]\n      B[Object B]\n      LinkBC[Link]\n      C[Object C]\n\n      A --\u003e LinkAB\n      LinkAB -.-\u003e|references| B\n      B --\u003e LinkBC\n      LinkBC -.-\u003e|references| C\n  `}\n  caption=\"Linear dependency chain\"\n/\u003e\n\nEach object depends on the previous one.\n\n### Pattern 2: Star Pattern (Aggregation)\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Link[Link Revision]\n      A[Chain A]\n      B[Chain B]\n      C[Chain C]\n      D[Chain D]\n      E[Chain E]\n\n      Link -.-\u003e|references| A\n      Link -.-\u003e|references| B\n      Link -.-\u003e|references| C\n      Link -.-\u003e|references| D\n      Link -.-\u003e|references| E\n  `}\n  caption=\"Star pattern - one link references multiple chains\"\n/\u003e\n\nOne link revision references multiple chains.\n\n### Pattern 3: Tree Pattern\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Root[Root Object]\n      Link1[Link to A, B]\n      LinkA[Link to A1, A2]\n      LinkB[Link to B1, B2]\n      A1[A1]\n      A2[A2]\n      B1[B1]\n      B2[B2]\n\n      Root --\u003e Link1\n      Link1 -.-\u003e LinkA\n      Link1 -.-\u003e LinkB\n      LinkA -.-\u003e|references| A1\n      LinkA -.-\u003e|references| A2\n      LinkB -.-\u003e|references| B1\n      LinkB -.-\u003e|references| B2\n  `}\n  caption=\"Tree pattern - hierarchical structure using links\"\n/\u003e\n\nHierarchical structure using links.\n\n### Pattern 4: Graph Pattern\n\n\u003cMermaid\n  chart={`\n    graph TD\n      A[A]\n      B[B]\n      C[C]\n      D[D]\n      E[E]\n      LinkA[Link from A]\n      LinkB[Link from B]\n      LinkC[Link from C]\n\n      A --\u003e LinkA\n      LinkA -.-\u003e|references| B\n      LinkA -.-\u003e|references| C\n\n      B --\u003e LinkB\n      LinkB -.-\u003e|references| C\n      LinkB -.-\u003e|references| D\n\n      C --\u003e LinkC\n      LinkC -.-\u003e|references| A\n      LinkC -.-\u003e|references| E\n  `}\n  caption=\"Graph pattern - complex graph with cycles and multiple connections\"\n/\u003e\n\nComplex graph with cycles and multiple connections.\n\n## Implementation Notes\n\n### Creating a Link Revision\n\n1. Identify the chains to link\n2. Get the head (latest) revision hash from each chain\n3. Collect hashes into `link_verification_hashes` array\n4. Determine the `previous_revision` for this link\n5. Generate nonce and timestamp\n6. Create the link revision structure\n7. Compute and verify the hash\n\n### Verifying a Link Revision\n\n#### Basic Verification\n```\n1. Verify link revision structure\n2. Validate each hash in link_verification_hashes\n3. Compute link revision hash\n```\n\n#### Deep Verification\n```\n1. Perform basic verification\n2. For each linked hash:\n   a. Retrieve the referenced revision\n   b. Verify the referenced revision chain\n   c. Check signatures and witnesses\n3. Validate all linked chains\n```\n\n### Link Resolution\n\nWhen traversing links:\n\n```\n1. Start with link revision\n2. Extract link_verification_hashes\n3. For each hash:\n   a. Resolve to actual revision\n   b. Load revision chain\n   c. Verify chain integrity\n4. Build complete relationship graph\n```\n\n## Advanced Topics\n\n### Cyclic References\n\nLinks can create cycles:\n\n\u003cMermaid\n  chart={`\n    graph LR\n      A[Chain A]\n      LinkA[Link from A]\n      B[Chain B]\n      LinkB[Link from B]\n\n      A --\u003e LinkA\n      LinkA -.-\u003e|references| B\n      B --\u003e LinkB\n      LinkB -.-\u003e|references| A\n  `}\n  caption=\"Cyclic references between chains\"\n/\u003e\n\n**Handling**:\n- Detect cycles during traversal\n- Use visited set to prevent infinite loops\n- Cycles may be valid depending on use case\n\n### Temporal Ordering\n\nLinks create a temporal relationship:\n\n```\nLink created at timestamp T references chains that existed before T\n```\n\n**Validation**:\n- Linked revisions should have timestamps \u003c link timestamp\n- Prevents linking to \"future\" revisions\n\n### Partial vs Complete References\n\n**Complete Reference**: Link to final revision of a chain\n```\nLink ‚Üí [Complete Chain A, Complete Chain B]\n```\n\n**Partial Reference**: Link to intermediate revision\n```\nLink ‚Üí [Chain A @ Revision 5, Chain B @ Revision 3]\n```\n\n### Link Updates\n\nTo update links over time:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object]\n      Link1[Link v1 - references A, B]\n      Link2[Link v2 - references A, B, C]\n      Link3[Link v3 - references A, C]\n\n      Obj --\u003e Link1\n      Link1 --\u003e Link2\n      Link2 --\u003e Link3\n  `}\n  caption=\"Link updates tracking changes over time\"\n/\u003e\n\nEach link revision chains to the previous, tracking changes.\n\n### Link Metadata\n\nWhile the standard link revision doesn't include metadata, you can add it by:\n\n1. Creating an object revision with link metadata\n2. Following it with a link revision\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object - metadata: 'This links dependencies']\n      Link[Link Revision]\n      Dep1[Dep1]\n      Dep2[Dep2]\n      Dep3[Dep3]\n\n      Obj --\u003e Link\n      Link -.-\u003e|references| Dep1\n      Link -.-\u003e|references| Dep2\n      Link -.-\u003e|references| Dep3\n  `}\n  caption=\"Link metadata using object revision\"\n/\u003e\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Can be linked, and can precede link revisions\n- **Signature Revisions**: Can be linked (e.g., aggregating signatures)\n- **Witness Revisions**: Can be linked, or can follow link revisions\n- **Template Revisions**: Typically not linked (they're standalone)\n\n## Security Considerations\n\n### 1. Link Validation\n\n**Verify Existence**: Ensure linked revisions actually exist before creating link\n**Verify Integrity**: Validate linked chains are not corrupted\n\n### 2. Circular Dependencies\n\n**Detection**: Implement cycle detection in verification\n**Policy**: Decide if cycles are allowed in your application\n\n### 3. Link Spam\n\n**Prevention**: Validate that links are meaningful and authorized\n**Rate Limiting**: Prevent excessive linking in systems\n\n### 4. Temporal Consistency\n\n**Timestamp Checking**: Ensure links don't reference \"future\" revisions\n**Causality**: Maintain causal ordering of events\n\n### 5. Authorization\n\n**Link Permission**: Verify the creator has rights to link to target chains\n**Privacy**: Linking may reveal relationships between otherwise private chains\n\n## Performance Considerations\n\n### Link Depth\n\nDeep link hierarchies impact verification time:\n\n```\nObject ‚Üí Link (10 chains) ‚Üí Each chain has Link (5 chains)\nTotal: 1 + 10 + 50 = 61 chains to verify\n```\n\n**Optimization**: Cache verified chains, use lazy loading\n\n### Link Width\n\nWide links (many references) increase storage and bandwidth:\n\n```\nLink ‚Üí [1000 chains]\n```\n\n**Optimization**: Paginate links, use link batching\n\n### Verification Strategy\n\n**Lazy**: Only verify linked chains when accessed\n**Eager**: Verify all linked chains upfront\n**Selective**: Verify critical paths only\n\n## Comparison with Other Approaches\n\n### vs Direct References\n\n**Direct Reference** (in object payload):\n```json\n{\n  \"payload\": {\n    \"dependencies\": [\"0xabc...\", \"0xdef...\"]\n  }\n}\n```\n\n**Link Revision**:\n```json\n{\n  \"link_verification_hashes\": [\"0xabc...\", \"0xdef...\"]\n}\n```\n\n**Advantages of Link Revision**:\n- Explicit in protocol (not application-specific)\n- Verifiable without parsing payload\n- Consistent structure across applications\n- Can be signed and witnessed separately\n\n### vs Witness Batching\n\n**Witness Batching**: Uses Merkle tree for efficient blockchain anchoring\n**Link Revision**: Creates explicit relationships between chains\n\n**Key Difference**: Witness is about timestamping, Link is about relationships.\n\n## Best Practices\n\n### 1. Use Descriptive Ordering\n\nOrder links meaningfully:\n```\n[\"primary_source\", \"secondary_source\", \"tertiary_source\"]\n```\n\n### 2. Link to Stable Points\n\nLink to revisions that are finalized (signed/witnessed):\n\n\u003cMermaid\n  chart={`\n    graph LR\n      Obj[Object]\n      Sign[Sign]\n      Witness[Witness]\n      Link[Link references this witnessed revision]\n\n      Obj --\u003e Sign\n      Sign --\u003e Witness\n      Witness -.-\u003e Link\n  `}\n  caption=\"Linking to stable, witnessed revisions\"\n/\u003e\n\n### 3. Document Link Semantics\n\nPrecede link with an object explaining the relationships:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object - description: 'These are the project dependencies']\n      Link[Link Revision]\n      Deps[Dependency chains]\n\n      Obj --\u003e Link\n      Link -.-\u003e|references| Deps\n  `}\n  caption=\"Documenting link semantics with object metadata\"\n/\u003e\n\n### 4. Consider Verification Cost\n\nLimit link depth and width for practical verification times.\n\n### 5. Use Links for Cross-Chain Only\n\nDon't use links for intra-chain references (use `previous_revision` instead).\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - Often linked\n- [Signature Revision](/schema_reference/signing_revision) - Can aggregate via links\n- [Witness Revision](/schema_reference/witness_revision) - Often follows links\n- [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) - Mathematical foundation for link structures\n"])</script><script>self.__next_f.push([1,"2c:T4217,"])</script><script>self.__next_f.push([1,"\n# Link Revision\n\nA Link Revision creates verifiable connections between separate revision chains. It allows you to establish relationships, dependencies, or references between different objects, effectively creating a graph structure of interconnected chains. Link revisions are essential for composing complex data structures and maintaining provenance across multiple chains.\n\n## Overview\n\nLink revisions enable:\n- **Chain Composition**: Connect multiple independent chains together\n- **Dependency Tracking**: Express that one chain depends on others\n- **Multi-Party Collaboration**: Combine contributions from different parties\n- **Provenance Graphs**: Build complex data relationship structures\n- **Verification Aggregation**: Group related chains for batch verification\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the previous revision in this chain |\n| `revision_type` | string | Yes | Always `\"link\"` for link revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the link was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `link_verification_hashes` | array | Yes | Array of revision hashes being linked to |\n\n### Field Details\n\n#### link_verification_hashes\n- **Type**: Array of hex strings\n- **Format**: Each element is a lowercase hex string prefixed with `0x`\n- **Purpose**: References to other revision chains\n- **Minimum**: Can be empty array (though typically contains at least one link)\n- **Maximum**: No strict limit, but practical limits depend on implementation\n- **Order**: Order may be significant depending on use case\n\n## Example\n\n### Basic Link Revision\n\nLinking to two other chains:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n    \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\"\n  ]\n}\n```\n\n### Single Link\n\nLinking to a single chain:\n\n```json\n{\n  \"previous_revision\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\"\n  ]\n}\n```\n\n### Multiple Links (Aggregation)\n\nAggregating many chains:\n\n```json\n{\n  \"previous_revision\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c\",\n  \"revision_type\": \"link\",\n  \"nonce\": \"0xa1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"link_verification_hashes\": [\n    \"0x1111111111111111111111111111111111111111111111111111111111111111\",\n    \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n    \"0x3333333333333333333333333333333333333333333333333333333333333333\",\n    \"0x4444444444444444444444444444444444444444444444444444444444444444\",\n    \"0x5555555555555555555555555555555555555555555555555555555555555555\"\n  ]\n}\n```\n\n## Validation Rules\n\nA Link Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"link\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Link Array**: `link_verification_hashes` is a valid array\n5. **Link Format**: Each element in the array is a valid hex string with `0x` prefix\n6. **Link Targets**: Each referenced revision should exist and be verifiable (optional strict validation)\n7. **No Duplicates**: Typically shouldn't contain duplicate hashes (application-specific)\n8. **Hash Verification**: The computed hash of the link revision is correct\n\n## Common Use Cases\n\n### 1. Document Dependencies\n\nLink a document to its source materials:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Contract[Contract Document - Object]\n      Link[Link Revision]\n      Ref1[Reference Doc 1]\n      Ref2[Reference Doc 2]\n      Ref3[Reference Doc 3]\n\n      Contract --\u003e Link\n      Link -.-\u003e|references| Ref1\n      Link -.-\u003e|references| Ref2\n      Link -.-\u003e|references| Ref3\n  `}\n  caption=\"Document dependencies using link revision\"\n/\u003e\n\n### 2. Multi-Party Signing\n\nCombine independent signatures:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Doc[Document Object]\n      SigA[Signature - Alice]\n      SigB[Signature - Bob]\n      SigC[Signature - Carol]\n      Link[Link Revision]\n      Witness[Witness - Timestamp all]\n\n      Doc --\u003e SigA\n      Doc --\u003e SigB\n      Doc --\u003e SigC\n      SigA --\u003e Link\n      SigB --\u003e Link\n      SigC --\u003e Link\n      Link --\u003e Witness\n  `}\n  caption=\"Multi-party signing with link revision\"\n/\u003e\n\n### 3. Bill of Materials\n\nLink a product to its components:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Product[Product Object]\n      Link[Link Revision]\n      Comp1[Component 1 Chain]\n      Comp2[Component 2 Chain]\n      Comp3[Component 3 Chain]\n\n      Product --\u003e Link\n      Link -.-\u003e|references| Comp1\n      Link -.-\u003e|references| Comp2\n      Link -.-\u003e|references| Comp3\n  `}\n  caption=\"Bill of materials with component chains\"\n/\u003e\n\nEach component has its own provenance chain.\n\n### 4. Credential Bundling\n\nGroup related credentials:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Profile[Profile Object]\n      Link[Link Revision]\n      Email[Email Credential]\n      Domain[Domain Credential]\n      GitHub[GitHub Credential]\n\n      Profile --\u003e Link\n      Link -.-\u003e|references| Email\n      Link -.-\u003e|references| Domain\n      Link -.-\u003e|references| GitHub\n  `}\n  caption=\"Credential bundling with link revision\"\n/\u003e\n\n### 5. Supply Chain Aggregation\n\nCombine supply chain events:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Tracking[Shipment Tracking]\n      Link[Link Revision]\n      Manufacturer[Manufacturer Chain]\n      Shipper[Shipper Chain]\n      Customs[Customs Chain]\n      Final[Final Delivery Confirmation]\n\n      Tracking --\u003e Link\n      Link -.-\u003e|references| Manufacturer\n      Link -.-\u003e|references| Shipper\n      Link -.-\u003e|references| Customs\n      Link --\u003e Final\n  `}\n  caption=\"Supply chain aggregation\"\n/\u003e\n\n### 6. Academic Citation\n\nLink a paper to cited works:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Paper[Research Paper - Object]\n      Link[Link Revision]\n      Cite1[Citation 1 Chain]\n      Cite2[Citation 2 Chain]\n      CiteN[Citation N Chain]\n\n      Paper --\u003e Link\n      Link -.-\u003e|references| Cite1\n      Link -.-\u003e|references| Cite2\n      Link -.-\u003e|references| CiteN\n  `}\n  caption=\"Academic citation with link revision\"\n/\u003e\n\n### 7. Version History\n\nLink to previous versions:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      V3[Document v3 - Object]\n      Link[Link Revision]\n      V1[Document v1 Final]\n      V2[Document v2 Final]\n\n      V3 --\u003e Link\n      Link -.-\u003e|references| V1\n      Link -.-\u003e|references| V2\n  `}\n  caption=\"Version history with link revision\"\n/\u003e\n\n### 8. Approval Workflow Merge\n\nMerge parallel approval processes:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Draft[Document Draft]\n      ReviewA[Review A]\n      ReviewB[Review B]\n      ApproveA[Approve A]\n      ApproveB[Approve B]\n      Link[Link Revision]\n      Final[Final Version]\n\n      Draft --\u003e ReviewA\n      Draft --\u003e ReviewB\n      ReviewA --\u003e ApproveA\n      ReviewB --\u003e ApproveB\n      ApproveA --\u003e Link\n      ApproveB --\u003e Link\n      Link --\u003e Final\n  `}\n  caption=\"Approval workflow merge with link revision\"\n/\u003e\n\n## Link Patterns\n\n### Pattern 1: Linear Dependency Chain\n\n\u003cMermaid\n  chart={`\n    graph LR\n      A[Object A]\n      LinkAB[Link]\n      B[Object B]\n      LinkBC[Link]\n      C[Object C]\n\n      A --\u003e LinkAB\n      LinkAB -.-\u003e|references| B\n      B --\u003e LinkBC\n      LinkBC -.-\u003e|references| C\n  `}\n  caption=\"Linear dependency chain\"\n/\u003e\n\nEach object depends on the previous one.\n\n### Pattern 2: Star Pattern (Aggregation)\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Link[Link Revision]\n      A[Chain A]\n      B[Chain B]\n      C[Chain C]\n      D[Chain D]\n      E[Chain E]\n\n      Link -.-\u003e|references| A\n      Link -.-\u003e|references| B\n      Link -.-\u003e|references| C\n      Link -.-\u003e|references| D\n      Link -.-\u003e|references| E\n  `}\n  caption=\"Star pattern - one link references multiple chains\"\n/\u003e\n\nOne link revision references multiple chains.\n\n### Pattern 3: Tree Pattern\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Root[Root Object]\n      Link1[Link to A, B]\n      LinkA[Link to A1, A2]\n      LinkB[Link to B1, B2]\n      A1[A1]\n      A2[A2]\n      B1[B1]\n      B2[B2]\n\n      Root --\u003e Link1\n      Link1 -.-\u003e LinkA\n      Link1 -.-\u003e LinkB\n      LinkA -.-\u003e|references| A1\n      LinkA -.-\u003e|references| A2\n      LinkB -.-\u003e|references| B1\n      LinkB -.-\u003e|references| B2\n  `}\n  caption=\"Tree pattern - hierarchical structure using links\"\n/\u003e\n\nHierarchical structure using links.\n\n### Pattern 4: Graph Pattern\n\n\u003cMermaid\n  chart={`\n    graph TD\n      A[A]\n      B[B]\n      C[C]\n      D[D]\n      E[E]\n      LinkA[Link from A]\n      LinkB[Link from B]\n      LinkC[Link from C]\n\n      A --\u003e LinkA\n      LinkA -.-\u003e|references| B\n      LinkA -.-\u003e|references| C\n\n      B --\u003e LinkB\n      LinkB -.-\u003e|references| C\n      LinkB -.-\u003e|references| D\n\n      C --\u003e LinkC\n      LinkC -.-\u003e|references| A\n      LinkC -.-\u003e|references| E\n  `}\n  caption=\"Graph pattern - complex graph with cycles and multiple connections\"\n/\u003e\n\nComplex graph with cycles and multiple connections.\n\n## Implementation Notes\n\n### Creating a Link Revision\n\n1. Identify the chains to link\n2. Get the head (latest) revision hash from each chain\n3. Collect hashes into `link_verification_hashes` array\n4. Determine the `previous_revision` for this link\n5. Generate nonce and timestamp\n6. Create the link revision structure\n7. Compute and verify the hash\n\n### Verifying a Link Revision\n\n#### Basic Verification\n```\n1. Verify link revision structure\n2. Validate each hash in link_verification_hashes\n3. Compute link revision hash\n```\n\n#### Deep Verification\n```\n1. Perform basic verification\n2. For each linked hash:\n   a. Retrieve the referenced revision\n   b. Verify the referenced revision chain\n   c. Check signatures and witnesses\n3. Validate all linked chains\n```\n\n### Link Resolution\n\nWhen traversing links:\n\n```\n1. Start with link revision\n2. Extract link_verification_hashes\n3. For each hash:\n   a. Resolve to actual revision\n   b. Load revision chain\n   c. Verify chain integrity\n4. Build complete relationship graph\n```\n\n## Advanced Topics\n\n### Cyclic References\n\nLinks can create cycles:\n\n\u003cMermaid\n  chart={`\n    graph LR\n      A[Chain A]\n      LinkA[Link from A]\n      B[Chain B]\n      LinkB[Link from B]\n\n      A --\u003e LinkA\n      LinkA -.-\u003e|references| B\n      B --\u003e LinkB\n      LinkB -.-\u003e|references| A\n  `}\n  caption=\"Cyclic references between chains\"\n/\u003e\n\n**Handling**:\n- Detect cycles during traversal\n- Use visited set to prevent infinite loops\n- Cycles may be valid depending on use case\n\n### Temporal Ordering\n\nLinks create a temporal relationship:\n\n```\nLink created at timestamp T references chains that existed before T\n```\n\n**Validation**:\n- Linked revisions should have timestamps \u003c link timestamp\n- Prevents linking to \"future\" revisions\n\n### Partial vs Complete References\n\n**Complete Reference**: Link to final revision of a chain\n```\nLink ‚Üí [Complete Chain A, Complete Chain B]\n```\n\n**Partial Reference**: Link to intermediate revision\n```\nLink ‚Üí [Chain A @ Revision 5, Chain B @ Revision 3]\n```\n\n### Link Updates\n\nTo update links over time:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object]\n      Link1[Link v1 - references A, B]\n      Link2[Link v2 - references A, B, C]\n      Link3[Link v3 - references A, C]\n\n      Obj --\u003e Link1\n      Link1 --\u003e Link2\n      Link2 --\u003e Link3\n  `}\n  caption=\"Link updates tracking changes over time\"\n/\u003e\n\nEach link revision chains to the previous, tracking changes.\n\n### Link Metadata\n\nWhile the standard link revision doesn't include metadata, you can add it by:\n\n1. Creating an object revision with link metadata\n2. Following it with a link revision\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object - metadata: 'This links dependencies']\n      Link[Link Revision]\n      Dep1[Dep1]\n      Dep2[Dep2]\n      Dep3[Dep3]\n\n      Obj --\u003e Link\n      Link -.-\u003e|references| Dep1\n      Link -.-\u003e|references| Dep2\n      Link -.-\u003e|references| Dep3\n  `}\n  caption=\"Link metadata using object revision\"\n/\u003e\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Can be linked, and can precede link revisions\n- **Signature Revisions**: Can be linked (e.g., aggregating signatures)\n- **Witness Revisions**: Can be linked, or can follow link revisions\n- **Template Revisions**: Typically not linked (they're standalone)\n\n## Security Considerations\n\n### 1. Link Validation\n\n**Verify Existence**: Ensure linked revisions actually exist before creating link\n**Verify Integrity**: Validate linked chains are not corrupted\n\n### 2. Circular Dependencies\n\n**Detection**: Implement cycle detection in verification\n**Policy**: Decide if cycles are allowed in your application\n\n### 3. Link Spam\n\n**Prevention**: Validate that links are meaningful and authorized\n**Rate Limiting**: Prevent excessive linking in systems\n\n### 4. Temporal Consistency\n\n**Timestamp Checking**: Ensure links don't reference \"future\" revisions\n**Causality**: Maintain causal ordering of events\n\n### 5. Authorization\n\n**Link Permission**: Verify the creator has rights to link to target chains\n**Privacy**: Linking may reveal relationships between otherwise private chains\n\n## Performance Considerations\n\n### Link Depth\n\nDeep link hierarchies impact verification time:\n\n```\nObject ‚Üí Link (10 chains) ‚Üí Each chain has Link (5 chains)\nTotal: 1 + 10 + 50 = 61 chains to verify\n```\n\n**Optimization**: Cache verified chains, use lazy loading\n\n### Link Width\n\nWide links (many references) increase storage and bandwidth:\n\n```\nLink ‚Üí [1000 chains]\n```\n\n**Optimization**: Paginate links, use link batching\n\n### Verification Strategy\n\n**Lazy**: Only verify linked chains when accessed\n**Eager**: Verify all linked chains upfront\n**Selective**: Verify critical paths only\n\n## Comparison with Other Approaches\n\n### vs Direct References\n\n**Direct Reference** (in object payload):\n```json\n{\n  \"payload\": {\n    \"dependencies\": [\"0xabc...\", \"0xdef...\"]\n  }\n}\n```\n\n**Link Revision**:\n```json\n{\n  \"link_verification_hashes\": [\"0xabc...\", \"0xdef...\"]\n}\n```\n\n**Advantages of Link Revision**:\n- Explicit in protocol (not application-specific)\n- Verifiable without parsing payload\n- Consistent structure across applications\n- Can be signed and witnessed separately\n\n### vs Witness Batching\n\n**Witness Batching**: Uses Merkle tree for efficient blockchain anchoring\n**Link Revision**: Creates explicit relationships between chains\n\n**Key Difference**: Witness is about timestamping, Link is about relationships.\n\n## Best Practices\n\n### 1. Use Descriptive Ordering\n\nOrder links meaningfully:\n```\n[\"primary_source\", \"secondary_source\", \"tertiary_source\"]\n```\n\n### 2. Link to Stable Points\n\nLink to revisions that are finalized (signed/witnessed):\n\n\u003cMermaid\n  chart={`\n    graph LR\n      Obj[Object]\n      Sign[Sign]\n      Witness[Witness]\n      Link[Link references this witnessed revision]\n\n      Obj --\u003e Sign\n      Sign --\u003e Witness\n      Witness -.-\u003e Link\n  `}\n  caption=\"Linking to stable, witnessed revisions\"\n/\u003e\n\n### 3. Document Link Semantics\n\nPrecede link with an object explaining the relationships:\n\n\u003cMermaid\n  chart={`\n    graph TD\n      Obj[Object - description: 'These are the project dependencies']\n      Link[Link Revision]\n      Deps[Dependency chains]\n\n      Obj --\u003e Link\n      Link -.-\u003e|references| Deps\n  `}\n  caption=\"Documenting link semantics with object metadata\"\n/\u003e\n\n### 4. Consider Verification Cost\n\nLimit link depth and width for practical verification times.\n\n### 5. Use Links for Cross-Chain Only\n\nDon't use links for intra-chain references (use `previous_revision` instead).\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - Often linked\n- [Signature Revision](/schema_reference/signing_revision) - Can aggregate via links\n- [Witness Revision](/schema_reference/witness_revision) - Often follows links\n- [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) - Mathematical foundation for link structures\n"])</script><script>self.__next_f.push([1,"2d:T2073,"])</script><script>self.__next_f.push([1,"\n# Object Revision\n\nAn Object Revision is the primary data-carrying revision type in Aqua Protocol v4. It stores arbitrary structured data that conforms to a template schema. Object revisions are typically the first revision in a chain (genesis) or follow other object revisions.\n\n## Overview\n\nObject revisions serve as containers for application data. Each object revision:\n- References a template (via `revision_type` field) that defines its schema\n- Contains a `payload` with the actual data\n- Can be the genesis revision (no `previous_revision`) or link to a previous revision\n- Must conform to the validation rules defined by its template\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Conditional | Hash reference to the previous revision. **Optional for genesis revisions**, **Required for subsequent revisions** |\n| `revision_type` | string | Yes | Hash reference to the template that defines the payload schema |\n| `nonce` | string | Yes | Random 16-byte hex string (e.g., `0x2ba6a8b9b987cf8c3567f72871812ae9`) for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp (seconds since epoch) when the revision was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `payload` | object | Yes | The actual data, must conform to the referenced template schema |\n\n### Field Details\n\n#### previous_revision\n- **Format**: Lowercase hex string prefixed with `0x` (e.g., `0x3f8a...`)\n- **Length**: Variable (typically 64 characters for SHA3-256 hashes)\n- **Omitted**: Only in genesis revisions (the first revision in a chain)\n- **Purpose**: Creates the chain linkage and ensures revision ordering\n\n#### revision_type\n- **Format**: Hash reference pointing to a Template Revision\n- **Purpose**: Identifies which template validates this object's payload\n- **Example**: `0x1234abcd...` (hash of a template revision)\n- **Validation**: The template's schema must validate the payload\n\n#### payload\n- **Type**: JSON object\n- **Validation**: Must conform to the JSON Schema defined in the referenced template\n- **Flexibility**: Can contain any structured data as long as it matches the template\n- **Size**: Depends on the method:\n  - `scalar`: Entire payload is hashed directly\n  - `tree`: Payload is broken into leaves for merkle tree construction\n\n## Methods\n\n### Scalar Method\n\nThe `scalar` method treats the entire object as a single unit. The payload is serialized, canonicalized, and hashed as one block.\n\n**Best for:**\n- Small to medium-sized objects\n- When you need to verify the entire object at once\n- Simple use cases\n\n### Tree Method\n\nThe `tree` method breaks the payload into leaves using JSON pointers, creating a merkle tree structure.\n\n**Best for:**\n- Large objects where partial verification is needed\n- When you want to prove specific fields without revealing the entire object\n- Advanced use cases requiring selective disclosure\n\n## Examples\n\n### Example 1: Genesis Object Revision (File)\n\nThis is a genesis revision (first in chain) using the File template:\n\n```json\n{\n  \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n  \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"payload_type\": \"application/pdf\",\n    \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n    \"hash_type\": \"FIPS_202-SHA3-256\",\n    \"descriptor\": \"Important Contract Document\"\n  }\n}\n```\n\n**Note**: No `previous_revision` field because this is a genesis revision.\n\n### Example 2: Subsequent Object Revision (Domain Claim)\n\nThis revision follows another revision in the chain:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"0x8b3e4c7d9f1a2b5c6e8f0a3b4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"domain\": \"example.com\",\n    \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n### Example 3: Object with Tree Method\n\nUsing the tree method for a larger object:\n\n```json\n{\n  \"previous_revision\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b\",\n  \"revision_type\": \"0x4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"tree\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"+1234567890\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"country\": \"USA\"\n    },\n    \"metadata\": {\n      \"created\": \"2024-01-01\",\n      \"verified\": true\n    }\n  }\n}\n```\n\n**With tree method**: Each field (using JSON pointers like `/name`, `/email`, `/address/city`) becomes a leaf in the merkle tree.\n\n## Validation Rules\n\nAn Object Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Version**: The `version` field matches `\"https://aqua-protocol.org/docs/v4/schema\"`\n3. **Method**: The `method` is either `\"scalar\"` or `\"tree\"`\n4. **Hash Type**: The `hash_type` is a recognized algorithm (e.g., `\"FIPS_202-SHA3-256\"`)\n5. **Nonce**: Is a valid 16-byte hex string prefixed with `0x`\n6. **Timestamp**: Is a valid Unix timestamp\n7. **Previous Revision**:\n   - Must be absent for genesis revisions\n   - Must be present and valid for non-genesis revisions\n   - Must reference an existing revision\n8. **Revision Type**: Must reference a valid template revision\n9. **Payload**: Must conform to the JSON Schema defined in the referenced template\n10. **Hash Verification**: The computed hash matches what's expected\n\n## Common Use Cases\n\n### Document Storage\nStore file metadata with hash references:\n```json\n{\n  \"payload\": {\n    \"payload_type\": \"application/pdf\",\n    \"hash\": \"0x...\",\n    \"hash_type\": \"FIPS_202-SHA3-256\",\n    \"descriptor\": \"Legal Agreement 2024\"\n  }\n}\n```\n\n### Identity Claims\nStore verifiable claims about entities:\n```json\n{\n  \"payload\": {\n    \"domain\": \"company.com\",\n    \"wallet_address\": \"0x742d35Cc...\"\n  }\n}\n```\n\n### Credential Data\nStore structured credential information:\n```json\n{\n  \"payload\": {\n    \"credential_type\": \"EmailVerification\",\n    \"subject\": \"user@example.com\",\n    \"issuer\": \"0x...\",\n    \"issued_at\": 1704067200\n  }\n}\n```\n\n## Relationship with Other Revisions\n\nAfter creating an Object Revision, you typically:\n\n1. **Sign it** - Add a Signature Revision to prove authenticity\n2. **Witness it** - Add a Witness Revision for timestamped proof\n3. **Update it** - Create a new Object Revision that references this one\n4. **Link it** - Create a Link Revision to connect to other chains\n\n## Implementation Notes\n\n### Creating an Object Revision\n\nWhen implementing object revision creation:\n\n1. Validate payload against the template schema first\n2. Generate a random 16-byte nonce\n3. Capture the current timestamp\n4. Include `previous_revision` only if not genesis\n5. Serialize according to the chosen method\n6. Compute the hash for verification\n\n### Verifying an Object Revision\n\nTo verify an object revision:\n\n1. Check all required fields are present\n2. Validate field types and formats\n3. Verify the referenced template exists\n4. Validate payload against template schema\n5. Recompute the hash and compare\n6. If not genesis, verify `previous_revision` exists and is valid\n\n## See Also\n\n- [Template Revision](/schema_reference/template_revision) - Defines the schema for object payloads\n- [Signature Revision](/schema_reference/signing_revision) - Sign object revisions\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamped proof\n- [Link Revision](/schema_reference/link_revision) - Connect to other chains\n"])</script><script>self.__next_f.push([1,"2e:T2073,"])</script><script>self.__next_f.push([1,"\n# Object Revision\n\nAn Object Revision is the primary data-carrying revision type in Aqua Protocol v4. It stores arbitrary structured data that conforms to a template schema. Object revisions are typically the first revision in a chain (genesis) or follow other object revisions.\n\n## Overview\n\nObject revisions serve as containers for application data. Each object revision:\n- References a template (via `revision_type` field) that defines its schema\n- Contains a `payload` with the actual data\n- Can be the genesis revision (no `previous_revision`) or link to a previous revision\n- Must conform to the validation rules defined by its template\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Conditional | Hash reference to the previous revision. **Optional for genesis revisions**, **Required for subsequent revisions** |\n| `revision_type` | string | Yes | Hash reference to the template that defines the payload schema |\n| `nonce` | string | Yes | Random 16-byte hex string (e.g., `0x2ba6a8b9b987cf8c3567f72871812ae9`) for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp (seconds since epoch) when the revision was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `payload` | object | Yes | The actual data, must conform to the referenced template schema |\n\n### Field Details\n\n#### previous_revision\n- **Format**: Lowercase hex string prefixed with `0x` (e.g., `0x3f8a...`)\n- **Length**: Variable (typically 64 characters for SHA3-256 hashes)\n- **Omitted**: Only in genesis revisions (the first revision in a chain)\n- **Purpose**: Creates the chain linkage and ensures revision ordering\n\n#### revision_type\n- **Format**: Hash reference pointing to a Template Revision\n- **Purpose**: Identifies which template validates this object's payload\n- **Example**: `0x1234abcd...` (hash of a template revision)\n- **Validation**: The template's schema must validate the payload\n\n#### payload\n- **Type**: JSON object\n- **Validation**: Must conform to the JSON Schema defined in the referenced template\n- **Flexibility**: Can contain any structured data as long as it matches the template\n- **Size**: Depends on the method:\n  - `scalar`: Entire payload is hashed directly\n  - `tree`: Payload is broken into leaves for merkle tree construction\n\n## Methods\n\n### Scalar Method\n\nThe `scalar` method treats the entire object as a single unit. The payload is serialized, canonicalized, and hashed as one block.\n\n**Best for:**\n- Small to medium-sized objects\n- When you need to verify the entire object at once\n- Simple use cases\n\n### Tree Method\n\nThe `tree` method breaks the payload into leaves using JSON pointers, creating a merkle tree structure.\n\n**Best for:**\n- Large objects where partial verification is needed\n- When you want to prove specific fields without revealing the entire object\n- Advanced use cases requiring selective disclosure\n\n## Examples\n\n### Example 1: Genesis Object Revision (File)\n\nThis is a genesis revision (first in chain) using the File template:\n\n```json\n{\n  \"revision_type\": \"0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e\",\n  \"nonce\": \"0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"payload_type\": \"application/pdf\",\n    \"hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n    \"hash_type\": \"FIPS_202-SHA3-256\",\n    \"descriptor\": \"Important Contract Document\"\n  }\n}\n```\n\n**Note**: No `previous_revision` field because this is a genesis revision.\n\n### Example 2: Subsequent Object Revision (Domain Claim)\n\nThis revision follows another revision in the chain:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"0x8b3e4c7d9f1a2b5c6e8f0a3b4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"domain\": \"example.com\",\n    \"wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n### Example 3: Object with Tree Method\n\nUsing the tree method for a larger object:\n\n```json\n{\n  \"previous_revision\": \"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b\",\n  \"revision_type\": \"0x4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"tree\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"payload\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"+1234567890\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"country\": \"USA\"\n    },\n    \"metadata\": {\n      \"created\": \"2024-01-01\",\n      \"verified\": true\n    }\n  }\n}\n```\n\n**With tree method**: Each field (using JSON pointers like `/name`, `/email`, `/address/city`) becomes a leaf in the merkle tree.\n\n## Validation Rules\n\nAn Object Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Version**: The `version` field matches `\"https://aqua-protocol.org/docs/v4/schema\"`\n3. **Method**: The `method` is either `\"scalar\"` or `\"tree\"`\n4. **Hash Type**: The `hash_type` is a recognized algorithm (e.g., `\"FIPS_202-SHA3-256\"`)\n5. **Nonce**: Is a valid 16-byte hex string prefixed with `0x`\n6. **Timestamp**: Is a valid Unix timestamp\n7. **Previous Revision**:\n   - Must be absent for genesis revisions\n   - Must be present and valid for non-genesis revisions\n   - Must reference an existing revision\n8. **Revision Type**: Must reference a valid template revision\n9. **Payload**: Must conform to the JSON Schema defined in the referenced template\n10. **Hash Verification**: The computed hash matches what's expected\n\n## Common Use Cases\n\n### Document Storage\nStore file metadata with hash references:\n```json\n{\n  \"payload\": {\n    \"payload_type\": \"application/pdf\",\n    \"hash\": \"0x...\",\n    \"hash_type\": \"FIPS_202-SHA3-256\",\n    \"descriptor\": \"Legal Agreement 2024\"\n  }\n}\n```\n\n### Identity Claims\nStore verifiable claims about entities:\n```json\n{\n  \"payload\": {\n    \"domain\": \"company.com\",\n    \"wallet_address\": \"0x742d35Cc...\"\n  }\n}\n```\n\n### Credential Data\nStore structured credential information:\n```json\n{\n  \"payload\": {\n    \"credential_type\": \"EmailVerification\",\n    \"subject\": \"user@example.com\",\n    \"issuer\": \"0x...\",\n    \"issued_at\": 1704067200\n  }\n}\n```\n\n## Relationship with Other Revisions\n\nAfter creating an Object Revision, you typically:\n\n1. **Sign it** - Add a Signature Revision to prove authenticity\n2. **Witness it** - Add a Witness Revision for timestamped proof\n3. **Update it** - Create a new Object Revision that references this one\n4. **Link it** - Create a Link Revision to connect to other chains\n\n## Implementation Notes\n\n### Creating an Object Revision\n\nWhen implementing object revision creation:\n\n1. Validate payload against the template schema first\n2. Generate a random 16-byte nonce\n3. Capture the current timestamp\n4. Include `previous_revision` only if not genesis\n5. Serialize according to the chosen method\n6. Compute the hash for verification\n\n### Verifying an Object Revision\n\nTo verify an object revision:\n\n1. Check all required fields are present\n2. Validate field types and formats\n3. Verify the referenced template exists\n4. Validate payload against template schema\n5. Recompute the hash and compare\n6. If not genesis, verify `previous_revision` exists and is valid\n\n## See Also\n\n- [Template Revision](/schema_reference/template_revision) - Defines the schema for object payloads\n- [Signature Revision](/schema_reference/signing_revision) - Sign object revisions\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamped proof\n- [Link Revision](/schema_reference/link_revision) - Connect to other chains\n"])</script><script>self.__next_f.push([1,"2f:T1183,"])</script><script>self.__next_f.push([1,"\nRevisions are content-identifiable envelops in Aqua-Protocol. They are atomic and form a graph structure in a hash-tree. It represents the evolutionary, iterative, and historical essence of the atomic objects in the Aqua Protocol.\n\n\n- Revision Chaining: Revisions form chains via optional previous_revision (a SHA3-256 hash), marking genesis if absent.\n- Type Identification: revision_type specifies the revision's purpose either a reference to a [template](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21) (32-hex hash) (for [Object](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21) revisions) or built-in types like \"[template](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\", \"[signature](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\", or \"[link](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\".\n- Timing and Entropy: Includes a Unix timestamp (local_timestamp, unsigned 64-bit) and a random nonce (128-bit hex) for ordering and anti-collision.\n- Versioning: version points to a protocol schema URL or a hash/custom string (up to 128 chars) for compatibility.\n- Canonicalisation Method: method chooses between \"scalar\" (simple object hash for efficiency) or \"tree\" (Merkle tree for granular proofs, e.g., selective disclosure).\n- Hash Type: identifier of the hashing function to generate the hash ID of the revision\n- Schema Integration: Optional schema embeds a full JSON Schema (Draft 2020-12) for validating custom data in templates.\n\n\n```JSON\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"https://aqua-protocol.org/docs/v4/metaschema\",\n  \"title\": \"Aqua Protocol Metaschema\",\n  \"description\": \"Schema for metadata in Aqua Protocol revisions\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"previous_revision\": {\n      \"description\": \"SHA3-256 hash of the previous revision. If not present, this is a genesis revision.\",\n      \"type\": \"string\",\n      \"pattern\": \"^[0-9a-fA-F]{64}$\"\n    },\n    \"revision_type\": {\n      \"description\": \"Non-traversable reference to a template or one of the specified types.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{32}$\"\n          \"description\": \"Non-traversable reference to a template revision hash.\"\n        },\n        {\n          \"type\": \"string\",\n          \"enum\": [\"template\", \"signature\", \"link\"]\n          \"description\": \"Fundamental revision types within Aqua Protocol\"\n        }\n      ]\n    },\n    \"local_timestamp\": {\n      \"description\": \"Unsigned 64-bit integer Unix timestamp.\",\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 18446744073709551615\n    },\n    \"nonce\": {\n      \"description\": \"128-bit random bytes for entropy, hex-encoded.\",\n      \"type\": \"string\",\n      \"pattern\": \"^[0-9a-fA-F]{32}$\"\n    },\n    \"version\": {\n      \"description\": \"Version identifier: either a specific URL or a SHA256 hash.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"const\": \"https://aqua-protocol.org/docs/v4/schema | FIPS_202-SHA3-256\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^{32}\"\n          \"maxLength\": 128,\n        }\n      ]\n    },\n    \"hash_type\": {\n      \"description\": \"Hash function identifier: either FIPS_202-SHA3-256 or a custom hashing type.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"const\": \"FIPS_202-SHA3-256\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^{32}\"\n          \"maxLength\": 128,\n        }\n      ]\n    }\n    \"method\": {\n      \"description\": \"Method type.\",\n      \"type\": \"string\",\n      \"enum\": [\"tree\", \"scalar\"]\n      \"description\": \"Scalar: Is a simple hash of the stringified revision object. This is the default method for performance reasons. Tree: Creates a merkle tree of all the values. This allows a more granular verification. This is used for e.g. selective disclosure\",\n    }\n    \"schema\": {\n\t    \"description\": \"Schema definition found in template revisions\",\n\t    \"type\": \"object\",\n\t    \"$ref\": \"https://json-schema.org/draft/2020-12/schema\"\n    }\n  },\n  \"required\": [\"revision_type\", \"local_timestamp\", \"nonce\", \"version\", \"hash_type\", \"method\"],\n  // This is to allow other revision types like link revision and signature revision\n  // Its the responsibility of the implementation to be more or less permissive\n  \"additionalFields\": true\n}\n\n\n\n```"])</script><script>self.__next_f.push([1,"30:T1183,"])</script><script>self.__next_f.push([1,"\nRevisions are content-identifiable envelops in Aqua-Protocol. They are atomic and form a graph structure in a hash-tree. It represents the evolutionary, iterative, and historical essence of the atomic objects in the Aqua Protocol.\n\n\n- Revision Chaining: Revisions form chains via optional previous_revision (a SHA3-256 hash), marking genesis if absent.\n- Type Identification: revision_type specifies the revision's purpose either a reference to a [template](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21) (32-hex hash) (for [Object](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21) revisions) or built-in types like \"[template](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\", \"[signature](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\", or \"[link](https://www.notion.so/V4-Protocol-Draft-27ae695c0eec801c95fff40830e4c0e4?pvs=21)\".\n- Timing and Entropy: Includes a Unix timestamp (local_timestamp, unsigned 64-bit) and a random nonce (128-bit hex) for ordering and anti-collision.\n- Versioning: version points to a protocol schema URL or a hash/custom string (up to 128 chars) for compatibility.\n- Canonicalisation Method: method chooses between \"scalar\" (simple object hash for efficiency) or \"tree\" (Merkle tree for granular proofs, e.g., selective disclosure).\n- Hash Type: identifier of the hashing function to generate the hash ID of the revision\n- Schema Integration: Optional schema embeds a full JSON Schema (Draft 2020-12) for validating custom data in templates.\n\n\n```JSON\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"https://aqua-protocol.org/docs/v4/metaschema\",\n  \"title\": \"Aqua Protocol Metaschema\",\n  \"description\": \"Schema for metadata in Aqua Protocol revisions\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"previous_revision\": {\n      \"description\": \"SHA3-256 hash of the previous revision. If not present, this is a genesis revision.\",\n      \"type\": \"string\",\n      \"pattern\": \"^[0-9a-fA-F]{64}$\"\n    },\n    \"revision_type\": {\n      \"description\": \"Non-traversable reference to a template or one of the specified types.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{32}$\"\n          \"description\": \"Non-traversable reference to a template revision hash.\"\n        },\n        {\n          \"type\": \"string\",\n          \"enum\": [\"template\", \"signature\", \"link\"]\n          \"description\": \"Fundamental revision types within Aqua Protocol\"\n        }\n      ]\n    },\n    \"local_timestamp\": {\n      \"description\": \"Unsigned 64-bit integer Unix timestamp.\",\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 18446744073709551615\n    },\n    \"nonce\": {\n      \"description\": \"128-bit random bytes for entropy, hex-encoded.\",\n      \"type\": \"string\",\n      \"pattern\": \"^[0-9a-fA-F]{32}$\"\n    },\n    \"version\": {\n      \"description\": \"Version identifier: either a specific URL or a SHA256 hash.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"const\": \"https://aqua-protocol.org/docs/v4/schema | FIPS_202-SHA3-256\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^{32}\"\n          \"maxLength\": 128,\n        }\n      ]\n    },\n    \"hash_type\": {\n      \"description\": \"Hash function identifier: either FIPS_202-SHA3-256 or a custom hashing type.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"const\": \"FIPS_202-SHA3-256\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^{32}\"\n          \"maxLength\": 128,\n        }\n      ]\n    }\n    \"method\": {\n      \"description\": \"Method type.\",\n      \"type\": \"string\",\n      \"enum\": [\"tree\", \"scalar\"]\n      \"description\": \"Scalar: Is a simple hash of the stringified revision object. This is the default method for performance reasons. Tree: Creates a merkle tree of all the values. This allows a more granular verification. This is used for e.g. selective disclosure\",\n    }\n    \"schema\": {\n\t    \"description\": \"Schema definition found in template revisions\",\n\t    \"type\": \"object\",\n\t    \"$ref\": \"https://json-schema.org/draft/2020-12/schema\"\n    }\n  },\n  \"required\": [\"revision_type\", \"local_timestamp\", \"nonce\", \"version\", \"hash_type\", \"method\"],\n  // This is to allow other revision types like link revision and signature revision\n  // Its the responsibility of the implementation to be more or less permissive\n  \"additionalFields\": true\n}\n\n\n\n```"])</script><script>self.__next_f.push([1,"31:T2eb6,"])</script><script>self.__next_f.push([1,"\n# Signature Revision\n\nA Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.\n\n## Overview\n\nSignature revisions provide:\n- **Authentication**: Proof that a specific entity created or approved the previous revision\n- **Integrity**: Assurance that the signed revision hasn't been tampered with\n- **Non-repudiation**: The signer cannot deny having signed the revision\n- **Flexibility**: Support for multiple cryptographic signature schemes\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being signed |\n| `revision_type` | string | Yes | Always `\"signature\"` for signature revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `signature` | object | Yes | Signature value object (varies by signature type) |\n\n### Signature Value Object\n\nThe `signature` field is an object with different structures depending on the signature type.\n\n## Signature Types\n\n### 1. RSA Signature\n\nUses RSA public-key cryptography with PKCS#1 v1.5 padding.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"rsa\",\n  \"signature\": \"0x...\",\n  \"public_key\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"rsa\"` |\n| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |\n| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |\n\n#### Validation Rules\n- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)\n- Public key must be DER-encoded and between 200-600 bytes\n- Both fields must be lowercase hex strings prefixed with `0x`\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"rsa\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"public_key\": \"0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001\"\n  }\n}\n```\n\n---\n\n### 2. Ethereum (EIP-191) Signature\n\nUses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"ethereum:eip-191\",\n  \"signature\": \"0x...\",\n  \"signature_wallet_address\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"ethereum:eip-191\"` |\n| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |\n| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |\n\n#### Validation Rules\n- Signature must be exactly 65 bytes\n- Wallet address must be a valid EIP-55 checksummed address\n- Both fields must be hex strings prefixed with `0x`\n- Address checksum must be validated\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"ethereum:eip-191\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c\",\n    \"signature_wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).\n\n---\n\n### 3. DID JWS Signature\n\nUses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).\n\n#### Structure\n```json\n{\n  \"signature_type\": \"did:jws\",\n  \"jws\": \"eyJ...\",\n  \"did\": \"did:key:...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"did:jws\"` |\n| `jws` | string | Compact JWS (JSON Web Signature) |\n| `did` | string | Decentralized Identifier of the signer |\n\n#### Validation Rules\n- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)\n- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)\n- The DID document must be resolvable to verify the signature\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"did:jws\",\n    \"jws\": \"eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ\",\n    \"did\": \"did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\"\n  }\n}\n```\n\n---\n\n## What Gets Signed\n\nThe signature is computed over the **hash of the previous revision**, not the revision itself.\n\n### Signing Process\n\n1. Compute the hash of the `previous_revision`\n2. For Ethereum: Add EIP-191 prefix (`\\x19Ethereum Signed Message:\\n32`)\n3. Sign the hash using the appropriate method\n4. Create the signature revision with the signature value\n5. Compute the hash of the signature revision\n\n### Example Signing Flow\n\n```\nObject Revision =\u003e Compute Hash =\u003e Sign Hash =\u003e Signature Revision\n     |\n0x3f8a7b2c... (previous_revision in signature)\n```\n\n## Validation Rules\n\nA Signature Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"signature\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Signature Type**: One of `\"rsa\"`, `\"ethereum:eip-191\"`, or `\"did:jws\"`\n5. **Signature Format**: Matches the requirements for the specific signature type\n6. **No Unknown Fields**: The signature object contains only recognized fields\n7. **Signature Verification**: The signature can be cryptographically verified\n   - For RSA: Verify using the provided public key\n   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`\n   - For DID:JWS: Resolve DID and verify JWS signature\n\n## Multiple Signatures\n\nTo add multiple signatures to the same revision:\n\n```\nObject Revision\n    |\nSignature 1 (Alice signs object)\n    |\nSignature 2 (Bob signs Signature 1)\n    |\nSignature 3 (Carol signs Signature 2)\n```\n\nEach signature revision signs the previous revision, creating a chain of signatures.\n\n### Multi-Party Signing\n\nFor independent multi-party signing (all signing the same object):\n\n```\n        Object Revision\n      |        |            |\nSignature A  Signature B  Signature C\n         |    |    |\n        Link Revision\n```\n\nUse a Link Revision to combine multiple independent signature branches.\n\n## Common Use Cases\n\n### 1. Document Signing\nSign file object revisions to prove authorship:\n```\nFile Object =\u003e Signature (Author) =\u003e Witness (Timestamp)\n```\n\n### 2. Approval Workflows\nMultiple parties sign in sequence:\n```\nDocument =\u003e Sign (Creator) =\u003e Sign (Reviewer) =\u003e Sign (Approver)\n```\n\n### 3. Notarization\nProfessional notary signs an object:\n```\nObject =\u003e Signature (Notary's RSA key) =\u003e Witness (Blockchain)\n```\n\n### 4. Smart Contract Interaction\nEthereum wallet signs for on-chain verification:\n```\nClaim =\u003e Signature (EIP-191) =\u003e Submit to Smart Contract\n```\n\n### 5. Decentralized Identity\nDID-based signatures for verifiable credentials:\n```\nCredential =\u003e Signature (Issuer's DID) =\u003e Holder stores\n```\n\n## Implementation Notes\n\n### Creating a Signature Revision\n\n1. Identify the revision to sign\n2. Compute its hash (the `previous_revision` value)\n3. Prepare the message to sign (hash, with any required prefixes)\n4. Generate the signature using chosen method\n5. Construct the signature revision object\n6. Validate the signature can be verified\n7. Compute and store the signature revision hash\n\n### Verifying a Signature Revision\n\n#### RSA Verification\n```\n1. Extract public_key from signature object\n2. Extract signature bytes\n3. Reconstruct signed message (hash of previous_revision)\n4. Verify signature using RSA public key\n```\n\n#### EIP-191 Verification\n```\n1. Reconstruct EIP-191 message: \"\\x19Ethereum Signed Message:\\n32\" + hash\n2. Recover address from signature\n3. Compare recovered address to signature_wallet_address\n```\n\n#### DID:JWS Verification\n```\n1. Resolve DID to get DID document\n2. Extract verification method (public key)\n3. Verify JWS signature using verification method\n4. Validate JWS payload matches revision data\n```\n\n## Security Considerations\n\n### 1. Key Management\n- RSA: Protect private key files, use strong key sizes (e2048 bits)\n- EIP-191: Secure wallet seed phrases/private keys\n- DID: Maintain DID document security and key rotation policies\n\n### 2. Signature Reuse\n- Each signature should sign a unique revision\n- Nonces prevent replay attacks\n\n### 3. Timestamp Validation\n- Check `local_timestamp` is reasonable (not far future/past)\n- Compare with witness timestamps for consistency\n\n### 4. Address Validation\n- For EIP-191: Always validate EIP-55 checksum\n- Reject non-checksummed addresses\n\n### 5. DID Resolution\n- Ensure DID resolver is trustworthy\n- Cache DID documents appropriately\n- Handle resolution failures gracefully\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Typically what gets signed first\n- **Witness Revisions**: Often follow signatures to add timestamping\n- **Link Revisions**: Can combine multiple signature branches\n- **Template Revisions**: Can also be signed, though less common\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets signed\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamps after signing\n- [Link Revision](/schema_reference/link_revision) - Combine signature branches\n- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard\n- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers\n- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures\n"])</script><script>self.__next_f.push([1,"32:T2eb6,"])</script><script>self.__next_f.push([1,"\n# Signature Revision\n\nA Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.\n\n## Overview\n\nSignature revisions provide:\n- **Authentication**: Proof that a specific entity created or approved the previous revision\n- **Integrity**: Assurance that the signed revision hasn't been tampered with\n- **Non-repudiation**: The signer cannot deny having signed the revision\n- **Flexibility**: Support for multiple cryptographic signature schemes\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being signed |\n| `revision_type` | string | Yes | Always `\"signature\"` for signature revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `signature` | object | Yes | Signature value object (varies by signature type) |\n\n### Signature Value Object\n\nThe `signature` field is an object with different structures depending on the signature type.\n\n## Signature Types\n\n### 1. RSA Signature\n\nUses RSA public-key cryptography with PKCS#1 v1.5 padding.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"rsa\",\n  \"signature\": \"0x...\",\n  \"public_key\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"rsa\"` |\n| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |\n| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |\n\n#### Validation Rules\n- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)\n- Public key must be DER-encoded and between 200-600 bytes\n- Both fields must be lowercase hex strings prefixed with `0x`\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"rsa\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"public_key\": \"0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001\"\n  }\n}\n```\n\n---\n\n### 2. Ethereum (EIP-191) Signature\n\nUses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"ethereum:eip-191\",\n  \"signature\": \"0x...\",\n  \"signature_wallet_address\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"ethereum:eip-191\"` |\n| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |\n| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |\n\n#### Validation Rules\n- Signature must be exactly 65 bytes\n- Wallet address must be a valid EIP-55 checksummed address\n- Both fields must be hex strings prefixed with `0x`\n- Address checksum must be validated\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"ethereum:eip-191\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c\",\n    \"signature_wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).\n\n---\n\n### 3. DID JWS Signature\n\nUses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).\n\n#### Structure\n```json\n{\n  \"signature_type\": \"did:jws\",\n  \"jws\": \"eyJ...\",\n  \"did\": \"did:key:...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"did:jws\"` |\n| `jws` | string | Compact JWS (JSON Web Signature) |\n| `did` | string | Decentralized Identifier of the signer |\n\n#### Validation Rules\n- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)\n- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)\n- The DID document must be resolvable to verify the signature\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"did:jws\",\n    \"jws\": \"eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ\",\n    \"did\": \"did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\"\n  }\n}\n```\n\n---\n\n## What Gets Signed\n\nThe signature is computed over the **hash of the previous revision**, not the revision itself.\n\n### Signing Process\n\n1. Compute the hash of the `previous_revision`\n2. For Ethereum: Add EIP-191 prefix (`\\x19Ethereum Signed Message:\\n32`)\n3. Sign the hash using the appropriate method\n4. Create the signature revision with the signature value\n5. Compute the hash of the signature revision\n\n### Example Signing Flow\n\n```\nObject Revision =\u003e Compute Hash =\u003e Sign Hash =\u003e Signature Revision\n     |\n0x3f8a7b2c... (previous_revision in signature)\n```\n\n## Validation Rules\n\nA Signature Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"signature\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Signature Type**: One of `\"rsa\"`, `\"ethereum:eip-191\"`, or `\"did:jws\"`\n5. **Signature Format**: Matches the requirements for the specific signature type\n6. **No Unknown Fields**: The signature object contains only recognized fields\n7. **Signature Verification**: The signature can be cryptographically verified\n   - For RSA: Verify using the provided public key\n   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`\n   - For DID:JWS: Resolve DID and verify JWS signature\n\n## Multiple Signatures\n\nTo add multiple signatures to the same revision:\n\n```\nObject Revision\n    |\nSignature 1 (Alice signs object)\n    |\nSignature 2 (Bob signs Signature 1)\n    |\nSignature 3 (Carol signs Signature 2)\n```\n\nEach signature revision signs the previous revision, creating a chain of signatures.\n\n### Multi-Party Signing\n\nFor independent multi-party signing (all signing the same object):\n\n```\n        Object Revision\n      |        |            |\nSignature A  Signature B  Signature C\n         |    |    |\n        Link Revision\n```\n\nUse a Link Revision to combine multiple independent signature branches.\n\n## Common Use Cases\n\n### 1. Document Signing\nSign file object revisions to prove authorship:\n```\nFile Object =\u003e Signature (Author) =\u003e Witness (Timestamp)\n```\n\n### 2. Approval Workflows\nMultiple parties sign in sequence:\n```\nDocument =\u003e Sign (Creator) =\u003e Sign (Reviewer) =\u003e Sign (Approver)\n```\n\n### 3. Notarization\nProfessional notary signs an object:\n```\nObject =\u003e Signature (Notary's RSA key) =\u003e Witness (Blockchain)\n```\n\n### 4. Smart Contract Interaction\nEthereum wallet signs for on-chain verification:\n```\nClaim =\u003e Signature (EIP-191) =\u003e Submit to Smart Contract\n```\n\n### 5. Decentralized Identity\nDID-based signatures for verifiable credentials:\n```\nCredential =\u003e Signature (Issuer's DID) =\u003e Holder stores\n```\n\n## Implementation Notes\n\n### Creating a Signature Revision\n\n1. Identify the revision to sign\n2. Compute its hash (the `previous_revision` value)\n3. Prepare the message to sign (hash, with any required prefixes)\n4. Generate the signature using chosen method\n5. Construct the signature revision object\n6. Validate the signature can be verified\n7. Compute and store the signature revision hash\n\n### Verifying a Signature Revision\n\n#### RSA Verification\n```\n1. Extract public_key from signature object\n2. Extract signature bytes\n3. Reconstruct signed message (hash of previous_revision)\n4. Verify signature using RSA public key\n```\n\n#### EIP-191 Verification\n```\n1. Reconstruct EIP-191 message: \"\\x19Ethereum Signed Message:\\n32\" + hash\n2. Recover address from signature\n3. Compare recovered address to signature_wallet_address\n```\n\n#### DID:JWS Verification\n```\n1. Resolve DID to get DID document\n2. Extract verification method (public key)\n3. Verify JWS signature using verification method\n4. Validate JWS payload matches revision data\n```\n\n## Security Considerations\n\n### 1. Key Management\n- RSA: Protect private key files, use strong key sizes (e2048 bits)\n- EIP-191: Secure wallet seed phrases/private keys\n- DID: Maintain DID document security and key rotation policies\n\n### 2. Signature Reuse\n- Each signature should sign a unique revision\n- Nonces prevent replay attacks\n\n### 3. Timestamp Validation\n- Check `local_timestamp` is reasonable (not far future/past)\n- Compare with witness timestamps for consistency\n\n### 4. Address Validation\n- For EIP-191: Always validate EIP-55 checksum\n- Reject non-checksummed addresses\n\n### 5. DID Resolution\n- Ensure DID resolver is trustworthy\n- Cache DID documents appropriately\n- Handle resolution failures gracefully\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Typically what gets signed first\n- **Witness Revisions**: Often follow signatures to add timestamping\n- **Link Revisions**: Can combine multiple signature branches\n- **Template Revisions**: Can also be signed, though less common\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets signed\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamps after signing\n- [Link Revision](/schema_reference/link_revision) - Combine signature branches\n- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard\n- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers\n- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures\n"])</script><script>self.__next_f.push([1,"33:T2c8d,"])</script><script>self.__next_f.push([1,"\n# Template Revision\n\nA Template Revision defines the structure and validation rules for Object Revisions. Templates use JSON Schema to specify what data fields are required, their types, formats, and constraints. Template revisions are standalone (they don't have a `previous_revision` field) and are referenced by object revisions via their hash.\n\n## Overview\n\nTemplate revisions serve as the \"type system\" for Aqua Protocol. They:\n- Define schemas using JSON Schema (Draft 2020-12)\n- Are immutable once created (identified by their hash)\n- Can be reused by multiple object revisions\n- Optionally reference code implementations\n- Enable validation and type safety\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revision_type` | string | Yes | Always `\"template\"` for template revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the template was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` (typically `\"scalar\"`) |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `schema` | object | Yes | JSON Schema (Draft 2020-12) that validates object payloads |\n| `code_revision_ref` | string | No | Optional hash reference to code that implements this template |\n\n### Field Details\n\n#### revision_type\n- **Value**: Always `\"template\"`\n- **Purpose**: Identifies this as a template revision\n- **Note**: Unlike object revisions, this is a string constant, not a hash reference\n\n#### schema\n- **Format**: Valid JSON Schema (Draft 2020-12 specification)\n- **Purpose**: Defines validation rules for object revision payloads\n- **Required fields in schema**:\n  - `$schema`: Should be `\"https://json-schema.org/draft/2020-12/schema\"`\n  - `type`: Typically `\"object\"`\n  - `properties`: Defines the payload structure\n  - `required`: Lists mandatory fields\n  - `additionalProperties`: Usually `false` for strict validation\n\n#### code_revision_ref\n- **Format**: Hex string reference to another revision (optional)\n- **Purpose**: Links to executable code or scripts that work with this template\n- **Use case**: For templates that need associated processing logic\n- **Example**: Reference to smart contract code, validation scripts, or transformation functions\n\n## Examples\n\n### Example 1: File Template\n\nA template for storing file metadata:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x2ba6a8b9b987cf8c3567f72871812ae9\",\n  \"local_timestamp\": 1762266013,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"payload_type\": {\n        \"type\": \"string\",\n        \"maxLength\": 128\n      },\n      \"hash\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-f]{64,128}$\"\n      },\n      \"hash_type\": {\n        \"description\": \"Hash function identifier\",\n        \"anyOf\": [\n          {\n            \"type\": \"string\",\n            \"const\": \"FIPS_202-SHA3-256\"\n          },\n          {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 128\n          }\n        ]\n      },\n      \"descriptor\": {\n        \"type\": \"string\",\n        \"maxLength\": 140\n      }\n    },\n    \"required\": [\n      \"payload_type\",\n      \"hash\",\n      \"hash_type\",\n      \"descriptor\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n**Hash of this template**: `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e`\n\nThis hash is what object revisions use in their `revision_type` field to reference this template.\n\n### Example 2: Domain Claim Template\n\nA template for domain ownership claims:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x0da37dc1685f4d78a87c9462b0e87685\",\n  \"local_timestamp\": 1762817552,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"domain\": {\n        \"type\": \"string\",\n        \"format\": \"idn-hostname\"\n      },\n      \"wallet_address\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-fA-F]{40}$\"\n      }\n    },\n    \"required\": [\n      \"domain\",\n      \"wallet_address\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n### Example 3: Email Claim Template\n\nA template for email verification claims:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x5c8f9a1b2d3e4f5a6b7c8d9e0f1a2b3c\",\n  \"local_timestamp\": 1762820000,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"email\": {\n        \"type\": \"string\",\n        \"format\": \"email\"\n      },\n      \"wallet_address\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-fA-F]{40}$\"\n      },\n      \"verified_at\": {\n        \"type\": \"integer\",\n        \"description\": \"Unix timestamp of verification\"\n      }\n    },\n    \"required\": [\n      \"email\",\n      \"wallet_address\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n### Example 4: Template with Code Reference\n\nA template that references associated code:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"local_timestamp\": 1762825000,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"calculation_type\": {\n        \"type\": \"string\",\n        \"enum\": [\"sum\", \"average\", \"weighted\"]\n      },\n      \"values\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"number\"\n        }\n      }\n    },\n    \"required\": [\"calculation_type\", \"values\"],\n    \"additionalProperties\": false\n  },\n  \"code_revision_ref\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\"\n}\n```\n\n## Built-in Templates\n\nThe Aqua RS SDK provides several built-in templates with pre-computed hashes:\n\n| Template | Purpose | Hash Reference |\n|----------|---------|----------------|\n| File | File metadata storage | `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e` |\n| Domain | Domain ownership claims | (computed at runtime) |\n| Email | Email verification | (computed at runtime) |\n| Name | Name claims | (computed at runtime) |\n| Phone | Phone verification | (computed at runtime) |\n| Attestation | General attestations | (computed at runtime) |\n\nThese templates are defined in the SDK at `src/schema/templates/` and can be used directly without creating new template revisions.\n\n## JSON Schema Features\n\nTemplate schemas support all JSON Schema Draft 2020-12 features:\n\n### Type Validation\n```json\n{\n  \"type\": \"string\"  // or \"number\", \"integer\", \"boolean\", \"array\", \"object\", \"null\"\n}\n```\n\n### Format Validation\n```json\n{\n  \"type\": \"string\",\n  \"format\": \"email\"  // or \"date\", \"date-time\", \"uri\", \"hostname\", etc.\n}\n```\n\n### Pattern Matching\n```json\n{\n  \"type\": \"string\",\n  \"pattern\": \"^0x[0-9a-f]{40}$\"\n}\n```\n\n### Length Constraints\n```json\n{\n  \"type\": \"string\",\n  \"minLength\": 1,\n  \"maxLength\": 100\n}\n```\n\n### Numeric Constraints\n```json\n{\n  \"type\": \"number\",\n  \"minimum\": 0,\n  \"maximum\": 100,\n  \"multipleOf\": 0.01\n}\n```\n\n### Array Constraints\n```json\n{\n  \"type\": \"array\",\n  \"items\": { \"type\": \"string\" },\n  \"minItems\": 1,\n  \"maxItems\": 10,\n  \"uniqueItems\": true\n}\n```\n\n### Enumerations\n```json\n{\n  \"type\": \"string\",\n  \"enum\": [\"option1\", \"option2\", \"option3\"]\n}\n```\n\n### Conditional Schemas\n```json\n{\n  \"anyOf\": [\n    { \"type\": \"string\", \"const\": \"FIPS_202-SHA3-256\" },\n    { \"type\": \"string\", \"minLength\": 1 }\n  ]\n}\n```\n\n## Validation Rules\n\nA Template Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` field is exactly `\"template\"`\n3. **Version**: Matches `\"https://aqua-protocol.org/docs/v4/schema\"`\n4. **Schema**: Is a valid JSON Schema (Draft 2020-12)\n5. **Schema Root**: The schema should define an object type at the root level\n6. **No Previous Revision**: Templates never have a `previous_revision` field\n7. **Code Reference**: If present, `code_revision_ref` must be a valid hash reference\n8. **Hash Verification**: The computed hash can be verified\n\n## Template Lifecycle\n\n### 1. Creation\n```\nCreate JSON Schema ÔøΩ Generate Template Revision ÔøΩ Compute Hash\n```\n\n### 2. Publication\n```\nTemplate Hash ÔøΩ Used by Object Revisions ÔøΩ Enables Validation\n```\n\n### 3. Reuse\n```\nMultiple Objects ÔøΩ Reference Same Template ÔøΩ Consistent Validation\n```\n\n## Best Practices\n\n### 1. Use Descriptive Property Names\n```json\n{\n  \"properties\": {\n    \"email_address\": { \"type\": \"string\", \"format\": \"email\" },\n    \"verified_at_timestamp\": { \"type\": \"integer\" }\n  }\n}\n```\n\n### 2. Always Set additionalProperties\n```json\n{\n  \"additionalProperties\": false  // Strict validation\n}\n```\n\n### 3. Include Descriptions\n```json\n{\n  \"properties\": {\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Current verification status: pending, verified, or rejected\"\n    }\n  }\n}\n```\n\n### 4. Use Appropriate Constraints\n```json\n{\n  \"email\": {\n    \"type\": \"string\",\n    \"format\": \"email\",\n    \"maxLength\": 254  // RFC 5321 limit\n  }\n}\n```\n\n### 5. Plan for Forward Compatibility\n- Avoid overly restrictive patterns\n- Use `anyOf` for accepting multiple formats\n- Consider optional fields for future extensions\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Reference templates via their `revision_type` field\n- **Code Revisions**: Can be referenced via `code_revision_ref` (optional)\n- **No Chaining**: Templates don't form chains; they're standalone definitions\n\n## Implementation Notes\n\n### Creating a Template\n\n1. Design your JSON Schema based on your data requirements\n2. Validate the schema itself is valid JSON Schema\n3. Create the template revision structure\n4. Generate a random nonce\n5. Compute the template hash\n6. Store the hash for use in object revisions\n\n### Using a Template\n\n1. Reference the template hash in the object's `revision_type`\n2. Ensure payload conforms to the template schema\n3. Validate payload against schema before creating object revision\n\n### Template Validation\n\nWhen validating an object against a template:\n\n```\n1. Retrieve template by hash\n2. Extract JSON Schema from template\n3. Validate object payload against schema\n4. Check validation result\n```\n\n## Common Use Cases\n\n### Document Templates\nDefine structure for document metadata, file hashes, and descriptors.\n\n### Credential Templates\nSpecify required fields for verifiable credentials (email, domain, phone, etc.).\n\n### Data Exchange Templates\nStandardize data formats for interoperability between systems.\n\n### Smart Contract Templates\nLink templates to on-chain contract code for decentralized validation.\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - Use templates to validate objects\n- [JSON Schema Specification](https://json-schema.org/draft/2020-12/json-schema-core.html) - Full JSON Schema documentation\n"])</script><script>self.__next_f.push([1,"34:T2c8d,"])</script><script>self.__next_f.push([1,"\n# Template Revision\n\nA Template Revision defines the structure and validation rules for Object Revisions. Templates use JSON Schema to specify what data fields are required, their types, formats, and constraints. Template revisions are standalone (they don't have a `previous_revision` field) and are referenced by object revisions via their hash.\n\n## Overview\n\nTemplate revisions serve as the \"type system\" for Aqua Protocol. They:\n- Define schemas using JSON Schema (Draft 2020-12)\n- Are immutable once created (identified by their hash)\n- Can be reused by multiple object revisions\n- Optionally reference code implementations\n- Enable validation and type safety\n\n## Schema Structure\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `revision_type` | string | Yes | Always `\"template\"` for template revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the template was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` or `\"tree\"` (typically `\"scalar\"`) |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `schema` | object | Yes | JSON Schema (Draft 2020-12) that validates object payloads |\n| `code_revision_ref` | string | No | Optional hash reference to code that implements this template |\n\n### Field Details\n\n#### revision_type\n- **Value**: Always `\"template\"`\n- **Purpose**: Identifies this as a template revision\n- **Note**: Unlike object revisions, this is a string constant, not a hash reference\n\n#### schema\n- **Format**: Valid JSON Schema (Draft 2020-12 specification)\n- **Purpose**: Defines validation rules for object revision payloads\n- **Required fields in schema**:\n  - `$schema`: Should be `\"https://json-schema.org/draft/2020-12/schema\"`\n  - `type`: Typically `\"object\"`\n  - `properties`: Defines the payload structure\n  - `required`: Lists mandatory fields\n  - `additionalProperties`: Usually `false` for strict validation\n\n#### code_revision_ref\n- **Format**: Hex string reference to another revision (optional)\n- **Purpose**: Links to executable code or scripts that work with this template\n- **Use case**: For templates that need associated processing logic\n- **Example**: Reference to smart contract code, validation scripts, or transformation functions\n\n## Examples\n\n### Example 1: File Template\n\nA template for storing file metadata:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x2ba6a8b9b987cf8c3567f72871812ae9\",\n  \"local_timestamp\": 1762266013,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"payload_type\": {\n        \"type\": \"string\",\n        \"maxLength\": 128\n      },\n      \"hash\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-f]{64,128}$\"\n      },\n      \"hash_type\": {\n        \"description\": \"Hash function identifier\",\n        \"anyOf\": [\n          {\n            \"type\": \"string\",\n            \"const\": \"FIPS_202-SHA3-256\"\n          },\n          {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 128\n          }\n        ]\n      },\n      \"descriptor\": {\n        \"type\": \"string\",\n        \"maxLength\": 140\n      }\n    },\n    \"required\": [\n      \"payload_type\",\n      \"hash\",\n      \"hash_type\",\n      \"descriptor\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n**Hash of this template**: `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e`\n\nThis hash is what object revisions use in their `revision_type` field to reference this template.\n\n### Example 2: Domain Claim Template\n\nA template for domain ownership claims:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x0da37dc1685f4d78a87c9462b0e87685\",\n  \"local_timestamp\": 1762817552,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"domain\": {\n        \"type\": \"string\",\n        \"format\": \"idn-hostname\"\n      },\n      \"wallet_address\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-fA-F]{40}$\"\n      }\n    },\n    \"required\": [\n      \"domain\",\n      \"wallet_address\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n### Example 3: Email Claim Template\n\nA template for email verification claims:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x5c8f9a1b2d3e4f5a6b7c8d9e0f1a2b3c\",\n  \"local_timestamp\": 1762820000,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"email\": {\n        \"type\": \"string\",\n        \"format\": \"email\"\n      },\n      \"wallet_address\": {\n        \"type\": \"string\",\n        \"pattern\": \"^0x[0-9a-fA-F]{40}$\"\n      },\n      \"verified_at\": {\n        \"type\": \"integer\",\n        \"description\": \"Unix timestamp of verification\"\n      }\n    },\n    \"required\": [\n      \"email\",\n      \"wallet_address\"\n    ],\n    \"additionalProperties\": false\n  }\n}\n```\n\n### Example 4: Template with Code Reference\n\nA template that references associated code:\n\n```json\n{\n  \"revision_type\": \"template\",\n  \"nonce\": \"0x7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"local_timestamp\": 1762825000,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"schema\": {\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"calculation_type\": {\n        \"type\": \"string\",\n        \"enum\": [\"sum\", \"average\", \"weighted\"]\n      },\n      \"values\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"number\"\n        }\n      }\n    },\n    \"required\": [\"calculation_type\", \"values\"],\n    \"additionalProperties\": false\n  },\n  \"code_revision_ref\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\"\n}\n```\n\n## Built-in Templates\n\nThe Aqua RS SDK provides several built-in templates with pre-computed hashes:\n\n| Template | Purpose | Hash Reference |\n|----------|---------|----------------|\n| File | File metadata storage | `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e` |\n| Domain | Domain ownership claims | (computed at runtime) |\n| Email | Email verification | (computed at runtime) |\n| Name | Name claims | (computed at runtime) |\n| Phone | Phone verification | (computed at runtime) |\n| Attestation | General attestations | (computed at runtime) |\n\nThese templates are defined in the SDK at `src/schema/templates/` and can be used directly without creating new template revisions.\n\n## JSON Schema Features\n\nTemplate schemas support all JSON Schema Draft 2020-12 features:\n\n### Type Validation\n```json\n{\n  \"type\": \"string\"  // or \"number\", \"integer\", \"boolean\", \"array\", \"object\", \"null\"\n}\n```\n\n### Format Validation\n```json\n{\n  \"type\": \"string\",\n  \"format\": \"email\"  // or \"date\", \"date-time\", \"uri\", \"hostname\", etc.\n}\n```\n\n### Pattern Matching\n```json\n{\n  \"type\": \"string\",\n  \"pattern\": \"^0x[0-9a-f]{40}$\"\n}\n```\n\n### Length Constraints\n```json\n{\n  \"type\": \"string\",\n  \"minLength\": 1,\n  \"maxLength\": 100\n}\n```\n\n### Numeric Constraints\n```json\n{\n  \"type\": \"number\",\n  \"minimum\": 0,\n  \"maximum\": 100,\n  \"multipleOf\": 0.01\n}\n```\n\n### Array Constraints\n```json\n{\n  \"type\": \"array\",\n  \"items\": { \"type\": \"string\" },\n  \"minItems\": 1,\n  \"maxItems\": 10,\n  \"uniqueItems\": true\n}\n```\n\n### Enumerations\n```json\n{\n  \"type\": \"string\",\n  \"enum\": [\"option1\", \"option2\", \"option3\"]\n}\n```\n\n### Conditional Schemas\n```json\n{\n  \"anyOf\": [\n    { \"type\": \"string\", \"const\": \"FIPS_202-SHA3-256\" },\n    { \"type\": \"string\", \"minLength\": 1 }\n  ]\n}\n```\n\n## Validation Rules\n\nA Template Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` field is exactly `\"template\"`\n3. **Version**: Matches `\"https://aqua-protocol.org/docs/v4/schema\"`\n4. **Schema**: Is a valid JSON Schema (Draft 2020-12)\n5. **Schema Root**: The schema should define an object type at the root level\n6. **No Previous Revision**: Templates never have a `previous_revision` field\n7. **Code Reference**: If present, `code_revision_ref` must be a valid hash reference\n8. **Hash Verification**: The computed hash can be verified\n\n## Template Lifecycle\n\n### 1. Creation\n```\nCreate JSON Schema ÔøΩ Generate Template Revision ÔøΩ Compute Hash\n```\n\n### 2. Publication\n```\nTemplate Hash ÔøΩ Used by Object Revisions ÔøΩ Enables Validation\n```\n\n### 3. Reuse\n```\nMultiple Objects ÔøΩ Reference Same Template ÔøΩ Consistent Validation\n```\n\n## Best Practices\n\n### 1. Use Descriptive Property Names\n```json\n{\n  \"properties\": {\n    \"email_address\": { \"type\": \"string\", \"format\": \"email\" },\n    \"verified_at_timestamp\": { \"type\": \"integer\" }\n  }\n}\n```\n\n### 2. Always Set additionalProperties\n```json\n{\n  \"additionalProperties\": false  // Strict validation\n}\n```\n\n### 3. Include Descriptions\n```json\n{\n  \"properties\": {\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Current verification status: pending, verified, or rejected\"\n    }\n  }\n}\n```\n\n### 4. Use Appropriate Constraints\n```json\n{\n  \"email\": {\n    \"type\": \"string\",\n    \"format\": \"email\",\n    \"maxLength\": 254  // RFC 5321 limit\n  }\n}\n```\n\n### 5. Plan for Forward Compatibility\n- Avoid overly restrictive patterns\n- Use `anyOf` for accepting multiple formats\n- Consider optional fields for future extensions\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Reference templates via their `revision_type` field\n- **Code Revisions**: Can be referenced via `code_revision_ref` (optional)\n- **No Chaining**: Templates don't form chains; they're standalone definitions\n\n## Implementation Notes\n\n### Creating a Template\n\n1. Design your JSON Schema based on your data requirements\n2. Validate the schema itself is valid JSON Schema\n3. Create the template revision structure\n4. Generate a random nonce\n5. Compute the template hash\n6. Store the hash for use in object revisions\n\n### Using a Template\n\n1. Reference the template hash in the object's `revision_type`\n2. Ensure payload conforms to the template schema\n3. Validate payload against schema before creating object revision\n\n### Template Validation\n\nWhen validating an object against a template:\n\n```\n1. Retrieve template by hash\n2. Extract JSON Schema from template\n3. Validate object payload against schema\n4. Check validation result\n```\n\n## Common Use Cases\n\n### Document Templates\nDefine structure for document metadata, file hashes, and descriptors.\n\n### Credential Templates\nSpecify required fields for verifiable credentials (email, domain, phone, etc.).\n\n### Data Exchange Templates\nStandardize data formats for interoperability between systems.\n\n### Smart Contract Templates\nLink templates to on-chain contract code for decentralized validation.\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - Use templates to validate objects\n- [JSON Schema Specification](https://json-schema.org/draft/2020-12/json-schema-core.html) - Full JSON Schema documentation\n"])</script><script>self.__next_f.push([1,"35:T334e,"])</script><script>self.__next_f.push([1,"\n# Witness Revision\n\nA Witness Revision provides cryptographic proof that a revision existed at a specific point in time. It anchors revision hashes to external systems like blockchains (Ethereum), decentralized networks (Nostr), or Trusted Timestamping Authorities (TSA). This creates an immutable, verifiable timestamp that cannot be backdated.\n\n## Overview\n\nWitness revisions provide:\n- **Timestamping**: Cryptographic proof of when a revision existed\n- **Immutability**: Blockchain or TSA anchoring prevents backdating\n- **Verifiability**: Anyone can verify the witness independently\n- **Batch Efficiency**: Multiple revisions can be witnessed in a single transaction via Merkle trees\n- **Decentralization**: Uses public blockchains or decentralized networks\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being witnessed |\n| `revision_type` | string | Yes | Always `\"witness\"` for witness revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the witness was created locally |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `witness` | object | Yes | Witness value object containing proof details |\n\n### Witness Value Object\n\nThe `witness` field contains details about the witnessing transaction:\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `merkle_proof` | array | Yes | Array of hex strings forming the Merkle proof path |\n| `sender_account_address` | string | Yes | Address that submitted the witness transaction |\n| `transaction_hash` | string | Yes | Transaction hash on the blockchain or network |\n| `smart_contract_address` | string | Yes | Address of the witness contract (or endpoint URL) |\n| `network` | string | Yes | Network identifier: `\"mainnet\"`, `\"sepolia\"`, `\"holesky\"`, `\"tsa\"`, or `\"nostr\"` |\n| `merkle_root` | string | Yes | Root hash of the Merkle tree stored on-chain |\n| `timestamp` | number | Yes | Unix timestamp from the blockchain/network |\n\n## Network Types\n\n### 1. Ethereum Networks\n\n#### Mainnet\n- **Network**: `\"mainnet\"`\n- **Purpose**: Production witnessing on Ethereum mainnet\n- **Cost**: Higher gas fees\n- **Security**: Maximum security and permanence\n\n#### Sepolia (Testnet)\n- **Network**: `\"sepolia\"`\n- **Purpose**: Testing and development\n- **Cost**: Free testnet ETH\n- **Security**: Testnet only, subject to resets\n\n#### Holesky (Testnet)\n- **Network**: `\"holesky\"`\n- **Purpose**: Testing and development\n- **Cost**: Free testnet ETH\n- **Security**: Testnet only, newer Ethereum testnet\n\n### 2. Trusted Timestamping Authority (TSA)\n\n- **Network**: `\"tsa\"`\n- **Purpose**: RFC 3161 compliant timestamping\n- **Provider**: DigiCert or other TSA services\n- **Verification**: Via TSA public certificates\n\n### 3. Nostr\n\n- **Network**: `\"nostr\"`\n- **Purpose**: Decentralized social network timestamping\n- **Verification**: Via Nostr relays and events\n- **Cost**: Typically free\n\n## Example\n\n### Ethereum Witness (Sepolia)\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"witness\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"witness\": {\n    \"merkle_proof\": [\n      \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n      \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\",\n      \"0x567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234\"\n    ],\n    \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n    \"transaction_hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n    \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n    \"network\": \"sepolia\",\n    \"merkle_root\": \"0xa3bf4f1b2b0b822cd15d6c15b0f00a089f86d081884c7d659a2feaa0c55ad015\",\n    \"timestamp\": 1704067250\n  }\n}\n```\n\n### Single Revision Witness\n\nWhen witnessing a single revision (no batching), the Merkle proof is empty:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"witness\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"witness\": {\n    \"merkle_proof\": [],\n    \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n    \"transaction_hash\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n    \"network\": \"mainnet\",\n    \"merkle_root\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n    \"timestamp\": 1704070850\n  }\n}\n```\n\n**Note**: When `merkle_proof` is empty, `merkle_root` equals `previous_revision`.\n\n## Merkle Tree Batching\n\nTo reduce costs, multiple revisions can be witnessed in a single transaction using Merkle trees.\n\n### Process\n\n1. **Collect Revisions**: Gather multiple revision hashes to witness\n2. **Build Merkle Tree**: Create a Merkle tree from the revision hashes\n3. **Submit Root**: Submit only the Merkle root to the blockchain\n4. **Generate Proofs**: For each revision, generate its Merkle proof\n5. **Create Witnesses**: Create witness revisions with proofs\n\n### Example: Witnessing 4 Revisions\n\n```\nRevision Hashes:\n- Rev1: 0xaaaa...\n- Rev2: 0xbbbb...\n- Rev3: 0xcccc...\n- Rev4: 0xdddd...\n\nMerkle Tree:\n           Root\n          /    \\\n       H12      H34\n      /  \\     /  \\\n    Rev1 Rev2 Rev3 Rev4\n\nSubmit to blockchain: Root hash only\n\nWitness for Rev1:\n  merkle_proof: [H12's sibling (Rev2), H12's parent's sibling (H34)]\n  merkle_root: Root\n```\n\n### Proof Verification\n\nTo verify a revision was witnessed:\n\n1. Start with revision hash\n2. Apply Merkle proof hashes (sibling hashes)\n3. Compute up the tree to get root\n4. Verify computed root matches `merkle_root`\n5. Verify `merkle_root` is on blockchain at `transaction_hash`\n\n## Validation Rules\n\nA Witness Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"witness\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Network**: One of the supported network values\n5. **Timestamp Consistency**:\n   - `witness.timestamp` should be close to `local_timestamp`\n   - Both should be reasonable (not far in future)\n6. **Merkle Proof**: If present, must be valid array of hex strings\n7. **Transaction Verification**: The `transaction_hash` exists on the specified `network`\n8. **Merkle Root Verification**: If batched, Merkle proof must lead to merkle_root\n9. **On-Chain Verification**: The `merkle_root` is stored at the `smart_contract_address` in the transaction\n10. **Address Format**: All addresses must be valid hex strings\n\n## Witness Smart Contract\n\n### Ethereum Contract Interface\n\nThe witness contract typically has a method like:\n\n```solidity\nfunction witness(bytes32 merkleRoot) public returns (bool)\n```\n\n### Verification Process\n\n1. Query blockchain for transaction at `transaction_hash`\n2. Verify transaction called the `smart_contract_address`\n3. Extract the witnessed value (merkle_root) from transaction data\n4. Verify it matches the `merkle_root` in the witness revision\n5. Check transaction timestamp matches `timestamp` field\n\n## Common Use Cases\n\n### 1. Document Notarization\n\n```\nDocument Object ‚Üí Signature ‚Üí Witness (Ethereum)\n```\n\nProves the document existed and was signed at a specific time.\n\n### 2. Batch Processing\n\n```\n100 Documents ‚Üí Compute Hashes ‚Üí Build Merkle Tree ‚Üí Single Witness Transaction\n```\n\nEconomical witnessing of many documents at once.\n\n### 3. Legal Evidence\n\n```\nEvidence Object ‚Üí Signature (Parties) ‚Üí Witness (Mainnet)\n```\n\nCreates tamper-proof timestamp for legal proceedings.\n\n### 4. Supply Chain\n\n```\nShipment Event ‚Üí Witness (Every checkpoint) ‚Üí Audit Trail\n```\n\nImmutable record of supply chain events.\n\n### 5. Credential Issuance\n\n```\nVC Issuance ‚Üí Signature (Issuer) ‚Üí Witness (Public verification)\n```\n\nPublicly verifiable credential issuance timestamps.\n\n## Timestamp Interpretation\n\n### local_timestamp\n- Created by client when preparing witness revision\n- Not trusted (can be manipulated)\n- Used for user display and rough ordering\n\n### witness.timestamp\n- Provided by blockchain/TSA\n- Trusted (immutable on-chain)\n- Authoritative time proof\n- Should be used for verification and legal purposes\n\n**Best Practice**: Always use `witness.timestamp` for critical timestamp verification.\n\n## Cost Considerations\n\n### Ethereum\n\n| Network | Cost | When to Use |\n|---------|------|-------------|\n| Mainnet | ~$5-50 per transaction | Production, legal, high-value |\n| Sepolia | Free (testnet) | Development, testing |\n| Holesky | Free (testnet) | Development, testing |\n\n**Gas Optimization**: Batch multiple witnesses into one transaction using Merkle trees.\n\n### TSA\n- Typically $0.10-1.00 per timestamp\n- Good for compliance requirements\n- RFC 3161 standard\n\n### Nostr\n- Free (decentralized network)\n- Lower trust than blockchain\n- Good for social proof\n\n## Implementation Notes\n\n### Creating a Witness Revision\n\n1. Identify the revision(s) to witness\n2. Choose network (mainnet, sepolia, etc.)\n3. If batching, build Merkle tree\n4. Submit transaction to blockchain\n5. Wait for transaction confirmation\n6. Extract transaction details\n7. Generate Merkle proofs (if batched)\n8. Create witness revision(s)\n\n### Verifying a Witness Revision\n\n#### Single Revision (No Batching)\n```\n1. Verify merkle_proof is empty\n2. Verify merkle_root equals previous_revision\n3. Query blockchain for transaction_hash\n4. Verify transaction exists and is confirmed\n5. Extract witnessed value from transaction\n6. Verify it matches merkle_root\n7. Check transaction timestamp\n```\n\n#### Batched Revision\n```\n1. Verify merkle_proof is non-empty\n2. Compute Merkle root using proof and previous_revision\n3. Verify computed root matches merkle_root\n4. Query blockchain for transaction_hash\n5. Verify merkle_root is stored on-chain\n6. Validate transaction timestamp\n```\n\n### Error Handling\n\nCommon issues and solutions:\n\n| Issue | Solution |\n|-------|----------|\n| Transaction not found | Wait longer (may not be confirmed yet) |\n| Wrong network | Check transaction on correct network |\n| Merkle proof invalid | Regenerate proof from original tree |\n| Timestamp mismatch | Check blockchain time vs local time |\n| Gas estimation failed | Check wallet balance and gas price |\n\n## Security Considerations\n\n### 1. Network Selection\n- Use mainnet for production/legal purposes\n- Use testnets only for development\n- Consider compliance requirements\n\n### 2. Confirmation Depth\n- Wait for sufficient confirmations (6+ for mainnet)\n- More confirmations = higher security\n- Balance security vs speed requirements\n\n### 3. Merkle Proof Storage\n- Store proofs securely\n- Without proof, batched witness can't be verified\n- Consider proof backup strategies\n\n### 4. Timestamp Trust\n- Trust blockchain timestamp over local_timestamp\n- Account for block time variability\n- Consider block reorganizations\n\n### 5. Cost Management\n- Batch witnesses to reduce costs\n- Monitor gas prices\n- Use appropriate network for use case\n\n## Advanced Topics\n\n### Multi-Network Witnessing\n\nWitness the same revision on multiple networks for redundancy:\n\n```\nObject ‚Üí Signature ‚Üí Witness (Ethereum) ‚Üí Witness (Nostr) ‚Üí Witness (TSA)\n```\n\nEach witness provides independent proof.\n\n### Periodic Re-Witnessing\n\nFor long-term preservation, periodically re-witness important revisions:\n\n```\n2024: Object ‚Üí Witness (Mainnet)\n2025: Link to Object ‚Üí Witness (Mainnet)\n2026: Link to 2025 ‚Üí Witness (Mainnet)\n```\n\n### Cross-Chain Verification\n\nWitness on multiple blockchains for increased trust:\n\n```\nObject ‚Üí Witness (Ethereum Mainnet) ‚Üí Witness (Polygon) ‚Üí Witness (Arbitrum)\n```\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Primary target for witnessing\n- **Signature Revisions**: Often witnessed after signing\n- **Link Revisions**: Can be witnessed to prove connection timestamp\n- **Template Revisions**: Rarely witnessed (they're standalone)\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets witnessed\n- [Signature Revision](/schema_reference/signing_revision) - Often combined with witnessing\n- [RFC 3161 - Timestamping](https://www.rfc-editor.org/rfc/rfc3161) - TSA standard\n- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/) - On-chain witnessing\n- [Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) - Batch witnessing structure\n"])</script><script>self.__next_f.push([1,"36:T334e,"])</script><script>self.__next_f.push([1,"\n# Witness Revision\n\nA Witness Revision provides cryptographic proof that a revision existed at a specific point in time. It anchors revision hashes to external systems like blockchains (Ethereum), decentralized networks (Nostr), or Trusted Timestamping Authorities (TSA). This creates an immutable, verifiable timestamp that cannot be backdated.\n\n## Overview\n\nWitness revisions provide:\n- **Timestamping**: Cryptographic proof of when a revision existed\n- **Immutability**: Blockchain or TSA anchoring prevents backdating\n- **Verifiability**: Anyone can verify the witness independently\n- **Batch Efficiency**: Multiple revisions can be witnessed in a single transaction via Merkle trees\n- **Decentralization**: Uses public blockchains or decentralized networks\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being witnessed |\n| `revision_type` | string | Yes | Always `\"witness\"` for witness revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the witness was created locally |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `witness` | object | Yes | Witness value object containing proof details |\n\n### Witness Value Object\n\nThe `witness` field contains details about the witnessing transaction:\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `merkle_proof` | array | Yes | Array of hex strings forming the Merkle proof path |\n| `sender_account_address` | string | Yes | Address that submitted the witness transaction |\n| `transaction_hash` | string | Yes | Transaction hash on the blockchain or network |\n| `smart_contract_address` | string | Yes | Address of the witness contract (or endpoint URL) |\n| `network` | string | Yes | Network identifier: `\"mainnet\"`, `\"sepolia\"`, `\"holesky\"`, `\"tsa\"`, or `\"nostr\"` |\n| `merkle_root` | string | Yes | Root hash of the Merkle tree stored on-chain |\n| `timestamp` | number | Yes | Unix timestamp from the blockchain/network |\n\n## Network Types\n\n### 1. Ethereum Networks\n\n#### Mainnet\n- **Network**: `\"mainnet\"`\n- **Purpose**: Production witnessing on Ethereum mainnet\n- **Cost**: Higher gas fees\n- **Security**: Maximum security and permanence\n\n#### Sepolia (Testnet)\n- **Network**: `\"sepolia\"`\n- **Purpose**: Testing and development\n- **Cost**: Free testnet ETH\n- **Security**: Testnet only, subject to resets\n\n#### Holesky (Testnet)\n- **Network**: `\"holesky\"`\n- **Purpose**: Testing and development\n- **Cost**: Free testnet ETH\n- **Security**: Testnet only, newer Ethereum testnet\n\n### 2. Trusted Timestamping Authority (TSA)\n\n- **Network**: `\"tsa\"`\n- **Purpose**: RFC 3161 compliant timestamping\n- **Provider**: DigiCert or other TSA services\n- **Verification**: Via TSA public certificates\n\n### 3. Nostr\n\n- **Network**: `\"nostr\"`\n- **Purpose**: Decentralized social network timestamping\n- **Verification**: Via Nostr relays and events\n- **Cost**: Typically free\n\n## Example\n\n### Ethereum Witness (Sepolia)\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"witness\",\n  \"nonce\": \"0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"witness\": {\n    \"merkle_proof\": [\n      \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n      \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\",\n      \"0x567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234\"\n    ],\n    \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n    \"transaction_hash\": \"0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\",\n    \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n    \"network\": \"sepolia\",\n    \"merkle_root\": \"0xa3bf4f1b2b0b822cd15d6c15b0f00a089f86d081884c7d659a2feaa0c55ad015\",\n    \"timestamp\": 1704067250\n  }\n}\n```\n\n### Single Revision Witness\n\nWhen witnessing a single revision (no batching), the Merkle proof is empty:\n\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"witness\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"witness\": {\n    \"merkle_proof\": [],\n    \"sender_account_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\",\n    \"transaction_hash\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"smart_contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n    \"network\": \"mainnet\",\n    \"merkle_root\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n    \"timestamp\": 1704070850\n  }\n}\n```\n\n**Note**: When `merkle_proof` is empty, `merkle_root` equals `previous_revision`.\n\n## Merkle Tree Batching\n\nTo reduce costs, multiple revisions can be witnessed in a single transaction using Merkle trees.\n\n### Process\n\n1. **Collect Revisions**: Gather multiple revision hashes to witness\n2. **Build Merkle Tree**: Create a Merkle tree from the revision hashes\n3. **Submit Root**: Submit only the Merkle root to the blockchain\n4. **Generate Proofs**: For each revision, generate its Merkle proof\n5. **Create Witnesses**: Create witness revisions with proofs\n\n### Example: Witnessing 4 Revisions\n\n```\nRevision Hashes:\n- Rev1: 0xaaaa...\n- Rev2: 0xbbbb...\n- Rev3: 0xcccc...\n- Rev4: 0xdddd...\n\nMerkle Tree:\n           Root\n          /    \\\n       H12      H34\n      /  \\     /  \\\n    Rev1 Rev2 Rev3 Rev4\n\nSubmit to blockchain: Root hash only\n\nWitness for Rev1:\n  merkle_proof: [H12's sibling (Rev2), H12's parent's sibling (H34)]\n  merkle_root: Root\n```\n\n### Proof Verification\n\nTo verify a revision was witnessed:\n\n1. Start with revision hash\n2. Apply Merkle proof hashes (sibling hashes)\n3. Compute up the tree to get root\n4. Verify computed root matches `merkle_root`\n5. Verify `merkle_root` is on blockchain at `transaction_hash`\n\n## Validation Rules\n\nA Witness Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"witness\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Network**: One of the supported network values\n5. **Timestamp Consistency**:\n   - `witness.timestamp` should be close to `local_timestamp`\n   - Both should be reasonable (not far in future)\n6. **Merkle Proof**: If present, must be valid array of hex strings\n7. **Transaction Verification**: The `transaction_hash` exists on the specified `network`\n8. **Merkle Root Verification**: If batched, Merkle proof must lead to merkle_root\n9. **On-Chain Verification**: The `merkle_root` is stored at the `smart_contract_address` in the transaction\n10. **Address Format**: All addresses must be valid hex strings\n\n## Witness Smart Contract\n\n### Ethereum Contract Interface\n\nThe witness contract typically has a method like:\n\n```solidity\nfunction witness(bytes32 merkleRoot) public returns (bool)\n```\n\n### Verification Process\n\n1. Query blockchain for transaction at `transaction_hash`\n2. Verify transaction called the `smart_contract_address`\n3. Extract the witnessed value (merkle_root) from transaction data\n4. Verify it matches the `merkle_root` in the witness revision\n5. Check transaction timestamp matches `timestamp` field\n\n## Common Use Cases\n\n### 1. Document Notarization\n\n```\nDocument Object ‚Üí Signature ‚Üí Witness (Ethereum)\n```\n\nProves the document existed and was signed at a specific time.\n\n### 2. Batch Processing\n\n```\n100 Documents ‚Üí Compute Hashes ‚Üí Build Merkle Tree ‚Üí Single Witness Transaction\n```\n\nEconomical witnessing of many documents at once.\n\n### 3. Legal Evidence\n\n```\nEvidence Object ‚Üí Signature (Parties) ‚Üí Witness (Mainnet)\n```\n\nCreates tamper-proof timestamp for legal proceedings.\n\n### 4. Supply Chain\n\n```\nShipment Event ‚Üí Witness (Every checkpoint) ‚Üí Audit Trail\n```\n\nImmutable record of supply chain events.\n\n### 5. Credential Issuance\n\n```\nVC Issuance ‚Üí Signature (Issuer) ‚Üí Witness (Public verification)\n```\n\nPublicly verifiable credential issuance timestamps.\n\n## Timestamp Interpretation\n\n### local_timestamp\n- Created by client when preparing witness revision\n- Not trusted (can be manipulated)\n- Used for user display and rough ordering\n\n### witness.timestamp\n- Provided by blockchain/TSA\n- Trusted (immutable on-chain)\n- Authoritative time proof\n- Should be used for verification and legal purposes\n\n**Best Practice**: Always use `witness.timestamp` for critical timestamp verification.\n\n## Cost Considerations\n\n### Ethereum\n\n| Network | Cost | When to Use |\n|---------|------|-------------|\n| Mainnet | ~$5-50 per transaction | Production, legal, high-value |\n| Sepolia | Free (testnet) | Development, testing |\n| Holesky | Free (testnet) | Development, testing |\n\n**Gas Optimization**: Batch multiple witnesses into one transaction using Merkle trees.\n\n### TSA\n- Typically $0.10-1.00 per timestamp\n- Good for compliance requirements\n- RFC 3161 standard\n\n### Nostr\n- Free (decentralized network)\n- Lower trust than blockchain\n- Good for social proof\n\n## Implementation Notes\n\n### Creating a Witness Revision\n\n1. Identify the revision(s) to witness\n2. Choose network (mainnet, sepolia, etc.)\n3. If batching, build Merkle tree\n4. Submit transaction to blockchain\n5. Wait for transaction confirmation\n6. Extract transaction details\n7. Generate Merkle proofs (if batched)\n8. Create witness revision(s)\n\n### Verifying a Witness Revision\n\n#### Single Revision (No Batching)\n```\n1. Verify merkle_proof is empty\n2. Verify merkle_root equals previous_revision\n3. Query blockchain for transaction_hash\n4. Verify transaction exists and is confirmed\n5. Extract witnessed value from transaction\n6. Verify it matches merkle_root\n7. Check transaction timestamp\n```\n\n#### Batched Revision\n```\n1. Verify merkle_proof is non-empty\n2. Compute Merkle root using proof and previous_revision\n3. Verify computed root matches merkle_root\n4. Query blockchain for transaction_hash\n5. Verify merkle_root is stored on-chain\n6. Validate transaction timestamp\n```\n\n### Error Handling\n\nCommon issues and solutions:\n\n| Issue | Solution |\n|-------|----------|\n| Transaction not found | Wait longer (may not be confirmed yet) |\n| Wrong network | Check transaction on correct network |\n| Merkle proof invalid | Regenerate proof from original tree |\n| Timestamp mismatch | Check blockchain time vs local time |\n| Gas estimation failed | Check wallet balance and gas price |\n\n## Security Considerations\n\n### 1. Network Selection\n- Use mainnet for production/legal purposes\n- Use testnets only for development\n- Consider compliance requirements\n\n### 2. Confirmation Depth\n- Wait for sufficient confirmations (6+ for mainnet)\n- More confirmations = higher security\n- Balance security vs speed requirements\n\n### 3. Merkle Proof Storage\n- Store proofs securely\n- Without proof, batched witness can't be verified\n- Consider proof backup strategies\n\n### 4. Timestamp Trust\n- Trust blockchain timestamp over local_timestamp\n- Account for block time variability\n- Consider block reorganizations\n\n### 5. Cost Management\n- Batch witnesses to reduce costs\n- Monitor gas prices\n- Use appropriate network for use case\n\n## Advanced Topics\n\n### Multi-Network Witnessing\n\nWitness the same revision on multiple networks for redundancy:\n\n```\nObject ‚Üí Signature ‚Üí Witness (Ethereum) ‚Üí Witness (Nostr) ‚Üí Witness (TSA)\n```\n\nEach witness provides independent proof.\n\n### Periodic Re-Witnessing\n\nFor long-term preservation, periodically re-witness important revisions:\n\n```\n2024: Object ‚Üí Witness (Mainnet)\n2025: Link to Object ‚Üí Witness (Mainnet)\n2026: Link to 2025 ‚Üí Witness (Mainnet)\n```\n\n### Cross-Chain Verification\n\nWitness on multiple blockchains for increased trust:\n\n```\nObject ‚Üí Witness (Ethereum Mainnet) ‚Üí Witness (Polygon) ‚Üí Witness (Arbitrum)\n```\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Primary target for witnessing\n- **Signature Revisions**: Often witnessed after signing\n- **Link Revisions**: Can be witnessed to prove connection timestamp\n- **Template Revisions**: Rarely witnessed (they're standalone)\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets witnessed\n- [Signature Revision](/schema_reference/signing_revision) - Often combined with witnessing\n- [RFC 3161 - Timestamping](https://www.rfc-editor.org/rfc/rfc3161) - TSA standard\n- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/) - On-chain witnessing\n- [Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) - Batch witnessing structure\n"])</script><script>self.__next_f.push([1,"37:T362b,"])</script><script>self.__next_f.push([1,"\n## Core Capabilities\n\n### Tamper-Proof Verification\nOnce a document is notarized in the Aqua Protocol, any modification becomes immediately detectable. The cryptographic hash of the document content is stored in the revision chain, making it mathematically impossible to alter without detection.\n\n### Timestamp Authentication\nEvery document revision receives a blockchain-anchored timestamp, providing cryptographic proof of when the document was created or modified. This eliminates disputes about document timelines.\n\n### Permanent Audit Trails\nAll document revisions, signatures, and witnesses are permanently recorded in an immutable chain. This creates a complete history of the document lifecycle that can be independently verified.\n\n### Decentralized Validation\nVerification happens cryptographically without requiring trust in intermediaries. Anyone with the document and its Aqua chain can independently verify authenticity and integrity.\n\n## Use Cases by Industry\n\n### Legal Documents\n\n**Contract Authenticity**\n- Prove when contracts were signed\n- Verify that contract terms haven't been altered\n- Establish non-repudiation through digital signatures\n- Maintain chain of custody for legal proceedings\n\n**Evidence Preservation**\n- Create tamper-proof records of digital evidence\n- Timestamp evidence collection\n- Maintain audit trails for admissibility\n- Prove evidence integrity in court\n\n**Notary Services**\n- Provide remote notarization with cryptographic proof\n- Replace traditional notary stamps with blockchain anchoring\n- Enable verifiable notarization across jurisdictions\n- Reduce costs while increasing security\n\n**Legal Compliance**\n- Demonstrate compliance with document retention policies\n- Prove regulatory filings were submitted on time\n- Maintain auditable records for investigations\n- Satisfy e-discovery requirements\n\n### Business Applications\n\n**Invoice Verification**\n- Authenticate invoices to prevent fraud\n- Track invoice approvals and modifications\n- Provide proof of invoice delivery and receipt\n- Enable automated payment processing with verified invoices\n\n**Purchase Orders**\n- Verify PO authenticity between trading partners\n- Track PO modifications and approvals\n- Prevent unauthorized changes\n- Create audit trails for procurement compliance\n\n**Financial Records**\n- Ensure integrity of financial statements\n- Track modifications to accounting records\n- Satisfy auditor requirements for record verification\n- Maintain SOX compliance with immutable audit logs\n\n**Regulatory Reporting**\n- Prove timely submission of regulatory reports\n- Demonstrate report integrity over time\n- Satisfy audit requirements\n- Reduce compliance costs\n\n### Educational Credentials\n\n**Diploma Authentication**\n- Provide instant verification of degree authenticity\n- Eliminate diploma mills and fraudulent credentials\n- Enable employers to verify qualifications\n- Reduce verification costs and time\n\n**Transcript Integrity**\n- Prevent transcript tampering\n- Allow secure sharing with third parties\n- Maintain permanent academic records\n- Enable credential portability across institutions\n\n**Certificate Validation**\n- Verify professional certifications\n- Track certificate expiration dates\n- Enable certificate revocation when needed\n- Support continuing education tracking\n\n**Academic Records**\n- Create verifiable lifetime learning records\n- Enable secure transcript sharing\n- Support credential stacking and micro-credentials\n- Facilitate credit transfers between institutions\n\n### Government Documents\n\n**Identity Documents**\n- Authenticate passports and ID cards\n- Enable remote identity verification\n- Prevent identity fraud\n- Support digital identity systems\n\n**License Verification**\n- Verify professional licenses instantly\n- Track license renewals and expirations\n- Enable license portability across jurisdictions\n- Support automated compliance checking\n\n**Permits and Certifications**\n- Authenticate building permits\n- Verify safety certifications\n- Track permit modifications\n- Enable instant permit validation by inspectors\n\n**Official Records**\n- Ensure integrity of government records\n- Enable citizen verification of official documents\n- Maintain transparent government operations\n- Prevent records tampering\n\n## Key Benefits\n\n### Eliminate Single Points of Failure\nTraditional document verification systems rely on centralized databases that can fail, be hacked, or become unavailable. Aqua Protocol's decentralized approach distributes verification capability, ensuring documents can always be verified even if specific systems are offline.\n\n### Maintain Document Provenance\nEvery document modification is recorded with cryptographic proof of who made the change, when it occurred, and what was changed. This complete provenance trail answers questions about document history definitively.\n\n### Cryptographic Verification\nVerification relies on mathematical certainty rather than trust. Hashes, signatures, and blockchain anchors provide proof that can't be forged, even by system administrators.\n\n### No Trusted Intermediaries Required\nUnlike traditional notary or verification services, Aqua Protocol enables anyone to verify document authenticity independently. This reduces costs and increases accessibility.\n\n### Regulatory Compliance\nIndustries requiring regulatory compliance benefit from maintained audit trails:\n- **Legal firms**: Demonstrate evidence integrity and chain of custody\n- **Financial institutions**: Satisfy SOX, GDPR, and financial regulations\n- **Healthcare providers**: Maintain HIPAA-compliant document trails\n- **Educational institutions**: Provide verifiable credentials that meet accreditation standards\n\n### Cost Reduction\nAutomated verification reduces manual processes, eliminates middlemen, speeds up verification times, and prevents fraud losses.\n\n## How It Works\n\n### 1. Document Notarization\nWhen a document is first notarized:\n- The document content is hashed using SHA3-256\n- A genesis revision is created with the document hash\n- The revision is signed by the document creator\n- The signature is witnessed on a blockchain\n- All data is stored in an immutable Aqua chain\n\n### 2. Document Updates\nWhen a document is modified:\n- A new revision is created referencing the previous revision\n- The new content hash is recorded\n- The update is signed by authorized parties\n- The signature is witnessed for timestamp proof\n- The revision chain grows, maintaining complete history\n\n### 3. Multi-Party Signing\nFor documents requiring multiple signatures:\n- Each party adds their signature as a new revision\n- Signatures reference the document revision being signed\n- Order of signing is preserved in the chain\n- All signatures receive blockchain timestamps\n- Final witness anchors the complete signing process\n\n### 4. Verification\nAnyone can verify a document by:\n- Computing the hash of the document content\n- Comparing it to the hash in the revision chain\n- Verifying all signatures cryptographically\n- Checking blockchain witness timestamps\n- Validating the entire revision chain integrity\n\n## Real-World Scenarios\n\n### Scenario 1: Legal Contract Management\n\n**Challenge**: A law firm needs to manage contracts with guaranteed integrity and provable signing timestamps for multiple parties.\n\n**Solution**:\n- Contract is notarized when drafted, creating the genesis revision\n- Each party reviews and signs, adding signature revisions\n- Final contract is witnessed on Ethereum mainnet\n- All parties receive the complete Aqua chain\n- Years later, if disputed, the contract's integrity and signing timeline can be cryptographically proven\n\n**Benefits**: Non-repudiation, tamper-proof records, defensible timestamps, reduced notary costs\n\n### Scenario 2: Academic Credential Verification\n\n**Challenge**: Universities issue thousands of diplomas, and employers need to verify credentials quickly without calling the registrar.\n\n**Solution**:\n- University notarizes each diploma as it's issued\n- Diploma includes an Aqua chain with the university's signature\n- University witnesses the batch of diplomas on blockchain\n- Employers scan QR code or receive Aqua chain from candidate\n- Verification happens instantly using Aqua verification tools\n\n**Benefits**: Instant verification, eliminated fraud, reduced administrative burden, improved candidate experience\n\n### Scenario 3: Financial Audit Trail\n\n**Challenge**: A public company must maintain auditable financial records that prove compliance with regulations.\n\n**Solution**:\n- Financial statements are notarized each quarter\n- CFO signs the statement, adding signature revision\n- External auditor witnesses the statement on blockchain\n- Audit trail is preserved permanently\n- Regulators can verify statement integrity independently\n\n**Benefits**: Regulatory compliance, reduced audit costs, defensible records, fraud prevention\n\n### Scenario 4: Government Permit Issuance\n\n**Challenge**: Building department issues permits that need to be verified by inspectors, contractors, and the public.\n\n**Solution**:\n- Permit applications are notarized when submitted\n- Permit approvals are signed by authorized officials\n- Approved permits are witnessed on blockchain\n- QR codes on physical permits link to Aqua chains\n- Anyone can verify permit authenticity and status\n\n**Benefits**: Fraud prevention, instant verification, public transparency, reduced administrative overhead\n\n## Integration Patterns\n\n### Document Management Systems\nIntegrate Aqua Protocol into existing DMS platforms to automatically notarize important documents. When documents are finalized, trigger Aqua notarization via SDK.\n\n### E-Signature Platforms\nEnhance e-signature solutions with blockchain-anchored timestamps and cryptographic verification. Each signature becomes a verifiable revision in the Aqua chain.\n\n### CRM and Business Systems\nAdd document verification to CRM, ERP, or custom business applications. Automatically notarize quotes, proposals, contracts, and invoices as they're generated.\n\n### Educational Systems\nIntegrate with student information systems to automatically notarize transcripts, diplomas, and certificates as they're issued.\n\n### Government Systems\nAdd Aqua Protocol to permit, license, and registration systems to provide instant verification capability to citizens and businesses.\n\n## Best Practices\n\n### Initial Notarization\n- Notarize documents as early as possible in their lifecycle\n- Include relevant metadata (document type, parties, purpose)\n- Use appropriate method (scalar for small docs, tree for large)\n- Sign immediately after creation to establish authorship\n\n### Multi-Party Documents\n- Establish signing order and communicate to all parties\n- Each party should verify previous signatures before adding theirs\n- Witness after all signatures are collected\n- Distribute complete Aqua chain to all parties\n\n### Long-Term Storage\n- Store Aqua chains separately from documents\n- Back up chains to multiple locations\n- Include Aqua chain with document when transmitting\n- Test verification periodically\n\n### Verification\n- Always verify documents received from third parties\n- Check entire revision chain, not just the latest revision\n- Verify blockchain witnesses for important documents\n- Validate signatures match expected signers\n\n### Privacy Considerations\n- Aqua chains don't contain document content by default\n- Share chains carefully as they prove document existence\n- Use private blockchains if public witnessing is problematic\n- Consider what metadata is included in revisions\n\n## Technical Advantages\n\n### Cryptographic Security\n- SHA3-256 hashing provides computational infeasibility of collision attacks\n- ECDSA signatures (65 bytes) provide 128-bit security level\n- Blockchain anchoring makes backdating mathematically impossible\n\n### Scalability\n- Document verification is O(n) where n is number of revisions\n- Merkle tree mode enables selective disclosure of large documents\n- Batch witnessing reduces blockchain transaction costs\n- Verification can happen offline after initial chain retrieval\n\n### Interoperability\n- JSON-based format enables easy integration\n- Multiple SDK options (Rust, JavaScript/TypeScript)\n- Platform-agnostic verification\n- Standard cryptographic primitives\n\n### Future-Proof\n- Protocol versioning supports evolution\n- Blockchain-agnostic witness mechanism\n- Multiple signature algorithm support\n- Extensible revision types\n\n## Common Questions\n\n**Q: What if the blockchain network goes offline?**\nA: Verification of existing documents still works using cryptographic verification of signatures and hashes. Only new witnessing requires blockchain access. Historical witnesses remain provable through transaction records.\n\n**Q: How long are documents stored?**\nA: Aqua Protocol stores only hashes and metadata, not document content. Document storage is separate and managed by users. Aqua chains are small (kilobytes) and can be stored indefinitely.\n\n**Q: Can witnesses be trusted?**\nA: Blockchain witnesses provide cryptographic proof of timestamp. As long as the blockchain network is secure and decentralized, witnesses cannot be backdated or falsified.\n\n**Q: What about privacy?**\nA: By default, only document hashes are stored on-chain, not content. The document itself remains private. Share Aqua chains carefully as they prove document existence at specific times.\n\n**Q: How do I revoke a document?**\nA: Add a revocation revision to the chain. The document history remains (for audit purposes), but new revisions can indicate revoked status.\n\n## See Also\n\n- [Supply Chain Tracking](/use_cases/supply-chain) - Apply similar verification to supply chain events\n- [Identity Attestation](/use_cases/identity-attestation) - Verify identity credentials\n- [Quick Start](/quick-start) - Get started with document verification\n- [Schema Reference](/schema_reference/introduction) - Technical specifications\n"])</script><script>self.__next_f.push([1,"38:T362b,"])</script><script>self.__next_f.push([1,"\n## Core Capabilities\n\n### Tamper-Proof Verification\nOnce a document is notarized in the Aqua Protocol, any modification becomes immediately detectable. The cryptographic hash of the document content is stored in the revision chain, making it mathematically impossible to alter without detection.\n\n### Timestamp Authentication\nEvery document revision receives a blockchain-anchored timestamp, providing cryptographic proof of when the document was created or modified. This eliminates disputes about document timelines.\n\n### Permanent Audit Trails\nAll document revisions, signatures, and witnesses are permanently recorded in an immutable chain. This creates a complete history of the document lifecycle that can be independently verified.\n\n### Decentralized Validation\nVerification happens cryptographically without requiring trust in intermediaries. Anyone with the document and its Aqua chain can independently verify authenticity and integrity.\n\n## Use Cases by Industry\n\n### Legal Documents\n\n**Contract Authenticity**\n- Prove when contracts were signed\n- Verify that contract terms haven't been altered\n- Establish non-repudiation through digital signatures\n- Maintain chain of custody for legal proceedings\n\n**Evidence Preservation**\n- Create tamper-proof records of digital evidence\n- Timestamp evidence collection\n- Maintain audit trails for admissibility\n- Prove evidence integrity in court\n\n**Notary Services**\n- Provide remote notarization with cryptographic proof\n- Replace traditional notary stamps with blockchain anchoring\n- Enable verifiable notarization across jurisdictions\n- Reduce costs while increasing security\n\n**Legal Compliance**\n- Demonstrate compliance with document retention policies\n- Prove regulatory filings were submitted on time\n- Maintain auditable records for investigations\n- Satisfy e-discovery requirements\n\n### Business Applications\n\n**Invoice Verification**\n- Authenticate invoices to prevent fraud\n- Track invoice approvals and modifications\n- Provide proof of invoice delivery and receipt\n- Enable automated payment processing with verified invoices\n\n**Purchase Orders**\n- Verify PO authenticity between trading partners\n- Track PO modifications and approvals\n- Prevent unauthorized changes\n- Create audit trails for procurement compliance\n\n**Financial Records**\n- Ensure integrity of financial statements\n- Track modifications to accounting records\n- Satisfy auditor requirements for record verification\n- Maintain SOX compliance with immutable audit logs\n\n**Regulatory Reporting**\n- Prove timely submission of regulatory reports\n- Demonstrate report integrity over time\n- Satisfy audit requirements\n- Reduce compliance costs\n\n### Educational Credentials\n\n**Diploma Authentication**\n- Provide instant verification of degree authenticity\n- Eliminate diploma mills and fraudulent credentials\n- Enable employers to verify qualifications\n- Reduce verification costs and time\n\n**Transcript Integrity**\n- Prevent transcript tampering\n- Allow secure sharing with third parties\n- Maintain permanent academic records\n- Enable credential portability across institutions\n\n**Certificate Validation**\n- Verify professional certifications\n- Track certificate expiration dates\n- Enable certificate revocation when needed\n- Support continuing education tracking\n\n**Academic Records**\n- Create verifiable lifetime learning records\n- Enable secure transcript sharing\n- Support credential stacking and micro-credentials\n- Facilitate credit transfers between institutions\n\n### Government Documents\n\n**Identity Documents**\n- Authenticate passports and ID cards\n- Enable remote identity verification\n- Prevent identity fraud\n- Support digital identity systems\n\n**License Verification**\n- Verify professional licenses instantly\n- Track license renewals and expirations\n- Enable license portability across jurisdictions\n- Support automated compliance checking\n\n**Permits and Certifications**\n- Authenticate building permits\n- Verify safety certifications\n- Track permit modifications\n- Enable instant permit validation by inspectors\n\n**Official Records**\n- Ensure integrity of government records\n- Enable citizen verification of official documents\n- Maintain transparent government operations\n- Prevent records tampering\n\n## Key Benefits\n\n### Eliminate Single Points of Failure\nTraditional document verification systems rely on centralized databases that can fail, be hacked, or become unavailable. Aqua Protocol's decentralized approach distributes verification capability, ensuring documents can always be verified even if specific systems are offline.\n\n### Maintain Document Provenance\nEvery document modification is recorded with cryptographic proof of who made the change, when it occurred, and what was changed. This complete provenance trail answers questions about document history definitively.\n\n### Cryptographic Verification\nVerification relies on mathematical certainty rather than trust. Hashes, signatures, and blockchain anchors provide proof that can't be forged, even by system administrators.\n\n### No Trusted Intermediaries Required\nUnlike traditional notary or verification services, Aqua Protocol enables anyone to verify document authenticity independently. This reduces costs and increases accessibility.\n\n### Regulatory Compliance\nIndustries requiring regulatory compliance benefit from maintained audit trails:\n- **Legal firms**: Demonstrate evidence integrity and chain of custody\n- **Financial institutions**: Satisfy SOX, GDPR, and financial regulations\n- **Healthcare providers**: Maintain HIPAA-compliant document trails\n- **Educational institutions**: Provide verifiable credentials that meet accreditation standards\n\n### Cost Reduction\nAutomated verification reduces manual processes, eliminates middlemen, speeds up verification times, and prevents fraud losses.\n\n## How It Works\n\n### 1. Document Notarization\nWhen a document is first notarized:\n- The document content is hashed using SHA3-256\n- A genesis revision is created with the document hash\n- The revision is signed by the document creator\n- The signature is witnessed on a blockchain\n- All data is stored in an immutable Aqua chain\n\n### 2. Document Updates\nWhen a document is modified:\n- A new revision is created referencing the previous revision\n- The new content hash is recorded\n- The update is signed by authorized parties\n- The signature is witnessed for timestamp proof\n- The revision chain grows, maintaining complete history\n\n### 3. Multi-Party Signing\nFor documents requiring multiple signatures:\n- Each party adds their signature as a new revision\n- Signatures reference the document revision being signed\n- Order of signing is preserved in the chain\n- All signatures receive blockchain timestamps\n- Final witness anchors the complete signing process\n\n### 4. Verification\nAnyone can verify a document by:\n- Computing the hash of the document content\n- Comparing it to the hash in the revision chain\n- Verifying all signatures cryptographically\n- Checking blockchain witness timestamps\n- Validating the entire revision chain integrity\n\n## Real-World Scenarios\n\n### Scenario 1: Legal Contract Management\n\n**Challenge**: A law firm needs to manage contracts with guaranteed integrity and provable signing timestamps for multiple parties.\n\n**Solution**:\n- Contract is notarized when drafted, creating the genesis revision\n- Each party reviews and signs, adding signature revisions\n- Final contract is witnessed on Ethereum mainnet\n- All parties receive the complete Aqua chain\n- Years later, if disputed, the contract's integrity and signing timeline can be cryptographically proven\n\n**Benefits**: Non-repudiation, tamper-proof records, defensible timestamps, reduced notary costs\n\n### Scenario 2: Academic Credential Verification\n\n**Challenge**: Universities issue thousands of diplomas, and employers need to verify credentials quickly without calling the registrar.\n\n**Solution**:\n- University notarizes each diploma as it's issued\n- Diploma includes an Aqua chain with the university's signature\n- University witnesses the batch of diplomas on blockchain\n- Employers scan QR code or receive Aqua chain from candidate\n- Verification happens instantly using Aqua verification tools\n\n**Benefits**: Instant verification, eliminated fraud, reduced administrative burden, improved candidate experience\n\n### Scenario 3: Financial Audit Trail\n\n**Challenge**: A public company must maintain auditable financial records that prove compliance with regulations.\n\n**Solution**:\n- Financial statements are notarized each quarter\n- CFO signs the statement, adding signature revision\n- External auditor witnesses the statement on blockchain\n- Audit trail is preserved permanently\n- Regulators can verify statement integrity independently\n\n**Benefits**: Regulatory compliance, reduced audit costs, defensible records, fraud prevention\n\n### Scenario 4: Government Permit Issuance\n\n**Challenge**: Building department issues permits that need to be verified by inspectors, contractors, and the public.\n\n**Solution**:\n- Permit applications are notarized when submitted\n- Permit approvals are signed by authorized officials\n- Approved permits are witnessed on blockchain\n- QR codes on physical permits link to Aqua chains\n- Anyone can verify permit authenticity and status\n\n**Benefits**: Fraud prevention, instant verification, public transparency, reduced administrative overhead\n\n## Integration Patterns\n\n### Document Management Systems\nIntegrate Aqua Protocol into existing DMS platforms to automatically notarize important documents. When documents are finalized, trigger Aqua notarization via SDK.\n\n### E-Signature Platforms\nEnhance e-signature solutions with blockchain-anchored timestamps and cryptographic verification. Each signature becomes a verifiable revision in the Aqua chain.\n\n### CRM and Business Systems\nAdd document verification to CRM, ERP, or custom business applications. Automatically notarize quotes, proposals, contracts, and invoices as they're generated.\n\n### Educational Systems\nIntegrate with student information systems to automatically notarize transcripts, diplomas, and certificates as they're issued.\n\n### Government Systems\nAdd Aqua Protocol to permit, license, and registration systems to provide instant verification capability to citizens and businesses.\n\n## Best Practices\n\n### Initial Notarization\n- Notarize documents as early as possible in their lifecycle\n- Include relevant metadata (document type, parties, purpose)\n- Use appropriate method (scalar for small docs, tree for large)\n- Sign immediately after creation to establish authorship\n\n### Multi-Party Documents\n- Establish signing order and communicate to all parties\n- Each party should verify previous signatures before adding theirs\n- Witness after all signatures are collected\n- Distribute complete Aqua chain to all parties\n\n### Long-Term Storage\n- Store Aqua chains separately from documents\n- Back up chains to multiple locations\n- Include Aqua chain with document when transmitting\n- Test verification periodically\n\n### Verification\n- Always verify documents received from third parties\n- Check entire revision chain, not just the latest revision\n- Verify blockchain witnesses for important documents\n- Validate signatures match expected signers\n\n### Privacy Considerations\n- Aqua chains don't contain document content by default\n- Share chains carefully as they prove document existence\n- Use private blockchains if public witnessing is problematic\n- Consider what metadata is included in revisions\n\n## Technical Advantages\n\n### Cryptographic Security\n- SHA3-256 hashing provides computational infeasibility of collision attacks\n- ECDSA signatures (65 bytes) provide 128-bit security level\n- Blockchain anchoring makes backdating mathematically impossible\n\n### Scalability\n- Document verification is O(n) where n is number of revisions\n- Merkle tree mode enables selective disclosure of large documents\n- Batch witnessing reduces blockchain transaction costs\n- Verification can happen offline after initial chain retrieval\n\n### Interoperability\n- JSON-based format enables easy integration\n- Multiple SDK options (Rust, JavaScript/TypeScript)\n- Platform-agnostic verification\n- Standard cryptographic primitives\n\n### Future-Proof\n- Protocol versioning supports evolution\n- Blockchain-agnostic witness mechanism\n- Multiple signature algorithm support\n- Extensible revision types\n\n## Common Questions\n\n**Q: What if the blockchain network goes offline?**\nA: Verification of existing documents still works using cryptographic verification of signatures and hashes. Only new witnessing requires blockchain access. Historical witnesses remain provable through transaction records.\n\n**Q: How long are documents stored?**\nA: Aqua Protocol stores only hashes and metadata, not document content. Document storage is separate and managed by users. Aqua chains are small (kilobytes) and can be stored indefinitely.\n\n**Q: Can witnesses be trusted?**\nA: Blockchain witnesses provide cryptographic proof of timestamp. As long as the blockchain network is secure and decentralized, witnesses cannot be backdated or falsified.\n\n**Q: What about privacy?**\nA: By default, only document hashes are stored on-chain, not content. The document itself remains private. Share Aqua chains carefully as they prove document existence at specific times.\n\n**Q: How do I revoke a document?**\nA: Add a revocation revision to the chain. The document history remains (for audit purposes), but new revisions can indicate revoked status.\n\n## See Also\n\n- [Supply Chain Tracking](/use_cases/supply-chain) - Apply similar verification to supply chain events\n- [Identity Attestation](/use_cases/identity-attestation) - Verify identity credentials\n- [Quick Start](/quick-start) - Get started with document verification\n- [Schema Reference](/schema_reference/introduction) - Technical specifications\n"])</script><script>self.__next_f.push([1,"39:T1791,"])</script><script>self.__next_f.push([1,"\nThe Aqua Protocol enables a robust **Self-Sovereign Identity (SSI)** framework where individuals and organizations can issue, attest, and verify identity claims without relying on centralized identity providers. By leveraging cryptographic proofs and decentralized trust chains, Aqua allows users to own their data while enabling third parties to verify specific attributes with certainty.\n\n## Core Capabilities\n\n### Self-Sovereign Identity (SSI)\nUsers have full control over their identities. Identity claims are **self-issued** first, proving account ownership, and then enriched by **attestations** from trusted authorities. This ensures that the user is always the central point of their identity graph.\n\n### Verifiable Attestations\nThird parties (Trust Authorities) can sign attestations that validate a user's specific claims (e.g., \"Over 18\", \"Accredited Investor\", \"University Graduate\"). These attestations are cryptographically linked to the user's identity chain and the authority's trust chain.\n\n### Trust Chains\nTrust is transitive and transparent. A verifier doesn't just trust a claim; they verify the entire chain of authority. For example, a diploma is trusted because it's signed by a University, which is accredited by an Education Ministry, which is recognized by the Government.\n\n### Selective Disclosure \u0026 Privacy\nUsers can share specific attestations (e.g., \"I am over 21\") without revealing their entire identity or unrelated personal data. Data Vaults protect sensitive claims, ensuring they are only decrypted for authorized verifiers.\n\n## Use Cases by Industry\n\n### Education \u0026 Academia\n\n**Digital Diplomas \u0026 Transcripts**\n- Universities issue tamper-proof degree certificates.\n- Students can instantly prove graduation to employers.\n- Prevents credential fraud and \"diploma mills\".\n- Enables portable academic records across institutions.\n\n**Professional Certifications**\n- Licensing boards attest to professional status (e.g., Medical License, Bar Association).\n- Real-time verification of valid/active status.\n- Automated expiry and renewal tracking.\n\n### Government \u0026 Legal\n\n**Digital ID \u0026 Passports**\n- Governments issue digital complements to physical IDs.\n- Citizens use digital wallets to prove citizenship or residency.\n- Streamlined visa and border entry processes.\n\n**Notary \u0026 Witnessing**\n- Notaries attest to the identity of a signer on a document.\n- Creates a cryptographic link between the person, the document, and the notary.\n- Replaces physical stamps with digital signatures.\n\n### Financial Services\n\n**KYC/AML Compliance**\n- Banks perform \"Know Your Customer\" checks once and issue a reusable attestation.\n- Users share this attestation with other services to onboard instantly without re-submitting documents.\n- Reduces compliance costs and friction.\n\n**Accredited Investor Status**\n- Financial institutions attest that a user meets investment criteria.\n- Allows participation in regulated private equity or tokens.\n\n### Digital Services \u0026 Web3\n\n**Sybil Resistance**\n- Verify that an account belongs to a unique human without collecting personal data.\n- \"Proof of Humanity\" or \"Social Login\" attestations.\n- Prevents bot spam and manipulation in DAOs and communities.\n\n**Reputation \u0026 Social Proof**\n- Platforms attest to a user's reputation score or history.\n- Enables portable reputation across different marketplaces and communities.\n\n## Key Benefits\n\n### User Privacy \u0026 Control\nUsers store their own data in encrypted Data Vaults. They grant access only when necessary and can revoke it at any time. No centralized \"honey pot\" of user data to hack.\n\n### Fraud Reduction\nCryptographic signatures make it impossible to forge attestations. \n\n### Interoperability\nBuilt on standard cryptographic primitives, allowing identity claims to be used across different platforms, wallets, and services that support the Aqua Protocol.\n\n### Reduced Friction\n\"Verify once, use everywhere.\" Users don't need to repeatedly upload passport photos or utility bills. One verified attestation can be reused across multiple services.\n\n## How It Works\n\n### 1. Claim Creation (Self-Issuance)\nThe user creates a **Self-Issued Identity Claim**.\n- Example: \"I claim my name is Alice.\"\n- This claim is signed by Alice's private key, establishing ownership of the claim.\n- It serves as the \"subject\" for future attestations.\n\n### 2. Attestation\nA **Trust Authority** (e.g., a University) verifies the claim off-chain (by checking real documents) and then issues an **Attestation**.\n- The Authority signs a statement referencing Alice's self-issued claim hash.\n- \"I, University X, attest that the claim [Hash] by Alice is true.\"\n- This attestation is recorded in the Authority's Aqua chain.\n\n### 3. Verification \u0026 Trust Chains\nA relying party (e.g., an Employer) verifies the diploma.\n- They check Alice's claim.\n- They verify the University's signature on the attestation.\n- They verify the University's authority (e.g., by checking a \"Ministry of Education\" attestation on the University's identity).\n- If the chain of trust is valid, the diploma is accepted.\n\n\n## Real-World Scenario: The \"Trust Chain\"\n\nConsider verifying a **University Degree**:\n\n1.  **The Graduate (Alice)**: Creates a self-issued claim for her degree.\n2.  **The Professor**: Signs an attestation for Alice's grade/completion.\n3.  **The Department Head**: Attests to the Professor's employment.\n4.  **The University**: Attests to the Department Head's role.\n5.  **The Ministry of Education**: Attests to the University's accreditation.\n\nWhen an employer verifies Alice's degree, they trace this path back to a root of trust they recognize (e.g., the Ministry of Education), ensuring the credential is legitimate without needing to call the university.\n\n## See Also\n\n- [Document Verification](/use_cases/document-verification) - Verify the integrity of files and contracts.\n- [Supply Chain Tracking](/use_cases/supply-chain) - Trace provenance of physical goods.\n- [Aqua CLI](/dev_tools/aqua_cli) - Tools for issuing and verifying claims.\n"])</script><script>self.__next_f.push([1,"3a:T1791,"])</script><script>self.__next_f.push([1,"\nThe Aqua Protocol enables a robust **Self-Sovereign Identity (SSI)** framework where individuals and organizations can issue, attest, and verify identity claims without relying on centralized identity providers. By leveraging cryptographic proofs and decentralized trust chains, Aqua allows users to own their data while enabling third parties to verify specific attributes with certainty.\n\n## Core Capabilities\n\n### Self-Sovereign Identity (SSI)\nUsers have full control over their identities. Identity claims are **self-issued** first, proving account ownership, and then enriched by **attestations** from trusted authorities. This ensures that the user is always the central point of their identity graph.\n\n### Verifiable Attestations\nThird parties (Trust Authorities) can sign attestations that validate a user's specific claims (e.g., \"Over 18\", \"Accredited Investor\", \"University Graduate\"). These attestations are cryptographically linked to the user's identity chain and the authority's trust chain.\n\n### Trust Chains\nTrust is transitive and transparent. A verifier doesn't just trust a claim; they verify the entire chain of authority. For example, a diploma is trusted because it's signed by a University, which is accredited by an Education Ministry, which is recognized by the Government.\n\n### Selective Disclosure \u0026 Privacy\nUsers can share specific attestations (e.g., \"I am over 21\") without revealing their entire identity or unrelated personal data. Data Vaults protect sensitive claims, ensuring they are only decrypted for authorized verifiers.\n\n## Use Cases by Industry\n\n### Education \u0026 Academia\n\n**Digital Diplomas \u0026 Transcripts**\n- Universities issue tamper-proof degree certificates.\n- Students can instantly prove graduation to employers.\n- Prevents credential fraud and \"diploma mills\".\n- Enables portable academic records across institutions.\n\n**Professional Certifications**\n- Licensing boards attest to professional status (e.g., Medical License, Bar Association).\n- Real-time verification of valid/active status.\n- Automated expiry and renewal tracking.\n\n### Government \u0026 Legal\n\n**Digital ID \u0026 Passports**\n- Governments issue digital complements to physical IDs.\n- Citizens use digital wallets to prove citizenship or residency.\n- Streamlined visa and border entry processes.\n\n**Notary \u0026 Witnessing**\n- Notaries attest to the identity of a signer on a document.\n- Creates a cryptographic link between the person, the document, and the notary.\n- Replaces physical stamps with digital signatures.\n\n### Financial Services\n\n**KYC/AML Compliance**\n- Banks perform \"Know Your Customer\" checks once and issue a reusable attestation.\n- Users share this attestation with other services to onboard instantly without re-submitting documents.\n- Reduces compliance costs and friction.\n\n**Accredited Investor Status**\n- Financial institutions attest that a user meets investment criteria.\n- Allows participation in regulated private equity or tokens.\n\n### Digital Services \u0026 Web3\n\n**Sybil Resistance**\n- Verify that an account belongs to a unique human without collecting personal data.\n- \"Proof of Humanity\" or \"Social Login\" attestations.\n- Prevents bot spam and manipulation in DAOs and communities.\n\n**Reputation \u0026 Social Proof**\n- Platforms attest to a user's reputation score or history.\n- Enables portable reputation across different marketplaces and communities.\n\n## Key Benefits\n\n### User Privacy \u0026 Control\nUsers store their own data in encrypted Data Vaults. They grant access only when necessary and can revoke it at any time. No centralized \"honey pot\" of user data to hack.\n\n### Fraud Reduction\nCryptographic signatures make it impossible to forge attestations. \n\n### Interoperability\nBuilt on standard cryptographic primitives, allowing identity claims to be used across different platforms, wallets, and services that support the Aqua Protocol.\n\n### Reduced Friction\n\"Verify once, use everywhere.\" Users don't need to repeatedly upload passport photos or utility bills. One verified attestation can be reused across multiple services.\n\n## How It Works\n\n### 1. Claim Creation (Self-Issuance)\nThe user creates a **Self-Issued Identity Claim**.\n- Example: \"I claim my name is Alice.\"\n- This claim is signed by Alice's private key, establishing ownership of the claim.\n- It serves as the \"subject\" for future attestations.\n\n### 2. Attestation\nA **Trust Authority** (e.g., a University) verifies the claim off-chain (by checking real documents) and then issues an **Attestation**.\n- The Authority signs a statement referencing Alice's self-issued claim hash.\n- \"I, University X, attest that the claim [Hash] by Alice is true.\"\n- This attestation is recorded in the Authority's Aqua chain.\n\n### 3. Verification \u0026 Trust Chains\nA relying party (e.g., an Employer) verifies the diploma.\n- They check Alice's claim.\n- They verify the University's signature on the attestation.\n- They verify the University's authority (e.g., by checking a \"Ministry of Education\" attestation on the University's identity).\n- If the chain of trust is valid, the diploma is accepted.\n\n\n## Real-World Scenario: The \"Trust Chain\"\n\nConsider verifying a **University Degree**:\n\n1.  **The Graduate (Alice)**: Creates a self-issued claim for her degree.\n2.  **The Professor**: Signs an attestation for Alice's grade/completion.\n3.  **The Department Head**: Attests to the Professor's employment.\n4.  **The University**: Attests to the Department Head's role.\n5.  **The Ministry of Education**: Attests to the University's accreditation.\n\nWhen an employer verifies Alice's degree, they trace this path back to a root of trust they recognize (e.g., the Ministry of Education), ensuring the credential is legitimate without needing to call the university.\n\n## See Also\n\n- [Document Verification](/use_cases/document-verification) - Verify the integrity of files and contracts.\n- [Supply Chain Tracking](/use_cases/supply-chain) - Trace provenance of physical goods.\n- [Aqua CLI](/dev_tools/aqua_cli) - Tools for issuing and verifying claims.\n"])</script><script>self.__next_f.push([1,"3b:T2693,"])</script><script>self.__next_f.push([1,"\n## Why Aqua Protocol?\n\nTraditional systems for tracking data provenance, verifying authenticity, and maintaining audit trails rely on centralized databases and trusted intermediaries. These approaches introduce:\n\n- **Single points of failure**: Centralized systems can be compromised, taken offline, or manipulated\n- **Trust requirements**: Users must trust the intermediary to maintain integrity\n- **Limited verification**: Third parties cannot independently verify authenticity\n- **Vendor lock-in**: Data is trapped in proprietary systems\n- **High costs**: Intermediaries charge fees for verification services\n\nAqua Protocol solves these problems through:\n\n- **Decentralized verification**: Anyone can verify data integrity cryptographically\n- **Mathematical certainty**: Cryptographic proofs replace trust requirements\n- **Immutable history**: Complete audit trails that cannot be altered\n- **Open standards**: Platform-agnostic verification using standard algorithms\n- **Cost efficiency**: Reduced reliance on intermediaries and manual processes\n\n## Core Capabilities\n\n### Tamper-Proof Records\nOnce data is recorded in an Aqua chain, modifications become immediately detectable. Cryptographic hashes ensure that any change to content, timestamps, or signatures invalidates the chain, providing mathematical proof of tampering.\n\n### Blockchain Timestamping\nEvery critical revision can be anchored to Ethereum, Nostr, or TSA timestamping services. This provides cryptographic proof of when data existed, eliminating disputes about timing and preventing backdating.\n\n### Multi-Party Signatures\nMultiple parties can cryptographically sign revisions, establishing non-repudiation and accountability. Each signature is independently verifiable, proving who authorized what and when.\n\n### Provenance Tracking\nLink revisions create relationships between chains, enabling complex provenance graphs. Track how data flows through systems, who touched it, and what transformations occurred.\n\n### Template-Based Validation\nVersion 4's template system enforces data schemas with JSON Schema validation, ensuring consistent structure across revisions while maintaining cryptographic integrity.\n\n## Application Domains\n\n### Legal and Compliance\nLegal documents, contracts, evidence, regulatory filings, and compliance records require guaranteed integrity and provable timestamps. Aqua Protocol provides:\n- Non-repudiation through cryptographic signatures\n- Defensible timestamps via blockchain anchoring\n- Complete audit trails for investigations\n- Chain of custody for evidence\n- Regulatory compliance documentation\n\n### Supply Chain and Logistics\nProducts moving through complex supply chains need provenance tracking from origin to destination. Aqua Protocol enables:\n- End-to-end traceability from raw materials to consumer\n- Multi-party coordination across manufacturers, distributors, and retailers\n- Authenticity verification to prevent counterfeits\n- Regulatory compliance for food, pharmaceuticals, and other regulated goods\n- Efficient recalls with precise product tracking\n\n### Identity and Credentials\nEducational institutions, professional organizations, and governments issue credentials that need verification. Aqua Protocol provides:\n- Instant verification of diplomas, certificates, and licenses\n- Revocation capability when credentials expire or are withdrawn\n- Portable credentials that individuals control\n- Elimination of credential fraud\n- Reduced verification costs and time\n\n### Financial Services\nFinancial institutions require immutable audit trails for transactions, statements, and regulatory reports. Aqua Protocol offers:\n- Tamper-proof financial records\n- Provable submission timing for regulatory filings\n- Multi-party approval workflows for transactions\n- Audit-ready documentation for compliance\n- Fraud prevention through verification\n\n### Healthcare\nPatient records, clinical trial data, and medical device tracking demand integrity and privacy. Aqua Protocol enables:\n- Verifiable medical records that patients control\n- Clinical trial data integrity for regulatory approval\n- Medical device tracking and recall management\n- HIPAA-compliant audit trails\n- Secure sharing between healthcare providers\n\n### Intellectual Property\nPatents, copyrights, trade secrets, and creative works benefit from provable timestamps. Aqua Protocol provides:\n- Proof of creation date for prior art disputes\n- Version tracking for creative works\n- Licensing and royalty audit trails\n- Collaborative creation with attribution\n- Protection against IP theft\n\n## Industry-Specific Solutions\n\n### Manufacturing\n- Bill of materials with cryptographic proof\n- Quality control inspection records\n- Product genealogy from components to finished goods\n- Supplier certification verification\n- Warranty claim documentation\n\n### Real Estate\n- Property title chains with verified transfers\n- Lease agreements with multi-party signatures\n- Inspection reports with tamper-proof timestamps\n- Escrow milestone documentation\n- Regulatory compliance for transactions\n\n### Energy and Utilities\n- Renewable energy certificate tracking\n- Carbon credit provenance verification\n- Utility meter reading audit trails\n- Regulatory compliance documentation\n- Asset maintenance history\n\n### Government and Public Sector\n- Passport and identity document verification\n- Professional license tracking\n- Permit and certification issuance\n- Public records integrity\n- Voting and election audit trails\n\n## Technical Flexibility\n\nAqua Protocol adapts to diverse requirements through:\n\n- **Multiple revision types**: Objects, templates, signatures, witnesses, and links\n- **Flexible signing methods**: RSA, Ethereum EIP-191, DID:JWS, and more\n- **Choice of witnesses**: Ethereum (mainnet, testnets), Nostr, TSA\n- **Scalar or tree methods**: Optimize for simplicity or selective disclosure\n- **Cross-platform SDKs**: Rust with WASM, JavaScript/TypeScript for any environment\n- **Template customization**: Define domain-specific schemas with JSON Schema\n\n## Getting Started\n\nExplore the detailed use cases below to understand how Aqua Protocol applies to your specific domain:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Document Verification\" icon=\"file-check\" href=\"/use_cases/document-verification\"\u003e\n    Ensure document authenticity and integrity with cryptographic verification. Learn how legal firms, businesses, educational institutions, and government agencies use Aqua Protocol for tamper-proof document management.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Supply Chain Tracking\" icon=\"truck\" href=\"/use_cases/supply-chain\"\u003e\n    Track products through the supply chain with end-to-end transparency. Discover how food, pharmaceutical, manufacturing, and logistics companies implement provenance verification.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Identity Attestation\" icon=\"id-card\" href=\"/use_cases/identity-attestation\"\u003e\n    Implement secure identity verification and credential attestation. Explore how credentials, certifications, and identity documents gain instant verifiability.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples \u0026 Tutorials\" icon=\"graduation-cap\" href=\"/use_cases/examples\"\u003e\n    Practical examples and step-by-step tutorials for building with Aqua Protocol. Get hands-on experience implementing real-world use cases.\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Common Patterns\n\nRegardless of industry, Aqua Protocol implementations typically follow these patterns:\n\n### 1. Genesis Creation\nStart by creating the initial revision with core data:\n- Document content, product information, or credential details\n- Relevant metadata (timestamps, identifiers, classifications)\n- Template reference for structured data validation\n\n### 2. Multi-Party Signatures\nCollect signatures from relevant parties:\n- Creator signs to establish authenticity\n- Reviewers sign to indicate approval\n- Authorities sign for official endorsement\n- Each signature adds non-repudiation\n\n### 3. Blockchain Witnessing\nAnchor critical revisions to blockchain:\n- Provides tamper-proof timestamps\n- Prevents backdating of revisions\n- Enables independent verification\n- Satisfies regulatory requirements\n\n### 4. Provenance Linking\nConnect related chains:\n- Link components to assemblies\n- Reference supporting documents\n- Establish dependencies between datasets\n- Create complex verification graphs\n\n### 5. Long-Term Verification\nMaintain verifiability over time:\n- Store Aqua chains separately from content\n- Distribute chains to all stakeholders\n- Periodically verify chain integrity\n- Update verification tools as needed\n\n## Benefits Across All Use Cases\n\n### Trust Without Intermediaries\nCryptographic verification replaces trust in centralized authorities. Anyone can independently verify authenticity, reducing costs and increasing accessibility.\n\n### Regulatory Compliance\nImmutable audit trails satisfy regulators across industries. From SOX compliance in finance to HIPAA in healthcare, Aqua Protocol provides defensible documentation.\n\n### Cost Reduction\nAutomated verification eliminates manual processes, reduces fraud losses, speeds up operations, and removes intermediary fees.\n\n### Enhanced Security\nCryptographic primitives (SHA3-256, ECDSA) provide security that cannot be achieved with traditional databases. Even system administrators cannot forge valid chains.\n\n### Future-Proof Design\nProtocol versioning, extensible revision types, and blockchain-agnostic witnessing ensure Aqua chains remain verifiable as technology evolves.\n\n## Next Steps\n\nReady to implement Aqua Protocol for your use case?\n\n- Review the detailed use case documentation above\n- Check out the [Quick Start Guide](/quick-start) for hands-on implementation\n- Explore the [Schema Reference](/schema_reference/introduction) for technical specifications\n- Choose your SDK: [Rust (v4)](/previous_versions/version_4/introduction) or [JavaScript (v3)](/previous_versions/version_3/introduction)\n"])</script><script>self.__next_f.push([1,"3c:T2693,"])</script><script>self.__next_f.push([1,"\n## Why Aqua Protocol?\n\nTraditional systems for tracking data provenance, verifying authenticity, and maintaining audit trails rely on centralized databases and trusted intermediaries. These approaches introduce:\n\n- **Single points of failure**: Centralized systems can be compromised, taken offline, or manipulated\n- **Trust requirements**: Users must trust the intermediary to maintain integrity\n- **Limited verification**: Third parties cannot independently verify authenticity\n- **Vendor lock-in**: Data is trapped in proprietary systems\n- **High costs**: Intermediaries charge fees for verification services\n\nAqua Protocol solves these problems through:\n\n- **Decentralized verification**: Anyone can verify data integrity cryptographically\n- **Mathematical certainty**: Cryptographic proofs replace trust requirements\n- **Immutable history**: Complete audit trails that cannot be altered\n- **Open standards**: Platform-agnostic verification using standard algorithms\n- **Cost efficiency**: Reduced reliance on intermediaries and manual processes\n\n## Core Capabilities\n\n### Tamper-Proof Records\nOnce data is recorded in an Aqua chain, modifications become immediately detectable. Cryptographic hashes ensure that any change to content, timestamps, or signatures invalidates the chain, providing mathematical proof of tampering.\n\n### Blockchain Timestamping\nEvery critical revision can be anchored to Ethereum, Nostr, or TSA timestamping services. This provides cryptographic proof of when data existed, eliminating disputes about timing and preventing backdating.\n\n### Multi-Party Signatures\nMultiple parties can cryptographically sign revisions, establishing non-repudiation and accountability. Each signature is independently verifiable, proving who authorized what and when.\n\n### Provenance Tracking\nLink revisions create relationships between chains, enabling complex provenance graphs. Track how data flows through systems, who touched it, and what transformations occurred.\n\n### Template-Based Validation\nVersion 4's template system enforces data schemas with JSON Schema validation, ensuring consistent structure across revisions while maintaining cryptographic integrity.\n\n## Application Domains\n\n### Legal and Compliance\nLegal documents, contracts, evidence, regulatory filings, and compliance records require guaranteed integrity and provable timestamps. Aqua Protocol provides:\n- Non-repudiation through cryptographic signatures\n- Defensible timestamps via blockchain anchoring\n- Complete audit trails for investigations\n- Chain of custody for evidence\n- Regulatory compliance documentation\n\n### Supply Chain and Logistics\nProducts moving through complex supply chains need provenance tracking from origin to destination. Aqua Protocol enables:\n- End-to-end traceability from raw materials to consumer\n- Multi-party coordination across manufacturers, distributors, and retailers\n- Authenticity verification to prevent counterfeits\n- Regulatory compliance for food, pharmaceuticals, and other regulated goods\n- Efficient recalls with precise product tracking\n\n### Identity and Credentials\nEducational institutions, professional organizations, and governments issue credentials that need verification. Aqua Protocol provides:\n- Instant verification of diplomas, certificates, and licenses\n- Revocation capability when credentials expire or are withdrawn\n- Portable credentials that individuals control\n- Elimination of credential fraud\n- Reduced verification costs and time\n\n### Financial Services\nFinancial institutions require immutable audit trails for transactions, statements, and regulatory reports. Aqua Protocol offers:\n- Tamper-proof financial records\n- Provable submission timing for regulatory filings\n- Multi-party approval workflows for transactions\n- Audit-ready documentation for compliance\n- Fraud prevention through verification\n\n### Healthcare\nPatient records, clinical trial data, and medical device tracking demand integrity and privacy. Aqua Protocol enables:\n- Verifiable medical records that patients control\n- Clinical trial data integrity for regulatory approval\n- Medical device tracking and recall management\n- HIPAA-compliant audit trails\n- Secure sharing between healthcare providers\n\n### Intellectual Property\nPatents, copyrights, trade secrets, and creative works benefit from provable timestamps. Aqua Protocol provides:\n- Proof of creation date for prior art disputes\n- Version tracking for creative works\n- Licensing and royalty audit trails\n- Collaborative creation with attribution\n- Protection against IP theft\n\n## Industry-Specific Solutions\n\n### Manufacturing\n- Bill of materials with cryptographic proof\n- Quality control inspection records\n- Product genealogy from components to finished goods\n- Supplier certification verification\n- Warranty claim documentation\n\n### Real Estate\n- Property title chains with verified transfers\n- Lease agreements with multi-party signatures\n- Inspection reports with tamper-proof timestamps\n- Escrow milestone documentation\n- Regulatory compliance for transactions\n\n### Energy and Utilities\n- Renewable energy certificate tracking\n- Carbon credit provenance verification\n- Utility meter reading audit trails\n- Regulatory compliance documentation\n- Asset maintenance history\n\n### Government and Public Sector\n- Passport and identity document verification\n- Professional license tracking\n- Permit and certification issuance\n- Public records integrity\n- Voting and election audit trails\n\n## Technical Flexibility\n\nAqua Protocol adapts to diverse requirements through:\n\n- **Multiple revision types**: Objects, templates, signatures, witnesses, and links\n- **Flexible signing methods**: RSA, Ethereum EIP-191, DID:JWS, and more\n- **Choice of witnesses**: Ethereum (mainnet, testnets), Nostr, TSA\n- **Scalar or tree methods**: Optimize for simplicity or selective disclosure\n- **Cross-platform SDKs**: Rust with WASM, JavaScript/TypeScript for any environment\n- **Template customization**: Define domain-specific schemas with JSON Schema\n\n## Getting Started\n\nExplore the detailed use cases below to understand how Aqua Protocol applies to your specific domain:\n\n\u003cCardGrid cols={2}\u003e\n  \u003cCard title=\"Document Verification\" icon=\"file-check\" href=\"/use_cases/document-verification\"\u003e\n    Ensure document authenticity and integrity with cryptographic verification. Learn how legal firms, businesses, educational institutions, and government agencies use Aqua Protocol for tamper-proof document management.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Supply Chain Tracking\" icon=\"truck\" href=\"/use_cases/supply-chain\"\u003e\n    Track products through the supply chain with end-to-end transparency. Discover how food, pharmaceutical, manufacturing, and logistics companies implement provenance verification.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Identity Attestation\" icon=\"id-card\" href=\"/use_cases/identity-attestation\"\u003e\n    Implement secure identity verification and credential attestation. Explore how credentials, certifications, and identity documents gain instant verifiability.\n  \u003c/Card\u003e\n\n  \u003cCard title=\"Examples \u0026 Tutorials\" icon=\"graduation-cap\" href=\"/use_cases/examples\"\u003e\n    Practical examples and step-by-step tutorials for building with Aqua Protocol. Get hands-on experience implementing real-world use cases.\n  \u003c/Card\u003e\n\u003c/CardGrid\u003e\n\n## Common Patterns\n\nRegardless of industry, Aqua Protocol implementations typically follow these patterns:\n\n### 1. Genesis Creation\nStart by creating the initial revision with core data:\n- Document content, product information, or credential details\n- Relevant metadata (timestamps, identifiers, classifications)\n- Template reference for structured data validation\n\n### 2. Multi-Party Signatures\nCollect signatures from relevant parties:\n- Creator signs to establish authenticity\n- Reviewers sign to indicate approval\n- Authorities sign for official endorsement\n- Each signature adds non-repudiation\n\n### 3. Blockchain Witnessing\nAnchor critical revisions to blockchain:\n- Provides tamper-proof timestamps\n- Prevents backdating of revisions\n- Enables independent verification\n- Satisfies regulatory requirements\n\n### 4. Provenance Linking\nConnect related chains:\n- Link components to assemblies\n- Reference supporting documents\n- Establish dependencies between datasets\n- Create complex verification graphs\n\n### 5. Long-Term Verification\nMaintain verifiability over time:\n- Store Aqua chains separately from content\n- Distribute chains to all stakeholders\n- Periodically verify chain integrity\n- Update verification tools as needed\n\n## Benefits Across All Use Cases\n\n### Trust Without Intermediaries\nCryptographic verification replaces trust in centralized authorities. Anyone can independently verify authenticity, reducing costs and increasing accessibility.\n\n### Regulatory Compliance\nImmutable audit trails satisfy regulators across industries. From SOX compliance in finance to HIPAA in healthcare, Aqua Protocol provides defensible documentation.\n\n### Cost Reduction\nAutomated verification eliminates manual processes, reduces fraud losses, speeds up operations, and removes intermediary fees.\n\n### Enhanced Security\nCryptographic primitives (SHA3-256, ECDSA) provide security that cannot be achieved with traditional databases. Even system administrators cannot forge valid chains.\n\n### Future-Proof Design\nProtocol versioning, extensible revision types, and blockchain-agnostic witnessing ensure Aqua chains remain verifiable as technology evolves.\n\n## Next Steps\n\nReady to implement Aqua Protocol for your use case?\n\n- Review the detailed use case documentation above\n- Check out the [Quick Start Guide](/quick-start) for hands-on implementation\n- Explore the [Schema Reference](/schema_reference/introduction) for technical specifications\n- Choose your SDK: [Rust (v4)](/previous_versions/version_4/introduction) or [JavaScript (v3)](/previous_versions/version_3/introduction)\n"])</script><script>self.__next_f.push([1,"3d:T40fa,"])</script><script>self.__next_f.push([1,"\n# Supply Chain Tracking\n\nAqua Protocol provides cryptographic provenance tracking for supply chain operations, enabling end-to-end traceability from raw materials to finished products. Each step in the supply chain is recorded with immutable timestamps, creating a verifiable chain of custody that proves authenticity and tracks movement across multiple parties.\n\n## Core Capabilities\n\n### End-to-End Traceability\nTrack products from origin to destination with cryptographic proof at each step. Every transfer, transformation, and quality check is recorded in an immutable chain, creating a complete product history that can be independently verified.\n\n### Multi-Party Coordination\nSupply chains involve manufacturers, distributors, retailers, regulators, and consumers. Aqua Protocol enables all parties to contribute to the chain while maintaining data integrity, without requiring a central authority.\n\n### Provenance Verification\nProve the origin and authenticity of products cryptographically. Consumers and businesses can verify that products are genuine, sourced ethically, and meet quality standards without trusting intermediaries.\n\n### Real-Time Transparency\nAll stakeholders can verify the current state and history of products in real-time. Blockchain witnesses provide tamper-proof timestamps, ensuring accurate tracking of supply chain events as they occur.\n\n## Use Cases by Industry\n\n### Food \u0026 Agriculture\n\n**Farm-to-Table Tracking**\n- Record harvest timestamps and origin farm information\n- Track temperature and storage conditions during transport\n- Prove organic certification and farming practices\n- Enable consumers to verify food provenance via QR codes\n\n**Quality Assurance**\n- Document quality inspections at each stage\n- Track batch numbers for recall management\n- Record processing and packaging timestamps\n- Maintain cold chain compliance records\n\n**Regulatory Compliance**\n- Demonstrate compliance with food safety regulations\n- Provide audit trails for health inspectors\n- Track certifications (organic, fair trade, kosher, halal)\n- Prove country of origin for import/export\n\n**Recall Management**\n- Identify affected batches immediately\n- Trace contamination to specific sources\n- Notify all parties in distribution chain\n- Minimize recall scope with precise tracking\n\n### Pharmaceuticals\n\n**Drug Authentication**\n- Prevent counterfeit medications from entering supply chain\n- Verify pharmaceutical manufacturer and production batch\n- Track medication from factory to pharmacy\n- Enable patients to verify medication authenticity\n\n**Cold Chain Management**\n- Record temperature at every transport stage\n- Prove compliance with storage requirements\n- Alert stakeholders to temperature excursions\n- Maintain regulatory compliance documentation\n\n**Clinical Trial Management**\n- Track investigational drugs through trial phases\n- Document chain of custody for trial materials\n- Prove compliance with trial protocols\n- Maintain audit trails for regulatory submissions\n\n**Regulatory Reporting**\n- Demonstrate compliance with pharmaceutical regulations\n- Track serialization and aggregation data\n- Provide audit trails for FDA, EMA, and other authorities\n- Support Drug Supply Chain Security Act (DSCSA) compliance\n\n### Manufacturing\n\n**Component Traceability**\n- Track components from suppliers to assembly\n- Verify authenticity of critical components\n- Manage bill of materials with cryptographic proof\n- Prevent counterfeit parts from entering production\n\n**Quality Control**\n- Record inspection results at each manufacturing stage\n- Document rework and quality issues\n- Track serial numbers through production process\n- Maintain statistical process control data\n\n**Product Genealogy**\n- Build complete product history from raw materials\n- Track which components went into which products\n- Enable root cause analysis for defects\n- Support warranty claims with production records\n\n**Supplier Management**\n- Verify supplier certifications and compliance\n- Track supplier performance metrics\n- Prove ethical sourcing practices\n- Manage supplier risk with documented history\n\n### Logistics \u0026 Distribution\n\n**Shipment Tracking**\n- Record custody transfers between carriers\n- Timestamp loading and unloading events\n- Track location updates throughout journey\n- Prove on-time delivery with blockchain witnesses\n\n**Customs and Border Control**\n- Provide immutable documentation for customs\n- Prove product origin for tariff classification\n- Streamline border crossings with verified data\n- Reduce customs delays with cryptographic proof\n\n**Last-Mile Delivery**\n- Verify final delivery to customer\n- Timestamp customer receipt\n- Prove condition at delivery\n- Enable dispute resolution with documented proof\n\n**Warehouse Management**\n- Track inventory movements within facilities\n- Record picking, packing, and shipping operations\n- Maintain lot and serial number traceability\n- Integrate with ERP systems for real-time updates\n\n## Key Benefits\n\n### Eliminate Counterfeits\nCounterfeit products cost industries billions annually. Aqua Protocol makes counterfeiting economically infeasible by requiring cryptographic proof at each supply chain step. Fake products cannot produce valid Aqua chains, making them easily identifiable.\n\n### Improve Recall Efficiency\nWhen safety issues arise, rapid recall is critical. Aqua Protocol enables precise identification of affected products, reducing recall scope and cost. Complete provenance data shows exactly which batches are impacted and where they were distributed.\n\n### Increase Consumer Trust\nConsumers increasingly demand transparency about product origins and manufacturing. Scannable QR codes linked to Aqua chains let customers verify authenticity, ethical sourcing, and quality standards, building brand trust.\n\n### Streamline Compliance\nRegulatory compliance requires extensive documentation and audit trails. Aqua Protocol automatically creates tamper-proof records that satisfy regulators, reducing compliance costs and audit preparation time.\n\n### Enable Ethical Sourcing\nProve that products meet ethical standards for labor practices, environmental impact, and sustainable sourcing. Immutable records prevent \"ethics washing\" and provide verifiable proof of responsible practices.\n\n### Reduce Liability\nComplete documentation of supply chain events reduces liability exposure. When disputes arise, cryptographic proof shows exactly what happened, when, and who was responsible.\n\n## How It Works\n\n### 1. Product Registration\nWhen a product enters the supply chain:\n- Genesis revision is created with product identifier\n- Initial metadata recorded (SKU, batch number, origin)\n- Manufacturer signs the genesis revision\n- Signature is witnessed on blockchain for timestamp proof\n- Product receives unique Aqua chain\n\n### 2. Supply Chain Events\nAs the product moves through the supply chain:\n- Each event creates a new revision (transfer, inspection, processing)\n- Event data includes timestamp, location, responsible party\n- Each party signs their contributions to the chain\n- Critical events are witnessed for regulatory proof\n- Chain grows to include complete product history\n\n### 3. Multi-Party Signatures\nWhen custody transfers between parties:\n- Sending party signs transfer revision\n- Receiving party verifies and countersigns\n- Both signatures reference the same state\n- Blockchain witness timestamps the transfer\n- Prevents disputes about transfer timing or condition\n\n### 4. Verification\nAt any point, stakeholders can verify:\n- Scan product QR code to retrieve Aqua chain\n- Verify all cryptographic signatures\n- Check blockchain witnesses for timestamps\n- Validate entire chain integrity\n- Confirm product authenticity and history\n\n## Real-World Scenarios\n\n### Scenario 1: Pharmaceutical Supply Chain\n\n**Challenge**: A pharmaceutical company must track medication from manufacturing through distribution to pharmacies while maintaining cold chain compliance and preventing counterfeits.\n\n**Solution**:\n- Each medication batch gets genesis revision when manufactured\n- Quality control inspections add signed revisions\n- Temperature monitors record readings as revisions\n- Each distributor transfer is signed by both parties\n- Pharmacies verify medication authenticity by scanning\n- Regulators can audit complete chain from manufacturer to patient\n\n**Benefits**: Counterfeit prevention, cold chain compliance, regulatory audit trails, patient safety, streamlined recalls\n\n### Scenario 2: Organic Food Certification\n\n**Challenge**: Consumers want to verify that \"organic\" products are genuinely organic from farm to store, but current systems rely on paper certificates that can be forged.\n\n**Solution**:\n- Farms create genesis revision with organic certification\n- Certification body signs the certification revision\n- Each processing step is documented and signed\n- Distributors add transport and storage revisions\n- Retailers witness final product placement\n- Consumers scan QR code to verify organic provenance\n\n**Benefits**: Verified organic claims, consumer confidence, brand differentiation, premium pricing justification\n\n### Scenario 3: Automotive Parts Traceability\n\n**Challenge**: An automotive manufacturer needs to track critical safety components through multiple supplier tiers to ensure authenticity and enable recalls if defects are discovered.\n\n**Solution**:\n- Tier 3 supplier creates genesis for raw materials\n- Tier 2 supplier adds processing revisions with quality checks\n- Tier 1 supplier integrates into assemblies with link revisions\n- OEM manufacturer links assemblies into final vehicles\n- Each VIN is linked to component Aqua chains\n- Defective component traced to exact source and all affected vehicles\n\n**Benefits**: Counterfeit prevention, rapid recall execution, root cause analysis, supplier accountability, quality improvement\n\n### Scenario 4: Coffee Supply Chain Transparency\n\n**Challenge**: Coffee roasters want to prove fair trade practices and sustainable sourcing to increasingly conscious consumers, but existing certification systems are opaque.\n\n**Solution**:\n- Coffee farmers create genesis with harvest data\n- Fair trade auditor signs certification revision\n- Exporters document transport and quality grading\n- Importers add customs and warehousing data\n- Roasters link to final packaged products\n- Consumers scan bags to see complete farm-to-cup journey\n\n**Benefits**: Verified ethical sourcing, consumer transparency, premium pricing, farmer accountability, brand storytelling\n\n## Integration Patterns\n\n### ERP Systems\nIntegrate Aqua Protocol with enterprise resource planning systems to automatically create revisions for inventory movements, production events, and quality checks.\n\n**Implementation**:\n- ERP triggers Aqua revision creation on key events\n- Product master data becomes genesis revision\n- Manufacturing orders add production revisions\n- Shipping orders create transfer revisions\n- Quality inspections add signed quality revisions\n\n### IoT Sensors\nConnect IoT devices to automatically record sensor data as revisions:\n- Temperature sensors for cold chain monitoring\n- GPS trackers for location updates\n- RFID readers for automated checkpoint scanning\n- Weight scales for quantity verification\n- Quality inspection equipment for automated testing\n\n### Blockchain Oracles\nUse blockchain oracles to feed external data into supply chains:\n- Weather data for agricultural provenance\n- Customs clearance status\n- Regulatory database lookups\n- Third-party certification verification\n- Market pricing for timestamp-based valuation\n\n### Consumer Apps\nBuild consumer-facing applications that verify products:\n- Mobile apps with QR code scanning\n- Web portals for product history viewing\n- Voice assistants for product authentication\n- Smart packaging with NFC chips\n- Augmented reality product storytelling\n\n### Supplier Portals\nCreate portals for suppliers to contribute to chains:\n- Self-service revision creation\n- Document upload and signature\n- Certification management\n- Quality data submission\n- Real-time status visibility\n\n## Best Practices\n\n### Genesis Creation\n- Create genesis as early as possible in supply chain\n- Include comprehensive product metadata\n- Use template revisions for standardized data\n- Sign genesis immediately to establish authenticity\n- Witness genesis for high-value or regulated products\n\n### Event Granularity\n- Balance detail with practical overhead\n- Record all custody transfers\n- Document critical quality checkpoints\n- Capture regulatory compliance events\n- Skip routine events that don't add value\n\n### Multi-Party Coordination\n- Establish clear protocols for handoffs\n- Both parties must sign custody transfers\n- Verify previous signatures before adding new ones\n- Communicate chain updates to all stakeholders\n- Maintain consistent timestamp standards\n\n### Data Privacy\n- Aqua chains store hashes, not sensitive content\n- Use tree method for selective disclosure\n- Share chains only with authorized parties\n- Consider what metadata is included\n- Use private witnesses if public timestamps are problematic\n\n### Verification Strategy\n- Verify products at key checkpoints\n- Check complete chain for high-value items\n- Spot-check for routine items\n- Validate blockchain witnesses for critical events\n- Train staff on verification procedures\n\n### Batch Operations\n- Use batch witnessing to reduce costs\n- Group similar products in same witness transaction\n- Balance cost savings with timestamp precision\n- Implement automated batching in integration systems\n- Monitor batch sizes for optimization\n\n## Technical Advantages\n\n### Scalability\n- Object revisions scale to billions of products\n- Link revisions enable hierarchical organization\n- Batch witnessing reduces blockchain costs\n- Offline verification after chain retrieval\n- Distributed storage prevents bottlenecks\n\n### Interoperability\n- JSON-based format for easy integration\n- Multiple SDK options (Rust, JavaScript)\n- Standard cryptographic primitives\n- Platform-agnostic verification\n- Compatible with existing supply chain systems\n\n### Flexibility\n- Template system for industry-specific schemas\n- Custom revision types for unique requirements\n- Multiple signature methods for different parties\n- Choice of witnessing networks\n- Extensible for future needs\n\n### Security\n- SHA3-256 hashing prevents collision attacks\n- ECDSA signatures provide strong authentication\n- Blockchain anchoring prevents backdating\n- Merkle trees enable selective disclosure\n- Cryptographic proof instead of trust\n\n## Common Questions\n\n**Q: How do we handle products without digital interfaces?**\nA: Use QR codes, NFC tags, or printed Aqua chain identifiers on packaging. The Aqua chain exists independently of the physical product. Low-cost printed codes work for most products.\n\n**Q: What if a supply chain participant doesn't want to use Aqua Protocol?**\nA: The chain can continue without them, but their contribution won't have cryptographic proof. This creates accountability - participants who don't use Aqua Protocol are less trustworthy. Market pressure encourages adoption.\n\n**Q: How do we handle returns and reverse logistics?**\nA: Add revision documenting the return event, including reason and condition. The chain naturally grows to include forward and reverse movements, maintaining complete product history.\n\n**Q: Can we integrate with existing traceability systems?**\nA: Yes. Aqua Protocol can wrap existing systems, adding cryptographic proof to current tracking data. Legacy system data can be hashed and stored in revisions.\n\n**Q: What about supply chain privacy?**\nA: Aqua chains contain only hashes by default, not business-sensitive data. Share chains selectively with authorized parties. Use tree method for selective disclosure of specific fields to certain stakeholders.\n\n**Q: How do we handle lost or damaged products?**\nA: Add revision documenting loss or damage event with relevant details. The Aqua chain preserves the history up to that point, supporting insurance claims and investigations.\n\n**Q: What if blockchain networks fail?**\nA: Verification of existing chains works offline using cryptographic signatures. Only new witnessing requires blockchain access. Historical witnesses remain provable through blockchain transaction records.\n\n## See Also\n\n- [Document Verification](/use_cases/document-verification) - Apply similar techniques to documents\n- [Identity Attestation](/use_cases/identity-attestation) - Verify credentials and certifications\n- [Quick Start](/quick-start) - Get started with supply chain tracking\n- [Schema Reference](/schema_reference/introduction) - Technical specifications\n"])</script><script>self.__next_f.push([1,"3e:T40fa,"])</script><script>self.__next_f.push([1,"\n# Supply Chain Tracking\n\nAqua Protocol provides cryptographic provenance tracking for supply chain operations, enabling end-to-end traceability from raw materials to finished products. Each step in the supply chain is recorded with immutable timestamps, creating a verifiable chain of custody that proves authenticity and tracks movement across multiple parties.\n\n## Core Capabilities\n\n### End-to-End Traceability\nTrack products from origin to destination with cryptographic proof at each step. Every transfer, transformation, and quality check is recorded in an immutable chain, creating a complete product history that can be independently verified.\n\n### Multi-Party Coordination\nSupply chains involve manufacturers, distributors, retailers, regulators, and consumers. Aqua Protocol enables all parties to contribute to the chain while maintaining data integrity, without requiring a central authority.\n\n### Provenance Verification\nProve the origin and authenticity of products cryptographically. Consumers and businesses can verify that products are genuine, sourced ethically, and meet quality standards without trusting intermediaries.\n\n### Real-Time Transparency\nAll stakeholders can verify the current state and history of products in real-time. Blockchain witnesses provide tamper-proof timestamps, ensuring accurate tracking of supply chain events as they occur.\n\n## Use Cases by Industry\n\n### Food \u0026 Agriculture\n\n**Farm-to-Table Tracking**\n- Record harvest timestamps and origin farm information\n- Track temperature and storage conditions during transport\n- Prove organic certification and farming practices\n- Enable consumers to verify food provenance via QR codes\n\n**Quality Assurance**\n- Document quality inspections at each stage\n- Track batch numbers for recall management\n- Record processing and packaging timestamps\n- Maintain cold chain compliance records\n\n**Regulatory Compliance**\n- Demonstrate compliance with food safety regulations\n- Provide audit trails for health inspectors\n- Track certifications (organic, fair trade, kosher, halal)\n- Prove country of origin for import/export\n\n**Recall Management**\n- Identify affected batches immediately\n- Trace contamination to specific sources\n- Notify all parties in distribution chain\n- Minimize recall scope with precise tracking\n\n### Pharmaceuticals\n\n**Drug Authentication**\n- Prevent counterfeit medications from entering supply chain\n- Verify pharmaceutical manufacturer and production batch\n- Track medication from factory to pharmacy\n- Enable patients to verify medication authenticity\n\n**Cold Chain Management**\n- Record temperature at every transport stage\n- Prove compliance with storage requirements\n- Alert stakeholders to temperature excursions\n- Maintain regulatory compliance documentation\n\n**Clinical Trial Management**\n- Track investigational drugs through trial phases\n- Document chain of custody for trial materials\n- Prove compliance with trial protocols\n- Maintain audit trails for regulatory submissions\n\n**Regulatory Reporting**\n- Demonstrate compliance with pharmaceutical regulations\n- Track serialization and aggregation data\n- Provide audit trails for FDA, EMA, and other authorities\n- Support Drug Supply Chain Security Act (DSCSA) compliance\n\n### Manufacturing\n\n**Component Traceability**\n- Track components from suppliers to assembly\n- Verify authenticity of critical components\n- Manage bill of materials with cryptographic proof\n- Prevent counterfeit parts from entering production\n\n**Quality Control**\n- Record inspection results at each manufacturing stage\n- Document rework and quality issues\n- Track serial numbers through production process\n- Maintain statistical process control data\n\n**Product Genealogy**\n- Build complete product history from raw materials\n- Track which components went into which products\n- Enable root cause analysis for defects\n- Support warranty claims with production records\n\n**Supplier Management**\n- Verify supplier certifications and compliance\n- Track supplier performance metrics\n- Prove ethical sourcing practices\n- Manage supplier risk with documented history\n\n### Logistics \u0026 Distribution\n\n**Shipment Tracking**\n- Record custody transfers between carriers\n- Timestamp loading and unloading events\n- Track location updates throughout journey\n- Prove on-time delivery with blockchain witnesses\n\n**Customs and Border Control**\n- Provide immutable documentation for customs\n- Prove product origin for tariff classification\n- Streamline border crossings with verified data\n- Reduce customs delays with cryptographic proof\n\n**Last-Mile Delivery**\n- Verify final delivery to customer\n- Timestamp customer receipt\n- Prove condition at delivery\n- Enable dispute resolution with documented proof\n\n**Warehouse Management**\n- Track inventory movements within facilities\n- Record picking, packing, and shipping operations\n- Maintain lot and serial number traceability\n- Integrate with ERP systems for real-time updates\n\n## Key Benefits\n\n### Eliminate Counterfeits\nCounterfeit products cost industries billions annually. Aqua Protocol makes counterfeiting economically infeasible by requiring cryptographic proof at each supply chain step. Fake products cannot produce valid Aqua chains, making them easily identifiable.\n\n### Improve Recall Efficiency\nWhen safety issues arise, rapid recall is critical. Aqua Protocol enables precise identification of affected products, reducing recall scope and cost. Complete provenance data shows exactly which batches are impacted and where they were distributed.\n\n### Increase Consumer Trust\nConsumers increasingly demand transparency about product origins and manufacturing. Scannable QR codes linked to Aqua chains let customers verify authenticity, ethical sourcing, and quality standards, building brand trust.\n\n### Streamline Compliance\nRegulatory compliance requires extensive documentation and audit trails. Aqua Protocol automatically creates tamper-proof records that satisfy regulators, reducing compliance costs and audit preparation time.\n\n### Enable Ethical Sourcing\nProve that products meet ethical standards for labor practices, environmental impact, and sustainable sourcing. Immutable records prevent \"ethics washing\" and provide verifiable proof of responsible practices.\n\n### Reduce Liability\nComplete documentation of supply chain events reduces liability exposure. When disputes arise, cryptographic proof shows exactly what happened, when, and who was responsible.\n\n## How It Works\n\n### 1. Product Registration\nWhen a product enters the supply chain:\n- Genesis revision is created with product identifier\n- Initial metadata recorded (SKU, batch number, origin)\n- Manufacturer signs the genesis revision\n- Signature is witnessed on blockchain for timestamp proof\n- Product receives unique Aqua chain\n\n### 2. Supply Chain Events\nAs the product moves through the supply chain:\n- Each event creates a new revision (transfer, inspection, processing)\n- Event data includes timestamp, location, responsible party\n- Each party signs their contributions to the chain\n- Critical events are witnessed for regulatory proof\n- Chain grows to include complete product history\n\n### 3. Multi-Party Signatures\nWhen custody transfers between parties:\n- Sending party signs transfer revision\n- Receiving party verifies and countersigns\n- Both signatures reference the same state\n- Blockchain witness timestamps the transfer\n- Prevents disputes about transfer timing or condition\n\n### 4. Verification\nAt any point, stakeholders can verify:\n- Scan product QR code to retrieve Aqua chain\n- Verify all cryptographic signatures\n- Check blockchain witnesses for timestamps\n- Validate entire chain integrity\n- Confirm product authenticity and history\n\n## Real-World Scenarios\n\n### Scenario 1: Pharmaceutical Supply Chain\n\n**Challenge**: A pharmaceutical company must track medication from manufacturing through distribution to pharmacies while maintaining cold chain compliance and preventing counterfeits.\n\n**Solution**:\n- Each medication batch gets genesis revision when manufactured\n- Quality control inspections add signed revisions\n- Temperature monitors record readings as revisions\n- Each distributor transfer is signed by both parties\n- Pharmacies verify medication authenticity by scanning\n- Regulators can audit complete chain from manufacturer to patient\n\n**Benefits**: Counterfeit prevention, cold chain compliance, regulatory audit trails, patient safety, streamlined recalls\n\n### Scenario 2: Organic Food Certification\n\n**Challenge**: Consumers want to verify that \"organic\" products are genuinely organic from farm to store, but current systems rely on paper certificates that can be forged.\n\n**Solution**:\n- Farms create genesis revision with organic certification\n- Certification body signs the certification revision\n- Each processing step is documented and signed\n- Distributors add transport and storage revisions\n- Retailers witness final product placement\n- Consumers scan QR code to verify organic provenance\n\n**Benefits**: Verified organic claims, consumer confidence, brand differentiation, premium pricing justification\n\n### Scenario 3: Automotive Parts Traceability\n\n**Challenge**: An automotive manufacturer needs to track critical safety components through multiple supplier tiers to ensure authenticity and enable recalls if defects are discovered.\n\n**Solution**:\n- Tier 3 supplier creates genesis for raw materials\n- Tier 2 supplier adds processing revisions with quality checks\n- Tier 1 supplier integrates into assemblies with link revisions\n- OEM manufacturer links assemblies into final vehicles\n- Each VIN is linked to component Aqua chains\n- Defective component traced to exact source and all affected vehicles\n\n**Benefits**: Counterfeit prevention, rapid recall execution, root cause analysis, supplier accountability, quality improvement\n\n### Scenario 4: Coffee Supply Chain Transparency\n\n**Challenge**: Coffee roasters want to prove fair trade practices and sustainable sourcing to increasingly conscious consumers, but existing certification systems are opaque.\n\n**Solution**:\n- Coffee farmers create genesis with harvest data\n- Fair trade auditor signs certification revision\n- Exporters document transport and quality grading\n- Importers add customs and warehousing data\n- Roasters link to final packaged products\n- Consumers scan bags to see complete farm-to-cup journey\n\n**Benefits**: Verified ethical sourcing, consumer transparency, premium pricing, farmer accountability, brand storytelling\n\n## Integration Patterns\n\n### ERP Systems\nIntegrate Aqua Protocol with enterprise resource planning systems to automatically create revisions for inventory movements, production events, and quality checks.\n\n**Implementation**:\n- ERP triggers Aqua revision creation on key events\n- Product master data becomes genesis revision\n- Manufacturing orders add production revisions\n- Shipping orders create transfer revisions\n- Quality inspections add signed quality revisions\n\n### IoT Sensors\nConnect IoT devices to automatically record sensor data as revisions:\n- Temperature sensors for cold chain monitoring\n- GPS trackers for location updates\n- RFID readers for automated checkpoint scanning\n- Weight scales for quantity verification\n- Quality inspection equipment for automated testing\n\n### Blockchain Oracles\nUse blockchain oracles to feed external data into supply chains:\n- Weather data for agricultural provenance\n- Customs clearance status\n- Regulatory database lookups\n- Third-party certification verification\n- Market pricing for timestamp-based valuation\n\n### Consumer Apps\nBuild consumer-facing applications that verify products:\n- Mobile apps with QR code scanning\n- Web portals for product history viewing\n- Voice assistants for product authentication\n- Smart packaging with NFC chips\n- Augmented reality product storytelling\n\n### Supplier Portals\nCreate portals for suppliers to contribute to chains:\n- Self-service revision creation\n- Document upload and signature\n- Certification management\n- Quality data submission\n- Real-time status visibility\n\n## Best Practices\n\n### Genesis Creation\n- Create genesis as early as possible in supply chain\n- Include comprehensive product metadata\n- Use template revisions for standardized data\n- Sign genesis immediately to establish authenticity\n- Witness genesis for high-value or regulated products\n\n### Event Granularity\n- Balance detail with practical overhead\n- Record all custody transfers\n- Document critical quality checkpoints\n- Capture regulatory compliance events\n- Skip routine events that don't add value\n\n### Multi-Party Coordination\n- Establish clear protocols for handoffs\n- Both parties must sign custody transfers\n- Verify previous signatures before adding new ones\n- Communicate chain updates to all stakeholders\n- Maintain consistent timestamp standards\n\n### Data Privacy\n- Aqua chains store hashes, not sensitive content\n- Use tree method for selective disclosure\n- Share chains only with authorized parties\n- Consider what metadata is included\n- Use private witnesses if public timestamps are problematic\n\n### Verification Strategy\n- Verify products at key checkpoints\n- Check complete chain for high-value items\n- Spot-check for routine items\n- Validate blockchain witnesses for critical events\n- Train staff on verification procedures\n\n### Batch Operations\n- Use batch witnessing to reduce costs\n- Group similar products in same witness transaction\n- Balance cost savings with timestamp precision\n- Implement automated batching in integration systems\n- Monitor batch sizes for optimization\n\n## Technical Advantages\n\n### Scalability\n- Object revisions scale to billions of products\n- Link revisions enable hierarchical organization\n- Batch witnessing reduces blockchain costs\n- Offline verification after chain retrieval\n- Distributed storage prevents bottlenecks\n\n### Interoperability\n- JSON-based format for easy integration\n- Multiple SDK options (Rust, JavaScript)\n- Standard cryptographic primitives\n- Platform-agnostic verification\n- Compatible with existing supply chain systems\n\n### Flexibility\n- Template system for industry-specific schemas\n- Custom revision types for unique requirements\n- Multiple signature methods for different parties\n- Choice of witnessing networks\n- Extensible for future needs\n\n### Security\n- SHA3-256 hashing prevents collision attacks\n- ECDSA signatures provide strong authentication\n- Blockchain anchoring prevents backdating\n- Merkle trees enable selective disclosure\n- Cryptographic proof instead of trust\n\n## Common Questions\n\n**Q: How do we handle products without digital interfaces?**\nA: Use QR codes, NFC tags, or printed Aqua chain identifiers on packaging. The Aqua chain exists independently of the physical product. Low-cost printed codes work for most products.\n\n**Q: What if a supply chain participant doesn't want to use Aqua Protocol?**\nA: The chain can continue without them, but their contribution won't have cryptographic proof. This creates accountability - participants who don't use Aqua Protocol are less trustworthy. Market pressure encourages adoption.\n\n**Q: How do we handle returns and reverse logistics?**\nA: Add revision documenting the return event, including reason and condition. The chain naturally grows to include forward and reverse movements, maintaining complete product history.\n\n**Q: Can we integrate with existing traceability systems?**\nA: Yes. Aqua Protocol can wrap existing systems, adding cryptographic proof to current tracking data. Legacy system data can be hashed and stored in revisions.\n\n**Q: What about supply chain privacy?**\nA: Aqua chains contain only hashes by default, not business-sensitive data. Share chains selectively with authorized parties. Use tree method for selective disclosure of specific fields to certain stakeholders.\n\n**Q: How do we handle lost or damaged products?**\nA: Add revision documenting loss or damage event with relevant details. The Aqua chain preserves the history up to that point, supporting insurance claims and investigations.\n\n**Q: What if blockchain networks fail?**\nA: Verification of existing chains works offline using cryptographic signatures. Only new witnessing requires blockchain access. Historical witnesses remain provable through blockchain transaction records.\n\n## See Also\n\n- [Document Verification](/use_cases/document-verification) - Apply similar techniques to documents\n- [Identity Attestation](/use_cases/identity-attestation) - Verify credentials and certifications\n- [Quick Start](/quick-start) - Get started with supply chain tracking\n- [Schema Reference](/schema_reference/introduction) - Technical specifications\n"])</script><script>self.__next_f.push([1,"c:[\"$\",\"$e\",null,{\"fallback\":[\"$\",\"$L14\",null,{}],\"children\":[[\"$\",\"$L15\",null,{\"header\":[\"$\",\"$L16\",null,{\"currentVersion\":\"v4.0.0\",\"versions\":[\"v1.1.0\",\"v2.0.2\",\"v3.0.2\",\"v4.0.0\"],\"config\":\"$0:f:0:1:0:props:children:1:props:children:props:children:props:config\"}],\"docs\":[{\"slug\":\"schema-reference/aqua-tree\",\"filePath\":\"schema-reference/aqua-tree\",\"title\":\"Aqua Tree\",\"meta\":{\"title\":\"Aqua Tree\",\"description\":\"The root data structure containing revisions and metadata\",\"sidebar_position\":1,\"content\":\"$17\",\"reading_time\":5,\"word_count\":888},\"content\":\"$18\",\"categoryLabel\":\"Schema Reference\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"book\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"welcome\",\"filePath\":\"welcome\",\"title\":\"Welcome to Aqua Protocol\",\"meta\":{\"title\":\"Welcome to Aqua Protocol\",\"description\":\"Account \u0026 verify data in seconds using cryptographic proof\",\"icon\":\"door-open\",\"sidebar_position\":1,\"content\":\"$19\",\"reading_time\":5,\"word_count\":823},\"content\":\"$1a\"},{\"slug\":\"quickstart\",\"filePath\":\"quickstart\",\"title\":\"Quick Start\",\"meta\":{\"title\":\"Quick Start\",\"description\":\"This guide will get you up and running with Aqua Protocol quickly. You'll create your first Aqua chain, sign it, and optionally witness it on a blockchain.\",\"icon\":\"rocket\",\"sidebar_position\":2,\"content\":\"$1b\",\"reading_time\":7,\"word_count\":1244},\"content\":\"$1c\"},{\"slug\":\"schema-reference/file-index\",\"filePath\":\"schema-reference/file-index\",\"title\":\"File Index\",\"meta\":{\"title\":\"File Index\",\"description\":\"Mapping content hashes to human-readable filenames\",\"sidebar_position\":2,\"content\":\"$1d\",\"reading_time\":5,\"word_count\":941},\"content\":\"$1e\",\"categoryLabel\":\"Schema Reference\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"book\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"development\",\"filePath\":\"development\",\"title\":\"Development Guide\",\"meta\":{\"title\":\"Development Guide\",\"description\":\"This guide covers everything you need to develop applications with Aqua Protocol, including signing methods, witnessing options, and SDK usage.\",\"icon\":\"code\",\"sidebar_position\":3,\"content\":\"$1f\",\"reading_time\":9,\"word_count\":1674},\"content\":\"$20\"},{\"slug\":\"schema-reference/introduction\",\"filePath\":\"schema-reference/introduction\",\"title\":\"Aqua Protocol Schema Reference \",\"meta\":{\"title\":\"Aqua Protocol Schema Reference \",\"description\":\"Complete technical reference for Aqua Protocol v4\",\"sidebar_position\":3,\"content\":\"$21\",\"reading_time\":8,\"word_count\":1476},\"content\":\"$22\",\"categoryLabel\":\"Schema Reference\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"book\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"version-info\",\"filePath\":\"version-info\",\"title\":\"Version v4 (beta)\",\"meta\":{\"title\":\"Version v4 (beta)\",\"description\":\"Concepts, protocol structure, and getting started with Aqua Protocol v4\",\"sidebar_position\":4,\"icon\":\"git-commit-horizontal\",\"content\":\"$23\",\"reading_time\":4,\"word_count\":686},\"content\":\"$24\"},{\"slug\":\"dev-tools/aqua-cli\",\"filePath\":\"dev-tools/aqua-cli\",\"title\":\"Aqua CLI\",\"meta\":{\"title\":\"Aqua CLI\",\"description\":\"Install a binary for notarization and verification\",\"icon\":\"terminal\",\"content\":\"$25\",\"reading_time\":3,\"word_count\":410},\"content\":\"$26\",\"categoryLabel\":\"Development Tools\",\"categoryPosition\":3,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"wrench\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"dev-tools/aqua-sdk\",\"filePath\":\"dev-tools/aqua-sdk\",\"title\":\"Aqua SDK\",\"meta\":{\"title\":\"Aqua SDK\",\"description\":\"A library for use in a code base for  notarization and verification\",\"icon\":\"code\",\"content\":\"$27\",\"reading_time\":2,\"word_count\":391},\"content\":\"$28\",\"categoryLabel\":\"Development Tools\",\"categoryPosition\":3,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"wrench\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"dev-tools/aquafier-api\",\"filePath\":\"dev-tools/aquafier-api\",\"title\":\"Aquafier API\",\"meta\":{\"title\":\"Aquafier API\",\"description\":\" A http API for notarization and verification \",\"icon\":\"code\",\"content\":\"$29\",\"reading_time\":3,\"word_count\":566},\"content\":\"$2a\",\"categoryLabel\":\"Development Tools\",\"categoryPosition\":3,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"wrench\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/link-revision\",\"filePath\":\"schema-reference/revision/link-revision\",\"title\":\"Link Revision\",\"meta\":{\"title\":\"Link Revision\",\"description\":\"Schema specification for Link Revisions in Aqua Protocol v4\",\"content\":\"$2b\",\"reading_time\":11,\"word_count\":2009},\"content\":\"$2c\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/object-revision\",\"filePath\":\"schema-reference/revision/object-revision\",\"title\":\"Object Revision\",\"meta\":{\"title\":\"Object Revision\",\"description\":\"Schema specification for Object Revisions in Aqua Protocol v4\",\"content\":\"$2d\",\"reading_time\":6,\"word_count\":1048},\"content\":\"$2e\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/revision\",\"filePath\":\"schema-reference/revision/revision\",\"title\":\"Aqua Protocol Revisions\",\"meta\":{\"title\":\"Aqua Protocol Revisions\",\"description\":\"What is a revision , what maked up a revision ?\",\"content\":\"$2f\",\"reading_time\":3,\"word_count\":461},\"content\":\"$30\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/signing-revision\",\"filePath\":\"schema-reference/revision/signing-revision\",\"title\":\"Signature Revision\",\"meta\":{\"title\":\"Signature Revision\",\"description\":\"Schema specification for Signature Revisions in Aqua Protocol v4\",\"content\":\"$31\",\"reading_time\":7,\"word_count\":1393},\"content\":\"$32\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/template-revision\",\"filePath\":\"schema-reference/revision/template-revision\",\"title\":\"Template Revision\",\"meta\":{\"title\":\"Template Revision\",\"description\":\"Schema specification for Template Revisions in Aqua Protocol v4\",\"content\":\"$33\",\"reading_time\":7,\"word_count\":1369},\"content\":\"$34\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"schema-reference/revision/witness-revision\",\"filePath\":\"schema-reference/revision/witness-revision\",\"title\":\"Witness Revision\",\"meta\":{\"title\":\"Witness Revision\",\"description\":\"Schema specification for Witness Revisions in Aqua Protocol v4\",\"content\":\"$35\",\"reading_time\":9,\"word_count\":1682},\"content\":\"$36\",\"categoryLabel\":\"Revision Types\",\"categoryPosition\":4,\"categoryCollapsible\":true,\"categoryCollapsed\":true,\"categoryIcon\":\"$undefined\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"use-cases/document-verification\",\"filePath\":\"use-cases/document-verification\",\"title\":\"Document Verification\",\"meta\":{\"title\":\"Document Verification\",\"description\":\"Aqua Protocol provides tamper-proof verification of document integrity through cryptographic proofs, enabling organizations to authenticate documents without relying on centralized authorities. Every document modification is timestamped and permanently recorded, creating an immutable audit trail.\",\"content\":\"$37\",\"reading_time\":10,\"word_count\":1863},\"content\":\"$38\",\"categoryLabel\":\"Use Cases\",\"categoryPosition\":2,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"lightbulb\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"use-cases/identity-attestation\",\"filePath\":\"use-cases/identity-attestation\",\"title\":\"Identity Attestation\",\"meta\":{\"title\":\"Identity Attestation\",\"description\":\"Establish trust with verifiable self-sovereign identity claims and attestations\",\"content\":\"$39\",\"reading_time\":5,\"word_count\":865},\"content\":\"$3a\",\"categoryLabel\":\"Use Cases\",\"categoryPosition\":2,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"lightbulb\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"use-cases/introduction\",\"filePath\":\"use-cases/introduction\",\"title\":\"Aqua Protocol Use Cases\",\"meta\":{\"title\":\"Aqua Protocol Use Cases\",\"description\":\"Aqua Protocol provides cryptographic verification and provenance tracking for data across diverse industries and applications. By creating immutable chains of revisions with signatures and blockchain anchoring, Aqua enables trust without centralized authorities.\",\"content\":\"$3b\",\"reading_time\":7,\"word_count\":1216},\"content\":\"$3c\",\"categoryLabel\":\"Use Cases\",\"categoryPosition\":2,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"lightbulb\",\"categoryTabGroup\":\"$undefined\"},{\"slug\":\"use-cases/supply-chain\",\"filePath\":\"use-cases/supply-chain\",\"title\":\"Supply Chain Tracking\",\"meta\":{\"title\":\"Supply Chain Tracking\",\"description\":\"End-to-end traceability and provenance verification for supply chain operations\",\"content\":\"$3d\",\"reading_time\":12,\"word_count\":2274},\"content\":\"$3e\",\"categoryLabel\":\"Use Cases\",\"categoryPosition\":2,\"categoryCollapsible\":true,\"categoryCollapsed\":false,\"categoryIcon\":\"lightbulb\",\"categoryTabGroup\":\"$undefined\"}],\"version\":\"v4.0.0\",\"content\":\"$L3f\",\"toc\":\"$L40\",\"config\":\"$0:f:0:1:0:props:children:1:props:children:props:children:props:config\",\"currentPageTabGroup\":\"$undefined\"}],\"$L41\",\"$L42\",\"$L43\"]}]\n"])</script><script>self.__next_f.push([1,"44:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"DocLayout\"]\n47:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"TableOfContents\"]\n48:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"MdxHotReload\"]\n49:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"HotReloadIndicator\"]\n4a:I[931024,[\"/_next/static/chunks/eb22c92016909501.js\",\"/_next/static/chunks/147f1793f0357acf.js\"],\"DevModeBadge\"]\n45:T2eb6,"])</script><script>self.__next_f.push([1,"\n# Signature Revision\n\nA Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.\n\n## Overview\n\nSignature revisions provide:\n- **Authentication**: Proof that a specific entity created or approved the previous revision\n- **Integrity**: Assurance that the signed revision hasn't been tampered with\n- **Non-repudiation**: The signer cannot deny having signed the revision\n- **Flexibility**: Support for multiple cryptographic signature schemes\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being signed |\n| `revision_type` | string | Yes | Always `\"signature\"` for signature revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `signature` | object | Yes | Signature value object (varies by signature type) |\n\n### Signature Value Object\n\nThe `signature` field is an object with different structures depending on the signature type.\n\n## Signature Types\n\n### 1. RSA Signature\n\nUses RSA public-key cryptography with PKCS#1 v1.5 padding.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"rsa\",\n  \"signature\": \"0x...\",\n  \"public_key\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"rsa\"` |\n| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |\n| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |\n\n#### Validation Rules\n- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)\n- Public key must be DER-encoded and between 200-600 bytes\n- Both fields must be lowercase hex strings prefixed with `0x`\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"rsa\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"public_key\": \"0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001\"\n  }\n}\n```\n\n---\n\n### 2. Ethereum (EIP-191) Signature\n\nUses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"ethereum:eip-191\",\n  \"signature\": \"0x...\",\n  \"signature_wallet_address\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"ethereum:eip-191\"` |\n| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |\n| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |\n\n#### Validation Rules\n- Signature must be exactly 65 bytes\n- Wallet address must be a valid EIP-55 checksummed address\n- Both fields must be hex strings prefixed with `0x`\n- Address checksum must be validated\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"ethereum:eip-191\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c\",\n    \"signature_wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).\n\n---\n\n### 3. DID JWS Signature\n\nUses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).\n\n#### Structure\n```json\n{\n  \"signature_type\": \"did:jws\",\n  \"jws\": \"eyJ...\",\n  \"did\": \"did:key:...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"did:jws\"` |\n| `jws` | string | Compact JWS (JSON Web Signature) |\n| `did` | string | Decentralized Identifier of the signer |\n\n#### Validation Rules\n- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)\n- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)\n- The DID document must be resolvable to verify the signature\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"did:jws\",\n    \"jws\": \"eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ\",\n    \"did\": \"did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\"\n  }\n}\n```\n\n---\n\n## What Gets Signed\n\nThe signature is computed over the **hash of the previous revision**, not the revision itself.\n\n### Signing Process\n\n1. Compute the hash of the `previous_revision`\n2. For Ethereum: Add EIP-191 prefix (`\\x19Ethereum Signed Message:\\n32`)\n3. Sign the hash using the appropriate method\n4. Create the signature revision with the signature value\n5. Compute the hash of the signature revision\n\n### Example Signing Flow\n\n```\nObject Revision =\u003e Compute Hash =\u003e Sign Hash =\u003e Signature Revision\n     |\n0x3f8a7b2c... (previous_revision in signature)\n```\n\n## Validation Rules\n\nA Signature Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"signature\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Signature Type**: One of `\"rsa\"`, `\"ethereum:eip-191\"`, or `\"did:jws\"`\n5. **Signature Format**: Matches the requirements for the specific signature type\n6. **No Unknown Fields**: The signature object contains only recognized fields\n7. **Signature Verification**: The signature can be cryptographically verified\n   - For RSA: Verify using the provided public key\n   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`\n   - For DID:JWS: Resolve DID and verify JWS signature\n\n## Multiple Signatures\n\nTo add multiple signatures to the same revision:\n\n```\nObject Revision\n    |\nSignature 1 (Alice signs object)\n    |\nSignature 2 (Bob signs Signature 1)\n    |\nSignature 3 (Carol signs Signature 2)\n```\n\nEach signature revision signs the previous revision, creating a chain of signatures.\n\n### Multi-Party Signing\n\nFor independent multi-party signing (all signing the same object):\n\n```\n        Object Revision\n      |        |            |\nSignature A  Signature B  Signature C\n         |    |    |\n        Link Revision\n```\n\nUse a Link Revision to combine multiple independent signature branches.\n\n## Common Use Cases\n\n### 1. Document Signing\nSign file object revisions to prove authorship:\n```\nFile Object =\u003e Signature (Author) =\u003e Witness (Timestamp)\n```\n\n### 2. Approval Workflows\nMultiple parties sign in sequence:\n```\nDocument =\u003e Sign (Creator) =\u003e Sign (Reviewer) =\u003e Sign (Approver)\n```\n\n### 3. Notarization\nProfessional notary signs an object:\n```\nObject =\u003e Signature (Notary's RSA key) =\u003e Witness (Blockchain)\n```\n\n### 4. Smart Contract Interaction\nEthereum wallet signs for on-chain verification:\n```\nClaim =\u003e Signature (EIP-191) =\u003e Submit to Smart Contract\n```\n\n### 5. Decentralized Identity\nDID-based signatures for verifiable credentials:\n```\nCredential =\u003e Signature (Issuer's DID) =\u003e Holder stores\n```\n\n## Implementation Notes\n\n### Creating a Signature Revision\n\n1. Identify the revision to sign\n2. Compute its hash (the `previous_revision` value)\n3. Prepare the message to sign (hash, with any required prefixes)\n4. Generate the signature using chosen method\n5. Construct the signature revision object\n6. Validate the signature can be verified\n7. Compute and store the signature revision hash\n\n### Verifying a Signature Revision\n\n#### RSA Verification\n```\n1. Extract public_key from signature object\n2. Extract signature bytes\n3. Reconstruct signed message (hash of previous_revision)\n4. Verify signature using RSA public key\n```\n\n#### EIP-191 Verification\n```\n1. Reconstruct EIP-191 message: \"\\x19Ethereum Signed Message:\\n32\" + hash\n2. Recover address from signature\n3. Compare recovered address to signature_wallet_address\n```\n\n#### DID:JWS Verification\n```\n1. Resolve DID to get DID document\n2. Extract verification method (public key)\n3. Verify JWS signature using verification method\n4. Validate JWS payload matches revision data\n```\n\n## Security Considerations\n\n### 1. Key Management\n- RSA: Protect private key files, use strong key sizes (e2048 bits)\n- EIP-191: Secure wallet seed phrases/private keys\n- DID: Maintain DID document security and key rotation policies\n\n### 2. Signature Reuse\n- Each signature should sign a unique revision\n- Nonces prevent replay attacks\n\n### 3. Timestamp Validation\n- Check `local_timestamp` is reasonable (not far future/past)\n- Compare with witness timestamps for consistency\n\n### 4. Address Validation\n- For EIP-191: Always validate EIP-55 checksum\n- Reject non-checksummed addresses\n\n### 5. DID Resolution\n- Ensure DID resolver is trustworthy\n- Cache DID documents appropriately\n- Handle resolution failures gracefully\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Typically what gets signed first\n- **Witness Revisions**: Often follow signatures to add timestamping\n- **Link Revisions**: Can combine multiple signature branches\n- **Template Revisions**: Can also be signed, though less common\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets signed\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamps after signing\n- [Link Revision](/schema_reference/link_revision) - Combine signature branches\n- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard\n- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers\n- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures\n"])</script><script>self.__next_f.push([1,"46:T2eb6,"])</script><script>self.__next_f.push([1,"\n# Signature Revision\n\nA Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.\n\n## Overview\n\nSignature revisions provide:\n- **Authentication**: Proof that a specific entity created or approved the previous revision\n- **Integrity**: Assurance that the signed revision hasn't been tampered with\n- **Non-repudiation**: The signer cannot deny having signed the revision\n- **Flexibility**: Support for multiple cryptographic signature schemes\n\n## Schema Structure\n\n### Common Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `previous_revision` | string | Yes | Hash reference to the revision being signed |\n| `revision_type` | string | Yes | Always `\"signature\"` for signature revisions |\n| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |\n| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |\n| `version` | string | Yes | Protocol version: `\"https://aqua-protocol.org/docs/v4/schema\"` |\n| `method` | string | Yes | Canonicalization method: `\"scalar\"` (typical) or `\"tree\"` |\n| `hash_type` | string | Yes | Hash algorithm: `\"FIPS_202-SHA3-256\"` |\n| `signature` | object | Yes | Signature value object (varies by signature type) |\n\n### Signature Value Object\n\nThe `signature` field is an object with different structures depending on the signature type.\n\n## Signature Types\n\n### 1. RSA Signature\n\nUses RSA public-key cryptography with PKCS#1 v1.5 padding.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"rsa\",\n  \"signature\": \"0x...\",\n  \"public_key\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"rsa\"` |\n| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |\n| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |\n\n#### Validation Rules\n- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)\n- Public key must be DER-encoded and between 200-600 bytes\n- Both fields must be lowercase hex strings prefixed with `0x`\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b\",\n  \"local_timestamp\": 1704067200,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"rsa\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d\",\n    \"public_key\": \"0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001\"\n  }\n}\n```\n\n---\n\n### 2. Ethereum (EIP-191) Signature\n\nUses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.\n\n#### Structure\n```json\n{\n  \"signature_type\": \"ethereum:eip-191\",\n  \"signature\": \"0x...\",\n  \"signature_wallet_address\": \"0x...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"ethereum:eip-191\"` |\n| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |\n| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |\n\n#### Validation Rules\n- Signature must be exactly 65 bytes\n- Wallet address must be a valid EIP-55 checksummed address\n- Both fields must be hex strings prefixed with `0x`\n- Address checksum must be validated\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e\",\n  \"local_timestamp\": 1704070800,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"ethereum:eip-191\",\n    \"signature\": \"0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c\",\n    \"signature_wallet_address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8\"\n  }\n}\n```\n\n**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).\n\n---\n\n### 3. DID JWS Signature\n\nUses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).\n\n#### Structure\n```json\n{\n  \"signature_type\": \"did:jws\",\n  \"jws\": \"eyJ...\",\n  \"did\": \"did:key:...\"\n}\n```\n\n#### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signature_type` | string | Must be `\"did:jws\"` |\n| `jws` | string | Compact JWS (JSON Web Signature) |\n| `did` | string | Decentralized Identifier of the signer |\n\n#### Validation Rules\n- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)\n- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)\n- The DID document must be resolvable to verify the signature\n\n#### Example\n```json\n{\n  \"previous_revision\": \"0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a\",\n  \"revision_type\": \"signature\",\n  \"nonce\": \"0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a\",\n  \"local_timestamp\": 1704074400,\n  \"version\": \"https://aqua-protocol.org/docs/v4/schema\",\n  \"method\": \"scalar\",\n  \"hash_type\": \"FIPS_202-SHA3-256\",\n  \"signature\": {\n    \"signature_type\": \"did:jws\",\n    \"jws\": \"eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ\",\n    \"did\": \"did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\"\n  }\n}\n```\n\n---\n\n## What Gets Signed\n\nThe signature is computed over the **hash of the previous revision**, not the revision itself.\n\n### Signing Process\n\n1. Compute the hash of the `previous_revision`\n2. For Ethereum: Add EIP-191 prefix (`\\x19Ethereum Signed Message:\\n32`)\n3. Sign the hash using the appropriate method\n4. Create the signature revision with the signature value\n5. Compute the hash of the signature revision\n\n### Example Signing Flow\n\n```\nObject Revision =\u003e Compute Hash =\u003e Sign Hash =\u003e Signature Revision\n     |\n0x3f8a7b2c... (previous_revision in signature)\n```\n\n## Validation Rules\n\nA Signature Revision is valid if:\n\n1. **Structure**: Contains all required fields with correct types\n2. **Revision Type**: The `revision_type` is exactly `\"signature\"`\n3. **Previous Revision**: References a valid existing revision\n4. **Signature Type**: One of `\"rsa\"`, `\"ethereum:eip-191\"`, or `\"did:jws\"`\n5. **Signature Format**: Matches the requirements for the specific signature type\n6. **No Unknown Fields**: The signature object contains only recognized fields\n7. **Signature Verification**: The signature can be cryptographically verified\n   - For RSA: Verify using the provided public key\n   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`\n   - For DID:JWS: Resolve DID and verify JWS signature\n\n## Multiple Signatures\n\nTo add multiple signatures to the same revision:\n\n```\nObject Revision\n    |\nSignature 1 (Alice signs object)\n    |\nSignature 2 (Bob signs Signature 1)\n    |\nSignature 3 (Carol signs Signature 2)\n```\n\nEach signature revision signs the previous revision, creating a chain of signatures.\n\n### Multi-Party Signing\n\nFor independent multi-party signing (all signing the same object):\n\n```\n        Object Revision\n      |        |            |\nSignature A  Signature B  Signature C\n         |    |    |\n        Link Revision\n```\n\nUse a Link Revision to combine multiple independent signature branches.\n\n## Common Use Cases\n\n### 1. Document Signing\nSign file object revisions to prove authorship:\n```\nFile Object =\u003e Signature (Author) =\u003e Witness (Timestamp)\n```\n\n### 2. Approval Workflows\nMultiple parties sign in sequence:\n```\nDocument =\u003e Sign (Creator) =\u003e Sign (Reviewer) =\u003e Sign (Approver)\n```\n\n### 3. Notarization\nProfessional notary signs an object:\n```\nObject =\u003e Signature (Notary's RSA key) =\u003e Witness (Blockchain)\n```\n\n### 4. Smart Contract Interaction\nEthereum wallet signs for on-chain verification:\n```\nClaim =\u003e Signature (EIP-191) =\u003e Submit to Smart Contract\n```\n\n### 5. Decentralized Identity\nDID-based signatures for verifiable credentials:\n```\nCredential =\u003e Signature (Issuer's DID) =\u003e Holder stores\n```\n\n## Implementation Notes\n\n### Creating a Signature Revision\n\n1. Identify the revision to sign\n2. Compute its hash (the `previous_revision` value)\n3. Prepare the message to sign (hash, with any required prefixes)\n4. Generate the signature using chosen method\n5. Construct the signature revision object\n6. Validate the signature can be verified\n7. Compute and store the signature revision hash\n\n### Verifying a Signature Revision\n\n#### RSA Verification\n```\n1. Extract public_key from signature object\n2. Extract signature bytes\n3. Reconstruct signed message (hash of previous_revision)\n4. Verify signature using RSA public key\n```\n\n#### EIP-191 Verification\n```\n1. Reconstruct EIP-191 message: \"\\x19Ethereum Signed Message:\\n32\" + hash\n2. Recover address from signature\n3. Compare recovered address to signature_wallet_address\n```\n\n#### DID:JWS Verification\n```\n1. Resolve DID to get DID document\n2. Extract verification method (public key)\n3. Verify JWS signature using verification method\n4. Validate JWS payload matches revision data\n```\n\n## Security Considerations\n\n### 1. Key Management\n- RSA: Protect private key files, use strong key sizes (e2048 bits)\n- EIP-191: Secure wallet seed phrases/private keys\n- DID: Maintain DID document security and key rotation policies\n\n### 2. Signature Reuse\n- Each signature should sign a unique revision\n- Nonces prevent replay attacks\n\n### 3. Timestamp Validation\n- Check `local_timestamp` is reasonable (not far future/past)\n- Compare with witness timestamps for consistency\n\n### 4. Address Validation\n- For EIP-191: Always validate EIP-55 checksum\n- Reject non-checksummed addresses\n\n### 5. DID Resolution\n- Ensure DID resolver is trustworthy\n- Cache DID documents appropriately\n- Handle resolution failures gracefully\n\n## Relationship with Other Revisions\n\n- **Object Revisions**: Typically what gets signed first\n- **Witness Revisions**: Often follow signatures to add timestamping\n- **Link Revisions**: Can combine multiple signature branches\n- **Template Revisions**: Can also be signed, though less common\n\n## See Also\n\n- [Object Revision](/schema_reference/object_revision) - What typically gets signed\n- [Witness Revision](/schema_reference/witness_revision) - Add timestamps after signing\n- [Link Revision](/schema_reference/link_revision) - Combine signature branches\n- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard\n- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers\n- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures\n"])</script><script>self.__next_f.push([1,"3f:[\"$\",\"$L44\",null,{\"meta\":{\"title\":\"Signature Revision\",\"description\":\"Schema specification for Signature Revisions in Aqua Protocol v4\",\"content\":\"$45\",\"reading_time\":7,\"word_count\":1393},\"content\":\"$46\",\"previousDoc\":{\"title\":\"Aqua Protocol Revisions\",\"slug\":\"schema-reference/revision/revision\"},\"nextDoc\":{\"title\":\"Template Revision\",\"slug\":\"schema-reference/revision/template-revision\"},\"version\":\"v4.0.0\",\"slug\":\"schema-reference/revision/signing-revision\",\"config\":\"$0:f:0:1:0:props:children:1:props:children:props:children:props:config\"}]\n"])</script><script>self.__next_f.push([1,"40:[\"$\",\"$L47\",null,{\"items\":[{\"id\":\"overview\",\"title\":\"Overview\",\"level\":2},{\"id\":\"schema-structure\",\"title\":\"Schema Structure\",\"level\":2},{\"id\":\"common-fields\",\"title\":\"Common Fields\",\"level\":3},{\"id\":\"signature-value-object\",\"title\":\"Signature Value Object\",\"level\":3},{\"id\":\"signature-types\",\"title\":\"Signature Types\",\"level\":2},{\"id\":\"1-rsa-signature\",\"title\":\"1. RSA Signature\",\"level\":3},{\"id\":\"2-ethereum-eip-191-signature\",\"title\":\"2. Ethereum (EIP-191) Signature\",\"level\":3},{\"id\":\"3-did-jws-signature\",\"title\":\"3. DID JWS Signature\",\"level\":3},{\"id\":\"what-gets-signed\",\"title\":\"What Gets Signed\",\"level\":2},{\"id\":\"signing-process\",\"title\":\"Signing Process\",\"level\":3},{\"id\":\"example-signing-flow\",\"title\":\"Example Signing Flow\",\"level\":3},{\"id\":\"validation-rules\",\"title\":\"Validation Rules\",\"level\":2},{\"id\":\"multiple-signatures\",\"title\":\"Multiple Signatures\",\"level\":2},{\"id\":\"multi-party-signing\",\"title\":\"Multi-Party Signing\",\"level\":3},{\"id\":\"common-use-cases\",\"title\":\"Common Use Cases\",\"level\":2},{\"id\":\"1-document-signing\",\"title\":\"1. Document Signing\",\"level\":3},{\"id\":\"2-approval-workflows\",\"title\":\"2. Approval Workflows\",\"level\":3},{\"id\":\"3-notarization\",\"title\":\"3. Notarization\",\"level\":3},{\"id\":\"4-smart-contract-interaction\",\"title\":\"4. Smart Contract Interaction\",\"level\":3},{\"id\":\"5-decentralized-identity\",\"title\":\"5. Decentralized Identity\",\"level\":3},{\"id\":\"implementation-notes\",\"title\":\"Implementation Notes\",\"level\":2},{\"id\":\"creating-a-signature-revision\",\"title\":\"Creating a Signature Revision\",\"level\":3},{\"id\":\"verifying-a-signature-revision\",\"title\":\"Verifying a Signature Revision\",\"level\":3},{\"id\":\"security-considerations\",\"title\":\"Security Considerations\",\"level\":2},{\"id\":\"1-key-management\",\"title\":\"1. Key Management\",\"level\":3},{\"id\":\"2-signature-reuse\",\"title\":\"2. Signature Reuse\",\"level\":3},{\"id\":\"3-timestamp-validation\",\"title\":\"3. Timestamp Validation\",\"level\":3},{\"id\":\"4-address-validation\",\"title\":\"4. Address Validation\",\"level\":3},{\"id\":\"5-did-resolution\",\"title\":\"5. DID Resolution\",\"level\":3},{\"id\":\"relationship-with-other-revisions\",\"title\":\"Relationship with Other Revisions\",\"level\":2},{\"id\":\"see-also\",\"title\":\"See Also\",\"level\":2}],\"config\":\"$0:f:0:1:0:props:children:1:props:children:props:children:props:config\"}]\n"])</script><script>self.__next_f.push([1,"41:[\"$\",\"$L48\",null,{}]\n42:[\"$\",\"$L49\",null,{}]\n43:[\"$\",\"$L4a\",null,{}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"4b:I[27201,[\"/_next/static/chunks/d96012bcfc98706a.js\",\"/_next/static/chunks/963c71eec1d89c3f.js\"],\"IconMark\"]\nf:null\n13:[[\"$\",\"title\",\"0\",{\"children\":\"Signature Revision | Aqua Protocol\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Schema specification for Signature Revisions in Aqua Protocol v4\"}],[\"$\",\"link\",\"2\",{\"rel\":\"canonical\",\"href\":\"https://aqua-protocol.org/docs/v4.0.0/schema-reference/revision/signing-revision\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:title\",\"content\":\"Signature Revision\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:description\",\"content\":\"Schema specification for Signature Revisions in Aqua Protocol v4\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:url\",\"content\":\"https://aqua-protocol.org/docs/v4.0.0/schema-reference/revision/signing-revision\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:site_name\",\"content\":\"Documentation Platform\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:title\",\"content\":\"Signature Revision\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:description\",\"content\":\"Schema specification for Signature Revisions in Aqua Protocol v4\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/logo/aqua-logo.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png\"}],[\"$\",\"$L4b\",\"14\",{}]]\n"])</script></body></html>