---
title: "Link Revision"
description: "Schema specification for Link Revisions in Aqua Protocol v4"
---

# Link Revision

A Link Revision creates verifiable connections between separate revision chains. It allows you to establish relationships, dependencies, or references between different objects, effectively creating a graph structure of interconnected chains. Link revisions are essential for composing complex data structures and maintaining provenance across multiple chains.

## Overview

Link revisions enable:
- **Chain Composition**: Connect multiple independent chains together
- **Dependency Tracking**: Express that one chain depends on others
- **Multi-Party Collaboration**: Combine contributions from different parties
- **Provenance Graphs**: Build complex data relationship structures
- **Verification Aggregation**: Group related chains for batch verification

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the previous revision in this chain |
| `revision_type` | string | Yes | Always `"link"` for link revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the link was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `link_verification_hashes` | array | Yes | Array of revision hashes being linked to |

### Field Details

#### link_verification_hashes
- **Type**: Array of hex strings
- **Format**: Each element is a lowercase hex string prefixed with `0x`
- **Purpose**: References to other revision chains
- **Minimum**: Can be empty array (though typically contains at least one link)
- **Maximum**: No strict limit, but practical limits depend on implementation
- **Order**: Order may be significant depending on use case

## Example

### Basic Link Revision

Linking to two other chains:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "link",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
  ]
}
```

### Single Link

Linking to a single chain:

```json
{
  "previous_revision": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f",
  "revision_type": "link",
  "nonce": "0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d"
  ]
}
```

### Multiple Links (Aggregation)

Aggregating many chains:

```json
{
  "previous_revision": "0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c",
  "revision_type": "link",
  "nonce": "0xa1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1111111111111111111111111111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222222222222222222222222222",
    "0x3333333333333333333333333333333333333333333333333333333333333333",
    "0x4444444444444444444444444444444444444444444444444444444444444444",
    "0x5555555555555555555555555555555555555555555555555555555555555555"
  ]
}
```

## Validation Rules

A Link Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"link"`
3. **Previous Revision**: References a valid existing revision
4. **Link Array**: `link_verification_hashes` is a valid array
5. **Link Format**: Each element in the array is a valid hex string with `0x` prefix
6. **Link Targets**: Each referenced revision should exist and be verifiable (optional strict validation)
7. **No Duplicates**: Typically shouldn't contain duplicate hashes (application-specific)
8. **Hash Verification**: The computed hash of the link revision is correct

## Common Use Cases

### 1. Document Dependencies

Link a document to its source materials:

<Mermaid
  chart={`
    graph TD
      Contract[Contract Document - Object]
      Link[Link Revision]
      Ref1[Reference Doc 1]
      Ref2[Reference Doc 2]
      Ref3[Reference Doc 3]

      Contract --> Link
      Link -.->|references| Ref1
      Link -.->|references| Ref2
      Link -.->|references| Ref3
  `}
  caption="Document dependencies using link revision"
/>

### 2. Multi-Party Signing

Combine independent signatures:

<Mermaid
  chart={`
    graph TD
      Doc[Document Object]
      SigA[Signature - Alice]
      SigB[Signature - Bob]
      SigC[Signature - Carol]
      Link[Link Revision]
      Witness[Witness - Timestamp all]

      Doc --> SigA
      Doc --> SigB
      Doc --> SigC
      SigA --> Link
      SigB --> Link
      SigC --> Link
      Link --> Witness
  `}
  caption="Multi-party signing with link revision"
/>

### 3. Bill of Materials

Link a product to its components:

<Mermaid
  chart={`
    graph TD
      Product[Product Object]
      Link[Link Revision]
      Comp1[Component 1 Chain]
      Comp2[Component 2 Chain]
      Comp3[Component 3 Chain]

      Product --> Link
      Link -.->|references| Comp1
      Link -.->|references| Comp2
      Link -.->|references| Comp3
  `}
  caption="Bill of materials with component chains"
/>

Each component has its own provenance chain.

### 4. Credential Bundling

Group related credentials:

<Mermaid
  chart={`
    graph TD
      Profile[Profile Object]
      Link[Link Revision]
      Email[Email Credential]
      Domain[Domain Credential]
      GitHub[GitHub Credential]

      Profile --> Link
      Link -.->|references| Email
      Link -.->|references| Domain
      Link -.->|references| GitHub
  `}
  caption="Credential bundling with link revision"
/>

### 5. Supply Chain Aggregation

Combine supply chain events:

<Mermaid
  chart={`
    graph TD
      Tracking[Shipment Tracking]
      Link[Link Revision]
      Manufacturer[Manufacturer Chain]
      Shipper[Shipper Chain]
      Customs[Customs Chain]
      Final[Final Delivery Confirmation]

      Tracking --> Link
      Link -.->|references| Manufacturer
      Link -.->|references| Shipper
      Link -.->|references| Customs
      Link --> Final
  `}
  caption="Supply chain aggregation"
/>

### 6. Academic Citation

Link a paper to cited works:

<Mermaid
  chart={`
    graph TD
      Paper[Research Paper - Object]
      Link[Link Revision]
      Cite1[Citation 1 Chain]
      Cite2[Citation 2 Chain]
      CiteN[Citation N Chain]

      Paper --> Link
      Link -.->|references| Cite1
      Link -.->|references| Cite2
      Link -.->|references| CiteN
  `}
  caption="Academic citation with link revision"
/>

### 7. Version History

Link to previous versions:

<Mermaid
  chart={`
    graph TD
      V3[Document v3 - Object]
      Link[Link Revision]
      V1[Document v1 Final]
      V2[Document v2 Final]

      V3 --> Link
      Link -.->|references| V1
      Link -.->|references| V2
  `}
  caption="Version history with link revision"
/>

### 8. Approval Workflow Merge

Merge parallel approval processes:

<Mermaid
  chart={`
    graph TD
      Draft[Document Draft]
      ReviewA[Review A]
      ReviewB[Review B]
      ApproveA[Approve A]
      ApproveB[Approve B]
      Link[Link Revision]
      Final[Final Version]

      Draft --> ReviewA
      Draft --> ReviewB
      ReviewA --> ApproveA
      ReviewB --> ApproveB
      ApproveA --> Link
      ApproveB --> Link
      Link --> Final
  `}
  caption="Approval workflow merge with link revision"
/>

## Link Patterns

### Pattern 1: Linear Dependency Chain

<Mermaid
  chart={`
    graph LR
      A[Object A]
      LinkAB[Link]
      B[Object B]
      LinkBC[Link]
      C[Object C]

      A --> LinkAB
      LinkAB -.->|references| B
      B --> LinkBC
      LinkBC -.->|references| C
  `}
  caption="Linear dependency chain"
/>

Each object depends on the previous one.

### Pattern 2: Star Pattern (Aggregation)

<Mermaid
  chart={`
    graph TD
      Link[Link Revision]
      A[Chain A]
      B[Chain B]
      C[Chain C]
      D[Chain D]
      E[Chain E]

      Link -.->|references| A
      Link -.->|references| B
      Link -.->|references| C
      Link -.->|references| D
      Link -.->|references| E
  `}
  caption="Star pattern - one link references multiple chains"
/>

One link revision references multiple chains.

### Pattern 3: Tree Pattern

<Mermaid
  chart={`
    graph TD
      Root[Root Object]
      Link1[Link to A, B]
      LinkA[Link to A1, A2]
      LinkB[Link to B1, B2]
      A1[A1]
      A2[A2]
      B1[B1]
      B2[B2]

      Root --> Link1
      Link1 -.-> LinkA
      Link1 -.-> LinkB
      LinkA -.->|references| A1
      LinkA -.->|references| A2
      LinkB -.->|references| B1
      LinkB -.->|references| B2
  `}
  caption="Tree pattern - hierarchical structure using links"
/>

Hierarchical structure using links.

### Pattern 4: Graph Pattern

<Mermaid
  chart={`
    graph TD
      A[A]
      B[B]
      C[C]
      D[D]
      E[E]
      LinkA[Link from A]
      LinkB[Link from B]
      LinkC[Link from C]

      A --> LinkA
      LinkA -.->|references| B
      LinkA -.->|references| C

      B --> LinkB
      LinkB -.->|references| C
      LinkB -.->|references| D

      C --> LinkC
      LinkC -.->|references| A
      LinkC -.->|references| E
  `}
  caption="Graph pattern - complex graph with cycles and multiple connections"
/>

Complex graph with cycles and multiple connections.

## Implementation Notes

### Creating a Link Revision

1. Identify the chains to link
2. Get the head (latest) revision hash from each chain
3. Collect hashes into `link_verification_hashes` array
4. Determine the `previous_revision` for this link
5. Generate nonce and timestamp
6. Create the link revision structure
7. Compute and verify the hash

### Verifying a Link Revision

#### Basic Verification
```
1. Verify link revision structure
2. Validate each hash in link_verification_hashes
3. Compute link revision hash
```

#### Deep Verification
```
1. Perform basic verification
2. For each linked hash:
   a. Retrieve the referenced revision
   b. Verify the referenced revision chain
   c. Check signatures and witnesses
3. Validate all linked chains
```

### Link Resolution

When traversing links:

```
1. Start with link revision
2. Extract link_verification_hashes
3. For each hash:
   a. Resolve to actual revision
   b. Load revision chain
   c. Verify chain integrity
4. Build complete relationship graph
```

## Advanced Topics

### Cyclic References

Links can create cycles:

<Mermaid
  chart={`
    graph LR
      A[Chain A]
      LinkA[Link from A]
      B[Chain B]
      LinkB[Link from B]

      A --> LinkA
      LinkA -.->|references| B
      B --> LinkB
      LinkB -.->|references| A
  `}
  caption="Cyclic references between chains"
/>

**Handling**:
- Detect cycles during traversal
- Use visited set to prevent infinite loops
- Cycles may be valid depending on use case

### Temporal Ordering

Links create a temporal relationship:

```
Link created at timestamp T references chains that existed before T
```

**Validation**:
- Linked revisions should have timestamps < link timestamp
- Prevents linking to "future" revisions

### Partial vs Complete References

**Complete Reference**: Link to final revision of a chain
```
Link → [Complete Chain A, Complete Chain B]
```

**Partial Reference**: Link to intermediate revision
```
Link → [Chain A @ Revision 5, Chain B @ Revision 3]
```

### Link Updates

To update links over time:

<Mermaid
  chart={`
    graph TD
      Obj[Object]
      Link1[Link v1 - references A, B]
      Link2[Link v2 - references A, B, C]
      Link3[Link v3 - references A, C]

      Obj --> Link1
      Link1 --> Link2
      Link2 --> Link3
  `}
  caption="Link updates tracking changes over time"
/>

Each link revision chains to the previous, tracking changes.

### Link Metadata

While the standard link revision doesn't include metadata, you can add it by:

1. Creating an object revision with link metadata
2. Following it with a link revision

<Mermaid
  chart={`
    graph TD
      Obj[Object - metadata: 'This links dependencies']
      Link[Link Revision]
      Dep1[Dep1]
      Dep2[Dep2]
      Dep3[Dep3]

      Obj --> Link
      Link -.->|references| Dep1
      Link -.->|references| Dep2
      Link -.->|references| Dep3
  `}
  caption="Link metadata using object revision"
/>

## Relationship with Other Revisions

- **Object Revisions**: Can be linked, and can precede link revisions
- **Signature Revisions**: Can be linked (e.g., aggregating signatures)
- **Witness Revisions**: Can be linked, or can follow link revisions
- **Template Revisions**: Typically not linked (they're standalone)

## Security Considerations

### 1. Link Validation

**Verify Existence**: Ensure linked revisions actually exist before creating link
**Verify Integrity**: Validate linked chains are not corrupted

### 2. Circular Dependencies

**Detection**: Implement cycle detection in verification
**Policy**: Decide if cycles are allowed in your application

### 3. Link Spam

**Prevention**: Validate that links are meaningful and authorized
**Rate Limiting**: Prevent excessive linking in systems

### 4. Temporal Consistency

**Timestamp Checking**: Ensure links don't reference "future" revisions
**Causality**: Maintain causal ordering of events

### 5. Authorization

**Link Permission**: Verify the creator has rights to link to target chains
**Privacy**: Linking may reveal relationships between otherwise private chains

## Performance Considerations

### Link Depth

Deep link hierarchies impact verification time:

```
Object → Link (10 chains) → Each chain has Link (5 chains)
Total: 1 + 10 + 50 = 61 chains to verify
```

**Optimization**: Cache verified chains, use lazy loading

### Link Width

Wide links (many references) increase storage and bandwidth:

```
Link → [1000 chains]
```

**Optimization**: Paginate links, use link batching

### Verification Strategy

**Lazy**: Only verify linked chains when accessed
**Eager**: Verify all linked chains upfront
**Selective**: Verify critical paths only

## Comparison with Other Approaches

### vs Direct References

**Direct Reference** (in object payload):
```json
{
  "payload": {
    "dependencies": ["0xabc...", "0xdef..."]
  }
}
```

**Link Revision**:
```json
{
  "link_verification_hashes": ["0xabc...", "0xdef..."]
}
```

**Advantages of Link Revision**:
- Explicit in protocol (not application-specific)
- Verifiable without parsing payload
- Consistent structure across applications
- Can be signed and witnessed separately

### vs Witness Batching

**Witness Batching**: Uses Merkle tree for efficient blockchain anchoring
**Link Revision**: Creates explicit relationships between chains

**Key Difference**: Witness is about timestamping, Link is about relationships.

## Best Practices

### 1. Use Descriptive Ordering

Order links meaningfully:
```
["primary_source", "secondary_source", "tertiary_source"]
```

### 2. Link to Stable Points

Link to revisions that are finalized (signed/witnessed):

<Mermaid
  chart={`
    graph LR
      Obj[Object]
      Sign[Sign]
      Witness[Witness]
      Link[Link references this witnessed revision]

      Obj --> Sign
      Sign --> Witness
      Witness -.-> Link
  `}
  caption="Linking to stable, witnessed revisions"
/>

### 3. Document Link Semantics

Precede link with an object explaining the relationships:

<Mermaid
  chart={`
    graph TD
      Obj[Object - description: 'These are the project dependencies']
      Link[Link Revision]
      Deps[Dependency chains]

      Obj --> Link
      Link -.->|references| Deps
  `}
  caption="Documenting link semantics with object metadata"
/>

### 4. Consider Verification Cost

Limit link depth and width for practical verification times.

### 5. Use Links for Cross-Chain Only

Don't use links for intra-chain references (use `previous_revision` instead).

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Often linked
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Can aggregate via links
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Often follows links
- [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) - Mathematical foundation for link structures
