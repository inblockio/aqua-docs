1:"$Sreact.fragment"
2:"$Sreact.suspense"
3:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"DocLoading"]
4:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"DocLayoutWrapper"]
5:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"Header"]
35:I[522016,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],""]
48:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"TableOfContents"]
49:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"MdxHotReload"]
4a:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"HotReloadIndicator"]
4b:I[839694,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"DevModeBadge"]
4c:I[897367,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/73e3194f06db260e.js"],"OutletBoundary"]
4e:I[931024,["/_next/static/chunks/9eb1c473552970f7.js","/_next/static/chunks/6b58fd8858fa5e45.js","/_next/static/chunks/9df80df1e0c22aa5.js"],"CodeBlock"]
6:T1f72,

The **Aqua Tree** is the primary data structure in Aqua Protocol. It serves as the container for all revisions, their relationships, and associated metadata. An Aqua Tree represents a complete, self-contained unit that can be stored, transmitted, and verified independently.

## Why "Tree" and Not "Chain"?

The term "tree" is intentional. While revisions form chains through their `previous_hash` references, the structure supports **branching** where a single revision can have multiple children. This creates a tree topology rather than a simple linear chain.

```txt
Genesis Revision
      |
  Revision A
    /    \
Rev B    Rev C  ← Branching creates a tree
  |        |
Rev D    Rev E
```

## Structure

An Aqua Tree consists of two primary components:

### Core Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revisions` | Object | Yes | Map of revision hashes to revision objects |
| `file_index` | Object | Yes | Map of content hashes to filenames |

### Complete Structure

```json
{
  "revisions": {
    "0xabc123...": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      // ... revision-specific fields
    },
    "0xdef456...": {
      // ... another revision
    }
  },
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "document.pdf",
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "contract.txt"
  }
}
```

## Revisions Map

The `revisions` field is an object where:
- **Keys**: Verification hashes of revisions (hex strings prefixed with `0x`)
- **Values**: Complete revision objects

Each revision is indexed by its verification hash, which is computed from the revision's canonical form. This allows O(1) lookup of any revision by its hash.

### Revision Hash as Key

```json
{
  "revisions": {
    "0xabc123...": { /* revision object */ },
    "0xdef456...": { /* revision object */ }
  }
}
```

The hash serves as:
- Unique identifier for the revision
- Key for efficient lookups
- Reference in `previous_hash` fields to build the chain

## File Index

The `file_index` maps content hashes to human-readable filenames. This provides context about what content each hash represents.

See the [File Index documentation](/docs/v4.0.0/schema-reference/file-index) for detailed information.

## Complete Example

Here's a minimal Aqua Tree with a genesis object revision and a signature:

```json

{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "text/plain",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Initial Document"
      }
    },
    "0xsig123...": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "nonce": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d",
      "local_timestamp": 1704067260,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c901",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "document.txt"
  }
}

```

## Navigating the Tree

### Finding the Genesis Revision

The genesis revision has no `previous_hash` field or has `previous_hash: null`. To find it:

```typescript
const genesis = Object.values(aquaTree.revisions).find(
  rev => !rev.previous_hash
);
```

### Following the Chain

To traverse from genesis to latest:

```typescript
function getChain(aquaTree, startHash) {
  const chain = [];
  let current = aquaTree.revisions[startHash];

  while (current) {
    chain.push(current);

    // Find child (revision that references this one)
    const childHash = Object.keys(aquaTree.revisions).find(hash =>
      aquaTree.revisions[hash].previous_hash === currentHash
    );

    current = childHash ? aquaTree.revisions[childHash] : null;
  }

  return chain;
}
```

### Finding All Branches

For trees with branches:

```typescript
function findChildren(aquaTree, parentHash) {
  return Object.entries(aquaTree.revisions)
    .filter(([_, rev]) => rev.previous_hash === parentHash)
    .map(([hash, rev]) => ({ hash, revision: rev }));
}
```

## Storage and Transmission

### File Storage

Aqua Trees are typically stored as JSON files with `.aqua.json` extension:

```bash
document.aqua.json
contract-2024-01-01.aqua.json
```

### Size Considerations

- Each revision: ~200-500 bytes (depending on type and content)
- Typical Aqua Tree: 1-10 KB for simple documents
- Large trees with many revisions: Up to several MB

### Compression

For large trees, consider gzip compression:

```bash
gzip document.aqua.json
# Results in document.aqua.json.gz
```

## Validation

An Aqua Tree is valid if:

1. **All revisions have valid hashes**: Each revision's hash matches its computed verification hash
2. **Previous hashes reference existing revisions**: All `previous_hash` values point to revisions in the tree (except genesis)
3. **No circular references**: Following `previous_hash` links eventually reaches genesis
4. **Signatures are valid**: All signature revisions have valid cryptographic signatures
5. **File index matches**: All hashes in file_index correspond to content referenced in revisions

## Use Cases

### Document Management

Store a document's complete revision history:
- Genesis: Initial document creation
- Updates: Each modification as new object revision
- Signatures: Approvals from stakeholders
- Witnesses: Blockchain timestamps for legal proof

### Multi-Document Projects

Use link revisions to connect related Aqua Trees:
- Main project tree links to component trees
- Each component has its own revision history
- Verification cascades through linked trees

### Credential Issuance

Issue verifiable credentials:
- Genesis: Credential data (degree, certificate, license)
- Signature: Issuing authority signs
- Witness: Blockchain timestamp for verification
- File index: Maps credential hash to recipient identifier

## Performance Considerations

### Lookup Performance

- Hash-based lookup: O(1)
- Finding children: O(n) where n is number of revisions
- Full chain traversal: O(m) where m is chain length

### Optimization Strategies

For large trees:
1. **Index children separately**: Maintain a `children` map for each revision
2. **Cache traversals**: Store pre-computed chain paths
3. **Lazy loading**: Load only needed revisions for verification
4. **Prune old revisions**: Archive historical revisions separately

## Related Documentation

- [Revision Types](/docs/v4.0.0/schema-reference/revision/revision) - Overview of all revision types
- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Genesis and data revisions
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Cryptographic signatures
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Blockchain anchoring
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Connecting trees
- [File Index](/docs/v4.0.0/schema-reference/file-index) - Content hash mapping7:T1f72,

The **Aqua Tree** is the primary data structure in Aqua Protocol. It serves as the container for all revisions, their relationships, and associated metadata. An Aqua Tree represents a complete, self-contained unit that can be stored, transmitted, and verified independently.

## Why "Tree" and Not "Chain"?

The term "tree" is intentional. While revisions form chains through their `previous_hash` references, the structure supports **branching** where a single revision can have multiple children. This creates a tree topology rather than a simple linear chain.

```txt
Genesis Revision
      |
  Revision A
    /    \
Rev B    Rev C  ← Branching creates a tree
  |        |
Rev D    Rev E
```

## Structure

An Aqua Tree consists of two primary components:

### Core Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revisions` | Object | Yes | Map of revision hashes to revision objects |
| `file_index` | Object | Yes | Map of content hashes to filenames |

### Complete Structure

```json
{
  "revisions": {
    "0xabc123...": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      // ... revision-specific fields
    },
    "0xdef456...": {
      // ... another revision
    }
  },
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "document.pdf",
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "contract.txt"
  }
}
```

## Revisions Map

The `revisions` field is an object where:
- **Keys**: Verification hashes of revisions (hex strings prefixed with `0x`)
- **Values**: Complete revision objects

Each revision is indexed by its verification hash, which is computed from the revision's canonical form. This allows O(1) lookup of any revision by its hash.

### Revision Hash as Key

```json
{
  "revisions": {
    "0xabc123...": { /* revision object */ },
    "0xdef456...": { /* revision object */ }
  }
}
```

The hash serves as:
- Unique identifier for the revision
- Key for efficient lookups
- Reference in `previous_hash` fields to build the chain

## File Index

The `file_index` maps content hashes to human-readable filenames. This provides context about what content each hash represents.

See the [File Index documentation](/docs/v4.0.0/schema-reference/file-index) for detailed information.

## Complete Example

Here's a minimal Aqua Tree with a genesis object revision and a signature:

```json

{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "text/plain",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Initial Document"
      }
    },
    "0xsig123...": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "nonce": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d",
      "local_timestamp": 1704067260,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c901",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "document.txt"
  }
}

```

## Navigating the Tree

### Finding the Genesis Revision

The genesis revision has no `previous_hash` field or has `previous_hash: null`. To find it:

```typescript
const genesis = Object.values(aquaTree.revisions).find(
  rev => !rev.previous_hash
);
```

### Following the Chain

To traverse from genesis to latest:

```typescript
function getChain(aquaTree, startHash) {
  const chain = [];
  let current = aquaTree.revisions[startHash];

  while (current) {
    chain.push(current);

    // Find child (revision that references this one)
    const childHash = Object.keys(aquaTree.revisions).find(hash =>
      aquaTree.revisions[hash].previous_hash === currentHash
    );

    current = childHash ? aquaTree.revisions[childHash] : null;
  }

  return chain;
}
```

### Finding All Branches

For trees with branches:

```typescript
function findChildren(aquaTree, parentHash) {
  return Object.entries(aquaTree.revisions)
    .filter(([_, rev]) => rev.previous_hash === parentHash)
    .map(([hash, rev]) => ({ hash, revision: rev }));
}
```

## Storage and Transmission

### File Storage

Aqua Trees are typically stored as JSON files with `.aqua.json` extension:

```bash
document.aqua.json
contract-2024-01-01.aqua.json
```

### Size Considerations

- Each revision: ~200-500 bytes (depending on type and content)
- Typical Aqua Tree: 1-10 KB for simple documents
- Large trees with many revisions: Up to several MB

### Compression

For large trees, consider gzip compression:

```bash
gzip document.aqua.json
# Results in document.aqua.json.gz
```

## Validation

An Aqua Tree is valid if:

1. **All revisions have valid hashes**: Each revision's hash matches its computed verification hash
2. **Previous hashes reference existing revisions**: All `previous_hash` values point to revisions in the tree (except genesis)
3. **No circular references**: Following `previous_hash` links eventually reaches genesis
4. **Signatures are valid**: All signature revisions have valid cryptographic signatures
5. **File index matches**: All hashes in file_index correspond to content referenced in revisions

## Use Cases

### Document Management

Store a document's complete revision history:
- Genesis: Initial document creation
- Updates: Each modification as new object revision
- Signatures: Approvals from stakeholders
- Witnesses: Blockchain timestamps for legal proof

### Multi-Document Projects

Use link revisions to connect related Aqua Trees:
- Main project tree links to component trees
- Each component has its own revision history
- Verification cascades through linked trees

### Credential Issuance

Issue verifiable credentials:
- Genesis: Credential data (degree, certificate, license)
- Signature: Issuing authority signs
- Witness: Blockchain timestamp for verification
- File index: Maps credential hash to recipient identifier

## Performance Considerations

### Lookup Performance

- Hash-based lookup: O(1)
- Finding children: O(n) where n is number of revisions
- Full chain traversal: O(m) where m is chain length

### Optimization Strategies

For large trees:
1. **Index children separately**: Maintain a `children` map for each revision
2. **Cache traversals**: Store pre-computed chain paths
3. **Lazy loading**: Load only needed revisions for verification
4. **Prune old revisions**: Archive historical revisions separately

## Related Documentation

- [Revision Types](/docs/v4.0.0/schema-reference/revision/revision) - Overview of all revision types
- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Genesis and data revisions
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Cryptographic signatures
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Blockchain anchoring
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Connecting trees
- [File Index](/docs/v4.0.0/schema-reference/file-index) - Content hash mapping8:T1c5a,


**Aqua Protocol** is an open, private, and decentralized solution for data accountability and governance. Built with modern cryptographic standards, Aqua enables you to verify data integrity and provenance without relying on centralized authorities.

<Callout type="info">
**Powered by Cryptography, Not Blockchain**

Aqua Protocol is made possible by crypto as in _cryptography_! While it can use Ethereum for timestamping, the protocol itself neither is nor requires blockchain technology. It's a privacy-preserving, open-source protocol built on modern cryptographic methods.

<Badge variant="success">
 Account & Verify Data in Seconds
</Badge>

</Callout>



## What is Aqua Protocol?

The Aqua Protocol is a foundational framework for building distributed trust networks. By leveraging hash-chains, cryptographic signatures, and optional blockchain timestamping, Aqua enables scalable, trustless verification of data integrity and provenance. It empowers developers and innovators to create applications that certify, attest, and secure data in an open and decentralized way.

<Card title="Core Idea"
  icon="rocket"
  href="/docs/v4.0.0/quickstart"
  horizontal
>
  Building trust through cryptographic proof and verifiable data structures.
</Card>

Trust can be built by relying on hashing and encryption mechanisms or by delegating to a mutually trusted party. Aqua Protocol handles both scenarios, giving you flexibility in how you establish and verify trust.



## How It Works

At its core, Aqua creates portable hash-chains called **AquaTrees** that record a gapless history of data revisions. These trees can be timestamped on Ethereum for immutability, exchanged across services, and verified automatically. Whether securing documents, systems, or identities, Aqua liberates the certification process from institutional gatekeepers, making trust accessible through open cryptographic standards.

### Key Features

- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is immediately detectable
- **Multi-Party Signatures**: Collect signatures from multiple parties for authentication and non-repudiation
- **Blockchain Timestamping**: Optional anchoring to Ethereum, Nostr, or TSA for provable timestamps
- **Portable Verification**: AquaTrees can be exchanged, stored, and verified anywhere
- **Privacy-Preserving**: Only hashes are stored on-chain, keeping your data private

## Try Aquafier

Want to see Aqua Protocol in action? Try **Aquafier**, our reference implementation that lets you upload, verify, and notarize any file:

<CardGrid cols={2}>
  <Card title="Aquafier (Production)"
    icon="globe"
    href="https://aquafier.inblock.io"
  >
    Try the live demo - upload and notarize files instantly
  </Card>

  <Card title="Aquafier (Testing)"
    icon="flask"
    href="https://dev.inblock.io"
  >
    Experiment in the development environment
  </Card>
</CardGrid>

## Getting Started

<Callout type="tip">New to Aqua Protocol? Here are the best places to start:</Callout>

<CardGrid cols={2}>
  <Card title="Quick Start Guide"
    icon="rocket"
    href="/docs/v4.0.0/quickstart"
  >
    Get up and running with Aqua Protocol in minutes
  </Card>

  <Card title="Understand the Schema"
    icon="brain"
    href="/docs/v4.0.0/schema-reference/introduction"
  >
    Learn about the components that make up the protocol
  </Card>

  <Card title="Explore Examples"
    icon="code"
    href="https://github.com/inblockio/aqua-examples"
  >
    Browse curated examples in different programming languages
  </Card>

  <Card title="Developer Tools"
    icon="wrench"
    href="/docs/v4.0.0/dev-tools/aqua-sdk"
  >
    Get started with our SDK, CLI, and development tools
  </Card>

  <Card title="Use Cases"
    icon="lightbulb"
    href="/docs/v4.0.0/use-cases/introduction"
  >
    Discover real-world applications and implementation patterns
  </Card>

  <Card title="View the Code"
    icon="github"
    href="https://github.com/inblockio"
  >
    Dive into the source code and contribute
  </Card>
</CardGrid>

## The Vision of Aqua

Aqua Protocol is still evolving, and we're discovering the full scope of its potential. Here's what Aqua represents:

<CardGrid cols={2}>
  <Card title="An Open Framework"
    icon="book-open"
  >
    Enabling private, decentralized solutions for general data notarization and verification
  </Card>

  <Card title="A Verifiable Data Structure"
    icon="shield-check"
  >
    Linking and certifying data with cryptographic precision through AquaTrees
  </Card>

  <Card title="A Protocol for Provenance"
    icon="fingerprint"
  >
    Ensuring clear attribution and integrity of data origins across systems
  </Card>

  <Card title="A Foundation for Trust"
    icon="handshake"
  >
    Powering distributed networks where trust is built-in, not assumed
  </Card>
</CardGrid>

## Current Version

**Aqua Protocol v4** (Beta) - Built with Rust, featuring:
- Template system with JSON Schema validation
- Enhanced revision types and canonicalization
- Cross-platform support via WASM
- Improved scalability and flexibility

**Aqua Protocol v3** (Stable) - Production-ready JavaScript/TypeScript SDK

<Callout type="info">
We're excited to see where this journey takes us and invite you to explore, build, and contribute to the future of decentralized trust with Aqua Protocol!
</Callout>

## Community & Contributions

Aqua Protocol is open source and community-driven. We welcome:

- **Feedback**: Share your thoughts and suggestions
- **Bug Reports**: Help us improve by reporting issues
- **Code Contributions**: Submit pull requests and improvements
- **Documentation**: Help make Aqua more accessible

<CardGrid cols={2}>
  <Card title="GitHub Repositories"
    icon="github"
    href="https://github.com/inblockio"
  >
    Browse our open-source code and contribute
  </Card>

  <Card title="Example Projects"
    icon="git-graph"
    href="https://github.com/inblockio/aqua-examples"
  >
    Explore complete examples and implementation patterns
  </Card>

  <Card title="Follow Updates"
    icon={(<svg viewBox="0 0 24 24" fill="currentColor" className="h-5 w-5">
      <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
    </svg>)}
    href="https://x.com/inblockio"
  >
    Stay updated with announcements and progress
  </Card>

  <Card title="Get Support"
    icon="mail"
    href="mailto:info@inblock.io"
  >
    Need help? Reach out to our team
  </Card>
</CardGrid>

## Next Steps

Ready to dive deeper?

1. **Start Building**: Follow the [Quick Start Guide](/docs/v4.0.0/quickstart) to create your first Aqua chain
2. **Understand the Protocol**: Read the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) for technical details
3. **Explore Use Cases**: See how others are using Aqua in [real-world applications](/docs/v4.0.0/use-cases/introduction)
4. **Join the Community**: Connect with developers on [GitHub](https://github.com/inblockio)

---

<Callout type="info">
**Need Help?**

Email us at [info@inblock.io](mailto:info@inblock.io) to talk to our team, or open an issue on GitHub for technical questions.
</Callout>


9:T1c5a,


**Aqua Protocol** is an open, private, and decentralized solution for data accountability and governance. Built with modern cryptographic standards, Aqua enables you to verify data integrity and provenance without relying on centralized authorities.

<Callout type="info">
**Powered by Cryptography, Not Blockchain**

Aqua Protocol is made possible by crypto as in _cryptography_! While it can use Ethereum for timestamping, the protocol itself neither is nor requires blockchain technology. It's a privacy-preserving, open-source protocol built on modern cryptographic methods.

<Badge variant="success">
 Account & Verify Data in Seconds
</Badge>

</Callout>



## What is Aqua Protocol?

The Aqua Protocol is a foundational framework for building distributed trust networks. By leveraging hash-chains, cryptographic signatures, and optional blockchain timestamping, Aqua enables scalable, trustless verification of data integrity and provenance. It empowers developers and innovators to create applications that certify, attest, and secure data in an open and decentralized way.

<Card title="Core Idea"
  icon="rocket"
  href="/docs/v4.0.0/quickstart"
  horizontal
>
  Building trust through cryptographic proof and verifiable data structures.
</Card>

Trust can be built by relying on hashing and encryption mechanisms or by delegating to a mutually trusted party. Aqua Protocol handles both scenarios, giving you flexibility in how you establish and verify trust.



## How It Works

At its core, Aqua creates portable hash-chains called **AquaTrees** that record a gapless history of data revisions. These trees can be timestamped on Ethereum for immutability, exchanged across services, and verified automatically. Whether securing documents, systems, or identities, Aqua liberates the certification process from institutional gatekeepers, making trust accessible through open cryptographic standards.

### Key Features

- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is immediately detectable
- **Multi-Party Signatures**: Collect signatures from multiple parties for authentication and non-repudiation
- **Blockchain Timestamping**: Optional anchoring to Ethereum, Nostr, or TSA for provable timestamps
- **Portable Verification**: AquaTrees can be exchanged, stored, and verified anywhere
- **Privacy-Preserving**: Only hashes are stored on-chain, keeping your data private

## Try Aquafier

Want to see Aqua Protocol in action? Try **Aquafier**, our reference implementation that lets you upload, verify, and notarize any file:

<CardGrid cols={2}>
  <Card title="Aquafier (Production)"
    icon="globe"
    href="https://aquafier.inblock.io"
  >
    Try the live demo - upload and notarize files instantly
  </Card>

  <Card title="Aquafier (Testing)"
    icon="flask"
    href="https://dev.inblock.io"
  >
    Experiment in the development environment
  </Card>
</CardGrid>

## Getting Started

<Callout type="tip">New to Aqua Protocol? Here are the best places to start:</Callout>

<CardGrid cols={2}>
  <Card title="Quick Start Guide"
    icon="rocket"
    href="/docs/v4.0.0/quickstart"
  >
    Get up and running with Aqua Protocol in minutes
  </Card>

  <Card title="Understand the Schema"
    icon="brain"
    href="/docs/v4.0.0/schema-reference/introduction"
  >
    Learn about the components that make up the protocol
  </Card>

  <Card title="Explore Examples"
    icon="code"
    href="https://github.com/inblockio/aqua-examples"
  >
    Browse curated examples in different programming languages
  </Card>

  <Card title="Developer Tools"
    icon="wrench"
    href="/docs/v4.0.0/dev-tools/aqua-sdk"
  >
    Get started with our SDK, CLI, and development tools
  </Card>

  <Card title="Use Cases"
    icon="lightbulb"
    href="/docs/v4.0.0/use-cases/introduction"
  >
    Discover real-world applications and implementation patterns
  </Card>

  <Card title="View the Code"
    icon="github"
    href="https://github.com/inblockio"
  >
    Dive into the source code and contribute
  </Card>
</CardGrid>

## The Vision of Aqua

Aqua Protocol is still evolving, and we're discovering the full scope of its potential. Here's what Aqua represents:

<CardGrid cols={2}>
  <Card title="An Open Framework"
    icon="book-open"
  >
    Enabling private, decentralized solutions for general data notarization and verification
  </Card>

  <Card title="A Verifiable Data Structure"
    icon="shield-check"
  >
    Linking and certifying data with cryptographic precision through AquaTrees
  </Card>

  <Card title="A Protocol for Provenance"
    icon="fingerprint"
  >
    Ensuring clear attribution and integrity of data origins across systems
  </Card>

  <Card title="A Foundation for Trust"
    icon="handshake"
  >
    Powering distributed networks where trust is built-in, not assumed
  </Card>
</CardGrid>

## Current Version

**Aqua Protocol v4** (Beta) - Built with Rust, featuring:
- Template system with JSON Schema validation
- Enhanced revision types and canonicalization
- Cross-platform support via WASM
- Improved scalability and flexibility

**Aqua Protocol v3** (Stable) - Production-ready JavaScript/TypeScript SDK

<Callout type="info">
We're excited to see where this journey takes us and invite you to explore, build, and contribute to the future of decentralized trust with Aqua Protocol!
</Callout>

## Community & Contributions

Aqua Protocol is open source and community-driven. We welcome:

- **Feedback**: Share your thoughts and suggestions
- **Bug Reports**: Help us improve by reporting issues
- **Code Contributions**: Submit pull requests and improvements
- **Documentation**: Help make Aqua more accessible

<CardGrid cols={2}>
  <Card title="GitHub Repositories"
    icon="github"
    href="https://github.com/inblockio"
  >
    Browse our open-source code and contribute
  </Card>

  <Card title="Example Projects"
    icon="git-graph"
    href="https://github.com/inblockio/aqua-examples"
  >
    Explore complete examples and implementation patterns
  </Card>

  <Card title="Follow Updates"
    icon={(<svg viewBox="0 0 24 24" fill="currentColor" className="h-5 w-5">
      <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
    </svg>)}
    href="https://x.com/inblockio"
  >
    Stay updated with announcements and progress
  </Card>

  <Card title="Get Support"
    icon="mail"
    href="mailto:info@inblock.io"
  >
    Need help? Reach out to our team
  </Card>
</CardGrid>

## Next Steps

Ready to dive deeper?

1. **Start Building**: Follow the [Quick Start Guide](/docs/v4.0.0/quickstart) to create your first Aqua chain
2. **Understand the Protocol**: Read the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) for technical details
3. **Explore Use Cases**: See how others are using Aqua in [real-world applications](/docs/v4.0.0/use-cases/introduction)
4. **Join the Community**: Connect with developers on [GitHub](https://github.com/inblockio)

---

<Callout type="info">
**Need Help?**

Email us at [info@inblock.io](mailto:info@inblock.io) to talk to our team, or open an issue on GitHub for technical questions.
</Callout>


a:T2ef1,
## Choose Your SDK

<Tabs defaultValue="js">
  <Tab label="js">
    **Stable** - Production-ready SDK for Node.js, Web, and React Native

    Best for: Web applications, existing JavaScript projects
  </Tab>

  <Tab label="rust">
    **Beta** - Template system, WASM support, cross-platform

    Best for: New projects, performance-critical applications
  </Tab>
</Tabs>

---

## JavaScript/TypeScript Quick Start (v3)

<Callout type="info">
### Prerequisites
- Node.js version 19 or higher
- npm, yarn, or pnpm package manager
</Callout >

<Callout type="note">
We recommend using TypeScript to enjoy type definitions and better development experience.
</Callout>

<Steps>
  <Step title="Install the SDK">
    Create a new project or add to an existing one:

    ```bash
    # Create new project (optional)
    mkdir my-aqua-project
    cd my-aqua-project
    npm init -y

    # Install Aqua SDK
    npm install aqua-js-sdk

    # For TypeScript projects, also install type support
    npm install --save-dev typescript @types/node
    ```
  </Step>

  <Step title="Create Your First Aqua Chain">
    Create a file called `index.ts` (or `index.js`):

    ```typescript
    import Aquafier, { FileObject } from 'aqua-js-sdk';

    async function main() {
        // Initialize Aquafier
        const aquafier = new Aquafier();

        // Create a file object to notarize
        const fileObject: FileObject = {
            fileName: "hello.txt",
            fileContent: "Hello, Aqua Protocol!",
            path: "./hello.txt"
        };

        // Create genesis revision (notarize the file)
        console.log("Creating Aqua chain...");
        const result = await aquafier.createGenesisRevision(fileObject);

        if (result.isOk()) {
            console.log("✓ Success! Aqua chain created.");
            console.log("Aqua Tree:", JSON.stringify(result.data.aquaTree, null, 2));

            // The aquaTree contains your notarized file
            const aquaTree = result.data.aquaTree;
            console.log("\nYou can now:");
            console.log("- Sign this chain");
            console.log("- Witness it on blockchain");
            console.log("- Verify it anytime");
        } else {
            console.error("✗ Error:", result.error);
        }
    }

    main().catch(console.error);
    ```
  </Step>

  <Step title="Run Your Code">
    ```bash
    # For TypeScript
    npx tsx index.ts

    # Or compile and run
    npx tsc index.ts
    node index.js

    # For plain JavaScript
    node index.js
    ```

    You should see output showing your Aqua chain was created successfully!
  </Step>

  <Step title="Next: Add a Signature (Optional)">
    Extend your code to add a cryptographic signature:

    ```typescript
    // ... after creating genesis ...

    if (result.isOk()) {
        const aquaTree = result.data.aquaTree;

        // Sign with MetaMask (will prompt in browser)
        const wrapper = {
            aquaTree: aquaTree,
            fileObject: fileObject,
            revision: ""
        };

        console.log("\nAdding signature...");
        const signedResult = await aquafier.signAquaTree(
            wrapper,
            "metamask",  // or "cli", "did", "p12"
            {},          // credentials
            true         // auto-increment
        );

        if (signedResult.isOk()) {
            console.log("✓ Signature added!");
        }
    }
    ```
  </Step>
</Steps>

---

## Rust Quick Start (v4)

<Callout type="info">

### Prerequisites
- Rust 1.70 or higher
- Cargo package manager

</Callout>

<Steps>
  <Step title="Create a New Project">
    ```bash
    # Create a new Rust binary project
    cargo new my-aqua-project
    cd my-aqua-project

    # Or for a library
    cargo new --lib my-aqua-lib
    ```
  </Step>

  <Step title="Add Aqua SDK Dependency">
    Add the Aqua SDK to your `Cargo.toml`:

    ```toml
    [dependencies]
    aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }
    tokio = { version = "1", features = ["full"] }
    serde_json = "1.0"
    ```
  </Step>

  <Step title="Create Your First Aqua Chain">
    Update `src/main.rs`:

    ```rust
    use aqua_rs_sdk::primitives::Method;
    use aqua_rs_sdk::schema::file_data::FileData;
    use aqua_rs_sdk::Aquafier;
    use std::path::PathBuf;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating Aqua chain...");

        // Read file content
        let filename = "test.txt".to_string();
        let file_content = tokio::fs::read(&filename).await?;

        // Create file data
        let file_data = FileData::new(
            filename.clone(),
            file_content,
            PathBuf::from(format!("./{}", filename)),
        );

        // Initialize Aquafier
        let aquafier = Aquafier::new(None, None);

        // Create genesis revision (notarize the file)
        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

        match result {
            Ok(tree) => {
                println!("✓ Aqua chain created successfully!");
                println!("{}", serde_json::to_string_pretty(&tree)?);

                println!("\nYou can now:");
                println!("- Add a signature revision");
                println!("- Witness on blockchain");
                println!("- Verify the chain");
            }
            Err(e) => {
                eprintln!("Error: {:#?}", e);
            }
        }

        Ok(())
    }
    ```
  </Step>

  <Step title="Build and Run">
    ```bash
    cargo build
    cargo run
    ```

    You should see confirmation that your object revision was created!
  </Step>
</Steps>

---

## CLI Tool Quick Start

<Callout type="info">
### Prerequisites
- Rust and Cargo installed
</Callout>

<Steps>
  <Step title="Install the CLI">
    ```bash
    # Clone and build
    git clone https://github.com/inblockio/aqua-cli-rs
    cd aqua-cli-rs
    cargo build --release

    # The binary will be at target/release/aqua-cli
    ```
  </Step>

  <Step title="Verify an Aqua Chain">
    ```bash
    ./target/release/aqua-cli verify --file chain.aqua.json
    ```
  </Step>

  <Step title="Get Help">
    ```bash
    ./target/release/aqua-cli --help
    ```
  </Step>
</Steps>

See the [CLI documentation](/docs/v4.0.0/dev-tools/aqua-cli) for more commands.

---

## Troubleshooting

<Accordion Group>
  <AccordionItem  title="Node.js: Module not found error">
    **Issue**: `Cannot find module 'aqua-js-sdk'`

    **Solutions**:
    1. Ensure you ran `npm install aqua-js-sdk`
    2. Check you're in the correct directory with `package.json`
    3. Try deleting `node_modules` and `package-lock.json`, then run `npm install` again
    4. For TypeScript, ensure you have `@types/node` installed
  </AccordionItem >

  <AccordionItem  title="TypeScript: Type errors">
    **Issue**: TypeScript compilation errors

    **Solutions**:
    1. Ensure you have TypeScript installed: `npm install --save-dev typescript`
    2. Create or update `tsconfig.json`:
       ```json
       {
         "compilerOptions": {
           "target": "ES2020",
           "module": "commonjs",
           "esModuleInterop": true,
           "strict": true
         }
       }
       ```
    3. Use `tsx` for direct TypeScript execution: `npm install --save-dev tsx`
  </AccordionItem >

  <AccordionItem  title="Rust: Compilation errors">
    **Issue**: Build fails with dependency errors

    **Solutions**:
    1. Update Rust: `rustup update`
    2. Clean and rebuild: `cargo clean && cargo build`
    3. Check you're using Rust 1.70 or higher: `rustc --version`
    4. Ensure your `Cargo.toml` has the correct repository URL
  </AccordionItem >

  <AccordionItem  title="MetaMask: Not detecting in Node.js">
    **Issue**: MetaMask signing doesn't work

    **Solution**: MetaMask works in browser environments only. For Node.js:
    - Use CLI signing with mnemonic in `credentials.json`
    - Or use DID or P12 signing methods
    - See [Development Guide](/docs/v4.0.0/development) for details
  </AccordionItem >

  <AccordionItem  title="Witnessing: Network errors">
    **Issue**: Ethereum witness fails

    **Solutions**:
    1. Ensure you have ETH in your wallet (testnet ETH for Sepolia/Holesky)
    2. Get testnet ETH from faucets:
       - Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)
       - Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)
    3. Check network connectivity
    4. Verify your Alchemy API key is correct
  </AccordionItem >
</Accordion>


---

## What You've Learned

Congratulations! You've created your first Aqua chain. Here's what you accomplished:

✅ Installed an Aqua SDK (JavaScript or Rust)<br/>
✅ Created a genesis revision (notarized data)<br/>
✅ Understood the basic Aqua workflow<br/>
✅ Ready to add signatures and witnesses<br/>

## Next Steps

Now that you have the basics, dive deeper into Aqua Protocol's features:

<CardGrid  cols={2}>
  <Card title="Signing Revisions" icon="signature" href="/docs/v4.0.0/schema-reference/revision/signing-revision">
    Add cryptographic signatures with RSA, Ethereum, or DID methods
  </Card>

  <Card title="Witnessing" icon="clock" href="/docs/v4.0.0/schema-reference/revision/witness-revision">
    Anchor your chains to Ethereum, TSA, or Nostr for timestamps
  </Card>

  <Card title="Linking Chains" icon="link" href="/docs/v4.0.0/schema-reference/revision/link-revision">
    Connect multiple Aqua Trees to build complex provenance graphs
  </Card>

  <Card title="Using Templates" icon="table" href="/docs/v4.0.0/schema-reference/revision/template-revision">
    Define data schemas with JSON Schema validation (v4 only)
  </Card>

  <Card title="Development Guide" icon="code" href="/docs/v4.0.0/development">
    Complete guide for signing methods, witnessing, and advanced usage
  </Card>

  <Card title="Schema Reference" icon="book" href="/docs/v4.0.0/schema-reference/introduction">
    Detailed technical specifications for all revision types
  </Card>

  <Card title="Use Cases" icon="lightbulb" href="/docs/v4.0.0/use-cases/introduction">
    Explore real-world applications and implementation patterns
  </Card>

  <Card title="Examples" icon="github" href="https://github.com/inblockio/aqua-examples">
    Browse complete working examples in multiple languages
  </Card>
</CardGrid >

## Complete Workflow Example

Want to see the full workflow including signing and witnessing?

<Tabs defaultValue="js">
  <Tab label="js">
    Check out the [complete JavaScript example](https://github.com/inblockio/aqua-js-sdk/tree/master/examples) in the SDK repository.
  </Tab>

  <Tab label="rust">
    Check out the [Rust SDK documentation](/docs/v4.0.0/dev-tools/aqua-sdk) for complete examples.
  </Tab>
</Tabs>

## Try Aquafier

Not ready to code yet? Try our web-based demo:

<CardGrid  cols={2}>
  <Card title="Aquafier Demo" icon="globe" href="https://aquafier.inblock.io">
    Upload and notarize files through a web interface
  </Card>

  <Card title="Test Environment" icon="bug-off" href="https://dev.inblock.io">
    Experiment safely in the development environment
  </Card>
</CardGrid >

## Get Help

<CardGrid  cols={2}>
  <Card title="GitHub Issues" icon="github" href="https://github.com/inblockio">
    Report bugs or ask questions on GitHub
  </Card>

  <Card title="Email Support" icon="mail" href="mailto:info@inblock.io">
    Contact our team for assistance
  </Card>

  <Card title="Documentation" icon="book" href="/docs/v4.0.0/welcome">
    Browse comprehensive guides and references
  </Card>

  <Card title="Community" icon="users" href="https://github.com/inblockio/aqua-examples/discussions">
    Join discussions with other developers
  </Card>
</CardGrid >

---

<Callout type="note" >
**Ready to build?** Start with the [Development Guide](/docs/v4.0.0/development) for detailed instructions on signing, witnessing, and advanced features.
</Callout  >
b:T2ef1,
## Choose Your SDK

<Tabs defaultValue="js">
  <Tab label="js">
    **Stable** - Production-ready SDK for Node.js, Web, and React Native

    Best for: Web applications, existing JavaScript projects
  </Tab>

  <Tab label="rust">
    **Beta** - Template system, WASM support, cross-platform

    Best for: New projects, performance-critical applications
  </Tab>
</Tabs>

---

## JavaScript/TypeScript Quick Start (v3)

<Callout type="info">
### Prerequisites
- Node.js version 19 or higher
- npm, yarn, or pnpm package manager
</Callout >

<Callout type="note">
We recommend using TypeScript to enjoy type definitions and better development experience.
</Callout>

<Steps>
  <Step title="Install the SDK">
    Create a new project or add to an existing one:

    ```bash
    # Create new project (optional)
    mkdir my-aqua-project
    cd my-aqua-project
    npm init -y

    # Install Aqua SDK
    npm install aqua-js-sdk

    # For TypeScript projects, also install type support
    npm install --save-dev typescript @types/node
    ```
  </Step>

  <Step title="Create Your First Aqua Chain">
    Create a file called `index.ts` (or `index.js`):

    ```typescript
    import Aquafier, { FileObject } from 'aqua-js-sdk';

    async function main() {
        // Initialize Aquafier
        const aquafier = new Aquafier();

        // Create a file object to notarize
        const fileObject: FileObject = {
            fileName: "hello.txt",
            fileContent: "Hello, Aqua Protocol!",
            path: "./hello.txt"
        };

        // Create genesis revision (notarize the file)
        console.log("Creating Aqua chain...");
        const result = await aquafier.createGenesisRevision(fileObject);

        if (result.isOk()) {
            console.log("✓ Success! Aqua chain created.");
            console.log("Aqua Tree:", JSON.stringify(result.data.aquaTree, null, 2));

            // The aquaTree contains your notarized file
            const aquaTree = result.data.aquaTree;
            console.log("\nYou can now:");
            console.log("- Sign this chain");
            console.log("- Witness it on blockchain");
            console.log("- Verify it anytime");
        } else {
            console.error("✗ Error:", result.error);
        }
    }

    main().catch(console.error);
    ```
  </Step>

  <Step title="Run Your Code">
    ```bash
    # For TypeScript
    npx tsx index.ts

    # Or compile and run
    npx tsc index.ts
    node index.js

    # For plain JavaScript
    node index.js
    ```

    You should see output showing your Aqua chain was created successfully!
  </Step>

  <Step title="Next: Add a Signature (Optional)">
    Extend your code to add a cryptographic signature:

    ```typescript
    // ... after creating genesis ...

    if (result.isOk()) {
        const aquaTree = result.data.aquaTree;

        // Sign with MetaMask (will prompt in browser)
        const wrapper = {
            aquaTree: aquaTree,
            fileObject: fileObject,
            revision: ""
        };

        console.log("\nAdding signature...");
        const signedResult = await aquafier.signAquaTree(
            wrapper,
            "metamask",  // or "cli", "did", "p12"
            {},          // credentials
            true         // auto-increment
        );

        if (signedResult.isOk()) {
            console.log("✓ Signature added!");
        }
    }
    ```
  </Step>
</Steps>

---

## Rust Quick Start (v4)

<Callout type="info">

### Prerequisites
- Rust 1.70 or higher
- Cargo package manager

</Callout>

<Steps>
  <Step title="Create a New Project">
    ```bash
    # Create a new Rust binary project
    cargo new my-aqua-project
    cd my-aqua-project

    # Or for a library
    cargo new --lib my-aqua-lib
    ```
  </Step>

  <Step title="Add Aqua SDK Dependency">
    Add the Aqua SDK to your `Cargo.toml`:

    ```toml
    [dependencies]
    aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }
    tokio = { version = "1", features = ["full"] }
    serde_json = "1.0"
    ```
  </Step>

  <Step title="Create Your First Aqua Chain">
    Update `src/main.rs`:

    ```rust
    use aqua_rs_sdk::primitives::Method;
    use aqua_rs_sdk::schema::file_data::FileData;
    use aqua_rs_sdk::Aquafier;
    use std::path::PathBuf;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating Aqua chain...");

        // Read file content
        let filename = "test.txt".to_string();
        let file_content = tokio::fs::read(&filename).await?;

        // Create file data
        let file_data = FileData::new(
            filename.clone(),
            file_content,
            PathBuf::from(format!("./{}", filename)),
        );

        // Initialize Aquafier
        let aquafier = Aquafier::new(None, None);

        // Create genesis revision (notarize the file)
        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

        match result {
            Ok(tree) => {
                println!("✓ Aqua chain created successfully!");
                println!("{}", serde_json::to_string_pretty(&tree)?);

                println!("\nYou can now:");
                println!("- Add a signature revision");
                println!("- Witness on blockchain");
                println!("- Verify the chain");
            }
            Err(e) => {
                eprintln!("Error: {:#?}", e);
            }
        }

        Ok(())
    }
    ```
  </Step>

  <Step title="Build and Run">
    ```bash
    cargo build
    cargo run
    ```

    You should see confirmation that your object revision was created!
  </Step>
</Steps>

---

## CLI Tool Quick Start

<Callout type="info">
### Prerequisites
- Rust and Cargo installed
</Callout>

<Steps>
  <Step title="Install the CLI">
    ```bash
    # Clone and build
    git clone https://github.com/inblockio/aqua-cli-rs
    cd aqua-cli-rs
    cargo build --release

    # The binary will be at target/release/aqua-cli
    ```
  </Step>

  <Step title="Verify an Aqua Chain">
    ```bash
    ./target/release/aqua-cli verify --file chain.aqua.json
    ```
  </Step>

  <Step title="Get Help">
    ```bash
    ./target/release/aqua-cli --help
    ```
  </Step>
</Steps>

See the [CLI documentation](/docs/v4.0.0/dev-tools/aqua-cli) for more commands.

---

## Troubleshooting

<Accordion Group>
  <AccordionItem  title="Node.js: Module not found error">
    **Issue**: `Cannot find module 'aqua-js-sdk'`

    **Solutions**:
    1. Ensure you ran `npm install aqua-js-sdk`
    2. Check you're in the correct directory with `package.json`
    3. Try deleting `node_modules` and `package-lock.json`, then run `npm install` again
    4. For TypeScript, ensure you have `@types/node` installed
  </AccordionItem >

  <AccordionItem  title="TypeScript: Type errors">
    **Issue**: TypeScript compilation errors

    **Solutions**:
    1. Ensure you have TypeScript installed: `npm install --save-dev typescript`
    2. Create or update `tsconfig.json`:
       ```json
       {
         "compilerOptions": {
           "target": "ES2020",
           "module": "commonjs",
           "esModuleInterop": true,
           "strict": true
         }
       }
       ```
    3. Use `tsx` for direct TypeScript execution: `npm install --save-dev tsx`
  </AccordionItem >

  <AccordionItem  title="Rust: Compilation errors">
    **Issue**: Build fails with dependency errors

    **Solutions**:
    1. Update Rust: `rustup update`
    2. Clean and rebuild: `cargo clean && cargo build`
    3. Check you're using Rust 1.70 or higher: `rustc --version`
    4. Ensure your `Cargo.toml` has the correct repository URL
  </AccordionItem >

  <AccordionItem  title="MetaMask: Not detecting in Node.js">
    **Issue**: MetaMask signing doesn't work

    **Solution**: MetaMask works in browser environments only. For Node.js:
    - Use CLI signing with mnemonic in `credentials.json`
    - Or use DID or P12 signing methods
    - See [Development Guide](/docs/v4.0.0/development) for details
  </AccordionItem >

  <AccordionItem  title="Witnessing: Network errors">
    **Issue**: Ethereum witness fails

    **Solutions**:
    1. Ensure you have ETH in your wallet (testnet ETH for Sepolia/Holesky)
    2. Get testnet ETH from faucets:
       - Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)
       - Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)
    3. Check network connectivity
    4. Verify your Alchemy API key is correct
  </AccordionItem >
</Accordion>


---

## What You've Learned

Congratulations! You've created your first Aqua chain. Here's what you accomplished:

✅ Installed an Aqua SDK (JavaScript or Rust)<br/>
✅ Created a genesis revision (notarized data)<br/>
✅ Understood the basic Aqua workflow<br/>
✅ Ready to add signatures and witnesses<br/>

## Next Steps

Now that you have the basics, dive deeper into Aqua Protocol's features:

<CardGrid  cols={2}>
  <Card title="Signing Revisions" icon="signature" href="/docs/v4.0.0/schema-reference/revision/signing-revision">
    Add cryptographic signatures with RSA, Ethereum, or DID methods
  </Card>

  <Card title="Witnessing" icon="clock" href="/docs/v4.0.0/schema-reference/revision/witness-revision">
    Anchor your chains to Ethereum, TSA, or Nostr for timestamps
  </Card>

  <Card title="Linking Chains" icon="link" href="/docs/v4.0.0/schema-reference/revision/link-revision">
    Connect multiple Aqua Trees to build complex provenance graphs
  </Card>

  <Card title="Using Templates" icon="table" href="/docs/v4.0.0/schema-reference/revision/template-revision">
    Define data schemas with JSON Schema validation (v4 only)
  </Card>

  <Card title="Development Guide" icon="code" href="/docs/v4.0.0/development">
    Complete guide for signing methods, witnessing, and advanced usage
  </Card>

  <Card title="Schema Reference" icon="book" href="/docs/v4.0.0/schema-reference/introduction">
    Detailed technical specifications for all revision types
  </Card>

  <Card title="Use Cases" icon="lightbulb" href="/docs/v4.0.0/use-cases/introduction">
    Explore real-world applications and implementation patterns
  </Card>

  <Card title="Examples" icon="github" href="https://github.com/inblockio/aqua-examples">
    Browse complete working examples in multiple languages
  </Card>
</CardGrid >

## Complete Workflow Example

Want to see the full workflow including signing and witnessing?

<Tabs defaultValue="js">
  <Tab label="js">
    Check out the [complete JavaScript example](https://github.com/inblockio/aqua-js-sdk/tree/master/examples) in the SDK repository.
  </Tab>

  <Tab label="rust">
    Check out the [Rust SDK documentation](/docs/v4.0.0/dev-tools/aqua-sdk) for complete examples.
  </Tab>
</Tabs>

## Try Aquafier

Not ready to code yet? Try our web-based demo:

<CardGrid  cols={2}>
  <Card title="Aquafier Demo" icon="globe" href="https://aquafier.inblock.io">
    Upload and notarize files through a web interface
  </Card>

  <Card title="Test Environment" icon="bug-off" href="https://dev.inblock.io">
    Experiment safely in the development environment
  </Card>
</CardGrid >

## Get Help

<CardGrid  cols={2}>
  <Card title="GitHub Issues" icon="github" href="https://github.com/inblockio">
    Report bugs or ask questions on GitHub
  </Card>

  <Card title="Email Support" icon="mail" href="mailto:info@inblock.io">
    Contact our team for assistance
  </Card>

  <Card title="Documentation" icon="book" href="/docs/v4.0.0/welcome">
    Browse comprehensive guides and references
  </Card>

  <Card title="Community" icon="users" href="https://github.com/inblockio/aqua-examples/discussions">
    Join discussions with other developers
  </Card>
</CardGrid >

---

<Callout type="note" >
**Ready to build?** Start with the [Development Guide](/docs/v4.0.0/development) for detailed instructions on signing, witnessing, and advanced features.
</Callout  >
c:T2457,
# File Index

The **File Index** is a component of the Aqua Tree that maps content hashes to human-readable filenames. It provides context about what each hash represents, making Aqua Trees more understandable and navigable.

## Purpose

When content is hashed (documents, images, data files), the resulting hash is a cryptographic string that provides no information about the original content. The file index solves this by maintaining a mapping between:

- **Content hashes**: SHA3-256 hashes of file content
- **Filenames**: Human-readable names that describe the content

This enables users and applications to understand what content each hash represents without needing to store or transmit the actual content.

## Structure

The file index is a simple key-value object:

```json
{
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "document.pdf",
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "test.txt",
    "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9": "image.png"
  }
}
```

### Field Format

| Component | Description | Format |
|-----------|-------------|--------|
| **Key** | Content hash | Hex string prefixed with `0x`, typically 64 characters (SHA3-256) |
| **Value** | Filename | String, typically includes file extension |

## Hash Sources

File index entries can reference hashes from several sources:

### 1. Object Revision Payloads

When an object revision contains content:

```json
{
  "revisions": {
    "0xrev_hash...": {
      "payload": {
        "hash": "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28",
        "payload_type": "application/pdf",
        "descriptor": "Contract Document"
      }
    }
  },
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "contract.pdf"
  }
}
```

### 2. Linked External Trees

When link revisions reference other Aqua Trees:

```json
{
  "revisions": {
    "0xlink_hash...": {
      "revision_type": "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f",
      "links": [
        {
          "verification_hash": "0xexternal_tree_hash...",
          "content_hash": "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9"
        }
      ]
    }
  },
  "file_index": {
    "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9": "component_tree.aqua.json"
  }
}
```

### 3. Template Content

When template revisions define schemas:

```json
{
  "file_index": {
    "0xtemplate_hash...": "user_credential_schema.json"
  }
}
```

## Complete Example

Here's a complete Aqua Tree showing how file_index integrates:

```json
{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "application/pdf",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Sales Contract"
      }
    },
    "0xsig_hash...": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x...",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "sales_contract_2024.pdf"
  }
}
```

## Benefits

### 1. Human Readability

Users can understand what content is in the tree without decoding hashes:

```json
"file_index": {
  "0xabc...": "proposal.docx",
  "0xdef...": "budget.xlsx",
  "0x123...": "diagram.png"
}
```

Instead of just seeing cryptographic hashes, users see meaningful filenames.

### 2. Content Discovery

Applications can list available content:

```typescript
const filenames = Object.values(aquaTree.file_index);
console.log("Available files:", filenames);
// Output: ["proposal.docx", "budget.xlsx", "diagram.png"]
```

### 3. Reverse Lookup

Find the hash for a known filename:

```typescript
function findHashByFilename(aquaTree, filename) {
  return Object.entries(aquaTree.file_index)
    .find(([_, name]) => name === filename)?.[0];
}

const hash = findHashByFilename(tree, "contract.pdf");
```

### 4. Linked Tree Context

When trees link to external trees, the file index identifies them:

```json
"file_index": {
  "0xhash1...": "main_document.pdf",
  "0xhash2...": "appendix_a.aqua.json",  // External tree
  "0xhash3...": "appendix_b.aqua.json"   // External tree
}
```

## Best Practices

### Descriptive Filenames

Use clear, descriptive names with appropriate extensions:

```json
// Good
"file_index": {
  "0xabc...": "employment_contract_john_doe_2024.pdf",
  "0xdef...": "diploma_computer_science_2024.pdf"
}

// Avoid
"file_index": {
  "0xabc...": "file1.dat",
  "0xdef...": "doc.bin"
}
```

### Include Extensions

Always include file extensions to indicate content type:

```json
"file_index": {
  "0xabc...": "document.pdf",      // PDF document
  "0xdef...": "image.png",          // PNG image
  "0x123...": "data.json",          // JSON data
  "0x456...": "archive.zip",        // Compressed archive
  "0x789...": "video.mp4"           // Video file
}
```

### Unique Names

Ensure filenames are unique within a tree to avoid ambiguity:

```json
// Good - unique names
"file_index": {
  "0xabc...": "contract_v1.pdf",
  "0xdef...": "contract_v2.pdf"
}

// Avoid - duplicate names
"file_index": {
  "0xabc...": "contract.pdf",
  "0xdef...": "contract.pdf"  // Ambiguous!
}
```

### External Tree Naming

For linked external trees, use the `.aqua.json` extension:

```json
"file_index": {
  "0xhash...": "component_a.aqua.json",
  "0xhash...": "dependency_b.aqua.json"
}
```

## Optional Nature

While the file index is a standard component of Aqua Trees, entries are **optional**:

- Not all hashes need file index entries
- The tree remains valid without file_index
- Applications can function using hashes alone

However, including file index entries significantly improves usability.

## Validation

The file index should be validated for:

### 1. Hash Format

All keys must be valid hex strings:

```typescript
function isValidHash(hash: string): boolean {
  return /^0x[0-9a-fA-F]{64}$/.test(hash);
}
```

### 2. Referenced Hashes

Hashes in file_index should appear in revisions:

```typescript
function validateFileIndex(aquaTree) {
  const referencedHashes = new Set();

  // Collect all content hashes from revisions
  Object.values(aquaTree.revisions).forEach(rev => {
    if (rev.payload?.hash) {
      referencedHashes.add(rev.payload.hash);
    }
    if (rev.links) {
      rev.links.forEach(link => referencedHashes.add(link.content_hash));
    }
  });

  // Check file_index entries
  for (const hash of Object.keys(aquaTree.file_index)) {
    if (!referencedHashes.has(hash)) {
      console.warn(`Orphaned file_index entry: ${hash}`);
    }
  }
}
```

### 3. Filename Validity

Filenames should not contain invalid characters:

```typescript
function isValidFilename(filename: string): boolean {
  // Avoid: null bytes, path separators, control characters
  return !/[\x00\/\\]/.test(filename);
}
```

## Use Cases

### Document Management Systems

Track document names across revisions:

```json
"file_index": {
  "0xv1...": "proposal_draft_v1.docx",
  "0xv2...": "proposal_draft_v2.docx",
  "0xfinal...": "proposal_final.docx"
}
```

### Multi-File Projects

Reference multiple files in a project:

```json
"file_index": {
  "0xreadme...": "README.md",
  "0xcode...": "main.rs",
  "0xconfig...": "config.toml",
  "0xdocs...": "documentation.pdf"
}
```

### Supply Chain Tracking

Identify product-related documents:

```json
"file_index": {
  "0xcert...": "organic_certification.pdf",
  "0xinspect...": "quality_inspection_report.pdf",
  "0xship...": "shipping_manifest.pdf"
}
```

### Credential Systems

Map credential hashes to recipient identifiers:

```json
"file_index": {
  "0xdiploma...": "diploma_john_doe_2024.pdf",
  "0xtranscript...": "transcript_john_doe_2024.pdf"
}
```

## Storage Considerations

### Size Impact

Each file index entry adds approximately 100-150 bytes:
- 64-character hash: ~66 bytes
- Filename: 20-50 bytes typical
- JSON overhead: ~20 bytes

For large trees, this is minimal compared to revision data.

### Compression

File index compresses well with gzip due to repetitive patterns:
- Hash prefixes (`0x`)
- Common file extensions (`.pdf`, `.json`)

## Related Documentation

- [Aqua Tree](/docs/v4.0.0/schema-reference/aqua-tree) - Complete tree structure
- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Revisions containing content hashes
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Linking to external trees
- [Template Revision](/docs/v4.0.0/schema-reference/revision/template-revision) - Schema definitions
d:T2457,
# File Index

The **File Index** is a component of the Aqua Tree that maps content hashes to human-readable filenames. It provides context about what each hash represents, making Aqua Trees more understandable and navigable.

## Purpose

When content is hashed (documents, images, data files), the resulting hash is a cryptographic string that provides no information about the original content. The file index solves this by maintaining a mapping between:

- **Content hashes**: SHA3-256 hashes of file content
- **Filenames**: Human-readable names that describe the content

This enables users and applications to understand what content each hash represents without needing to store or transmit the actual content.

## Structure

The file index is a simple key-value object:

```json
{
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "document.pdf",
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "test.txt",
    "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9": "image.png"
  }
}
```

### Field Format

| Component | Description | Format |
|-----------|-------------|--------|
| **Key** | Content hash | Hex string prefixed with `0x`, typically 64 characters (SHA3-256) |
| **Value** | Filename | String, typically includes file extension |

## Hash Sources

File index entries can reference hashes from several sources:

### 1. Object Revision Payloads

When an object revision contains content:

```json
{
  "revisions": {
    "0xrev_hash...": {
      "payload": {
        "hash": "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28",
        "payload_type": "application/pdf",
        "descriptor": "Contract Document"
      }
    }
  },
  "file_index": {
    "0xe1bcaa92b0ea2f0eb1f046ca4fc877f26726e5bec8b1a5cf25504a29bc4e0f28": "contract.pdf"
  }
}
```

### 2. Linked External Trees

When link revisions reference other Aqua Trees:

```json
{
  "revisions": {
    "0xlink_hash...": {
      "revision_type": "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f",
      "links": [
        {
          "verification_hash": "0xexternal_tree_hash...",
          "content_hash": "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9"
        }
      ]
    }
  },
  "file_index": {
    "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9": "component_tree.aqua.json"
  }
}
```

### 3. Template Content

When template revisions define schemas:

```json
{
  "file_index": {
    "0xtemplate_hash...": "user_credential_schema.json"
  }
}
```

## Complete Example

Here's a complete Aqua Tree showing how file_index integrates:

```json
{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "application/pdf",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Sales Contract"
      }
    },
    "0xsig_hash...": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x...",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "sales_contract_2024.pdf"
  }
}
```

## Benefits

### 1. Human Readability

Users can understand what content is in the tree without decoding hashes:

```json
"file_index": {
  "0xabc...": "proposal.docx",
  "0xdef...": "budget.xlsx",
  "0x123...": "diagram.png"
}
```

Instead of just seeing cryptographic hashes, users see meaningful filenames.

### 2. Content Discovery

Applications can list available content:

```typescript
const filenames = Object.values(aquaTree.file_index);
console.log("Available files:", filenames);
// Output: ["proposal.docx", "budget.xlsx", "diagram.png"]
```

### 3. Reverse Lookup

Find the hash for a known filename:

```typescript
function findHashByFilename(aquaTree, filename) {
  return Object.entries(aquaTree.file_index)
    .find(([_, name]) => name === filename)?.[0];
}

const hash = findHashByFilename(tree, "contract.pdf");
```

### 4. Linked Tree Context

When trees link to external trees, the file index identifies them:

```json
"file_index": {
  "0xhash1...": "main_document.pdf",
  "0xhash2...": "appendix_a.aqua.json",  // External tree
  "0xhash3...": "appendix_b.aqua.json"   // External tree
}
```

## Best Practices

### Descriptive Filenames

Use clear, descriptive names with appropriate extensions:

```json
// Good
"file_index": {
  "0xabc...": "employment_contract_john_doe_2024.pdf",
  "0xdef...": "diploma_computer_science_2024.pdf"
}

// Avoid
"file_index": {
  "0xabc...": "file1.dat",
  "0xdef...": "doc.bin"
}
```

### Include Extensions

Always include file extensions to indicate content type:

```json
"file_index": {
  "0xabc...": "document.pdf",      // PDF document
  "0xdef...": "image.png",          // PNG image
  "0x123...": "data.json",          // JSON data
  "0x456...": "archive.zip",        // Compressed archive
  "0x789...": "video.mp4"           // Video file
}
```

### Unique Names

Ensure filenames are unique within a tree to avoid ambiguity:

```json
// Good - unique names
"file_index": {
  "0xabc...": "contract_v1.pdf",
  "0xdef...": "contract_v2.pdf"
}

// Avoid - duplicate names
"file_index": {
  "0xabc...": "contract.pdf",
  "0xdef...": "contract.pdf"  // Ambiguous!
}
```

### External Tree Naming

For linked external trees, use the `.aqua.json` extension:

```json
"file_index": {
  "0xhash...": "component_a.aqua.json",
  "0xhash...": "dependency_b.aqua.json"
}
```

## Optional Nature

While the file index is a standard component of Aqua Trees, entries are **optional**:

- Not all hashes need file index entries
- The tree remains valid without file_index
- Applications can function using hashes alone

However, including file index entries significantly improves usability.

## Validation

The file index should be validated for:

### 1. Hash Format

All keys must be valid hex strings:

```typescript
function isValidHash(hash: string): boolean {
  return /^0x[0-9a-fA-F]{64}$/.test(hash);
}
```

### 2. Referenced Hashes

Hashes in file_index should appear in revisions:

```typescript
function validateFileIndex(aquaTree) {
  const referencedHashes = new Set();

  // Collect all content hashes from revisions
  Object.values(aquaTree.revisions).forEach(rev => {
    if (rev.payload?.hash) {
      referencedHashes.add(rev.payload.hash);
    }
    if (rev.links) {
      rev.links.forEach(link => referencedHashes.add(link.content_hash));
    }
  });

  // Check file_index entries
  for (const hash of Object.keys(aquaTree.file_index)) {
    if (!referencedHashes.has(hash)) {
      console.warn(`Orphaned file_index entry: ${hash}`);
    }
  }
}
```

### 3. Filename Validity

Filenames should not contain invalid characters:

```typescript
function isValidFilename(filename: string): boolean {
  // Avoid: null bytes, path separators, control characters
  return !/[\x00\/\\]/.test(filename);
}
```

## Use Cases

### Document Management Systems

Track document names across revisions:

```json
"file_index": {
  "0xv1...": "proposal_draft_v1.docx",
  "0xv2...": "proposal_draft_v2.docx",
  "0xfinal...": "proposal_final.docx"
}
```

### Multi-File Projects

Reference multiple files in a project:

```json
"file_index": {
  "0xreadme...": "README.md",
  "0xcode...": "main.rs",
  "0xconfig...": "config.toml",
  "0xdocs...": "documentation.pdf"
}
```

### Supply Chain Tracking

Identify product-related documents:

```json
"file_index": {
  "0xcert...": "organic_certification.pdf",
  "0xinspect...": "quality_inspection_report.pdf",
  "0xship...": "shipping_manifest.pdf"
}
```

### Credential Systems

Map credential hashes to recipient identifiers:

```json
"file_index": {
  "0xdiploma...": "diploma_john_doe_2024.pdf",
  "0xtranscript...": "transcript_john_doe_2024.pdf"
}
```

## Storage Considerations

### Size Impact

Each file index entry adds approximately 100-150 bytes:
- 64-character hash: ~66 bytes
- Filename: 20-50 bytes typical
- JSON overhead: ~20 bytes

For large trees, this is minimal compared to revision data.

### Compression

File index compresses well with gzip due to repetitive patterns:
- Hash prefixes (`0x`)
- Common file extensions (`.pdf`, `.json`)

## Related Documentation

- [Aqua Tree](/docs/v4.0.0/schema-reference/aqua-tree) - Complete tree structure
- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Revisions containing content hashes
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Linking to external trees
- [Template Revision](/docs/v4.0.0/schema-reference/revision/template-revision) - Schema definitions
e:T3ac1,
<Callout type="info" title="Prerequisites">
We recommend completing the [Quick Start Guide](/docs/v4.0.0/quickstart) before diving into development details.
</Callout>

## Choose Your SDK

Aqua Protocol offers SDKs for different use cases:

<CardGrid cols={2}>
  <Card title="Rust SDK (v4)" icon="code" href="/docs/v4.0.0/dev-tools/aqua-sdk">
    **Beta** - Template system, WASM support, cross-platform

    Best for: New projects, performance-critical applications
  </Card>

  <Card title="JavaScript SDK (v3)" icon="code" href="/docs/v3.0.2/tooling">
    **Stable** - Production-ready, Node.js/Web/React Native

    Best for: Web applications, existing JavaScript projects
  </Card>

  <Card title="CLI Tool (v4)" icon="terminal" href="/docs/v4.0.0/dev-tools/aqua-cli">
    Command-line tool for quick operations

    Best for: Testing, CI/CD, scripting
  </Card>

  <Card title="Aquafier API (v3)" icon="globe" href="/docs/v4.0.0/dev-tools/aquafier-api">
    Web-based API for notarization

    Best for: No-code integration, demos
  </Card>
</CardGrid>

## Signing Methods

Aqua Protocol supports multiple signature types for different use cases:

| Method | Protocol Version | Use Case | Trust Model |
|--------|-----------------|----------|-------------|
| **DID (JWS)** | v3, v4 | Decentralized identities | W3C DID standard |
| **Ethereum (EIP-191)** | v3, v4 | Blockchain-native apps | Ethereum addresses |
| **RSA** | v4 only | Traditional PKI | Certificate authorities |
| **P12 Certificates** | v3 only | Enterprise/legal docs | Certificate authorities |


### Signing Setup Details

<Accordion title="DID Signature (W3C Decentralized Identifiers)">
**What you need**: A DID key pair

**How to generate**:

**Option 1: Using JavaScript**
```bash
npm install @digitalcredentials/did-method-key
```

```javascript
import { Ed25519VerificationKey2020 } from '@digitalcredentials/ed25519-verification-key-2020';
import { X25519KeyAgreementKey2020 } from '@digitalcredentials/x25519-key-agreement-key-2020';

const keyPair = await Ed25519VerificationKey2020.generate();
const did = `did:key:${keyPair.publicKeyMultibase}`;
console.log('DID:', did);
console.log('Private Key:', keyPair.privateKeyMultibase);
```

**Option 2: Online Generator**
- Visit [EBSI DID Generator](https://hub.ebsi.eu/tools/did-generator)
- Click "Generate Keys"
- Save your DID and private key securely

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Ethereum Signature (EIP-191)">
**What you need**: Ethereum wallet with private key or mnemonic

**Two supported methods**:

**1. MetaMask Browser Extension** (Recommended for development)
- Install [MetaMask](https://metamask.io/) in your browser
- Create or import a wallet
- The SDK will prompt for signature when needed

**2. Mnemonic/Private Key in Credentials File**

Create a `credentials.json` file:
```json
{
  "mnemonic": "your twelve word mnemonic phrase here...",
  "wallet_address": "0xYourEthereumAddress"
}
```

Or with private key:
```json
{
  "private_key": "0xYourPrivateKeyHex",
  "wallet_address": "0xYourEthereumAddress"
}
```

<Callout type="warning" title="Security">
Never commit credentials.json to version control! Add it to `.gitignore`.
</Callout>

Check your SDK documentation ([Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) | [JavaScript SDK](/docs/v3.0.2/tooling)) for how to pass credentials.

**Protocol Support**: v3, v4

</Accordion>

<Accordion title="RSA Signature (v4 only)">
**What you need**: RSA key pair (2048-bit or higher)

**Generate RSA keys**:

```bash
# Generate private key (2048-bit)
openssl genrsa -out private.pem 2048

# Extract public key
openssl rsa -in private.pem -pubout -out public.pem

# View keys
cat private.pem
cat public.pem
```

**For production**: Use keys from your organization's PKI infrastructure or certificate authority.

**Protocol Support**: v4 only
</Accordion>

<Accordion title="P12 Certificate Signature (v3 only)">
**What you need**: PKCS#12 certificate file (.p12/.pfx) with password

**For Development** (self-signed certificate):

```bash
# Generate private key
openssl genrsa -out private.key 2048

# Create certificate signing request
openssl req -new -key private.key -out certificate.csr

# For Windows/Git Bash, specify config:
# openssl req -new -key private.key -out certificate.csr -config "C:\Program Files\Git\usr\ssl\openssl.cnf"

# Generate self-signed certificate (valid for 365 days)
openssl x509 -req -days 365 -in certificate.csr -signkey private.key -out certificate.crt

# Create P12 file (you'll be prompted for export password)
openssl pkcs12 -export -out certificate.p12 -inkey private.key -in certificate.crt
```

**Convert to Base64** (required for SDK):
```bash
# macOS/Linux
base64 -i certificate.p12 -o certificate_base64.txt

# Windows (PowerShell)
[Convert]::ToBase64String([IO.File]::ReadAllBytes("certificate.p12")) | Out-File certificate_base64.txt

# Linux alternative
base64 certificate.p12 > certificate_base64.txt
```

**For Production** (trusted certificate):

 **1. Purchase from Certificate Authority**:
   - DigiCert, Sectigo, GlobalSign, etc.
   - Request "Code Signing" or "Document Signing" certificate
   - They'll provide a .p12/.pfx file directly

**2. If you receive separate files** (.crt + .key + intermediate):
   ```bash
   openssl pkcs12 -export -out certificate.p12 \
       -inkey privatekey.key \
       -in certificate.crt \
       -certfile intermediate.crt
   ```

**Usage in SDK**:
```json
{
  "p12_content": "base64_encoded_p12_content_here",
  "p12_password": "your_export_password"
}
```

**Protocol Support**: v3 only
</Accordion>

## Witnessing Methods

Witnessing anchors your Aqua revisions to external timestamping services for provable timestamps:

| Method | Networks | Cost | Verification |
|--------|----------|------|--------------|
| **Ethereum** | Mainnet, Sepolia, Holesky | Gas fees (testnet: free) | Blockchain explorer |
| **TSA** | RFC 3161 services | Free (public TSAs) | TSA verification |
| **Nostr** | Nostr relays | Free | Nostr event verification |

### Witnessing Setup Details

<Accordion title="TSA Witness (Time-Stamp Authority - RFC 3161)">
**What you need**: A TSA service URL

**Free Public TSA Services**:

```bash
# DigiCert
http://timestamp.digicert.com

# Sectigo (formerly Comodo)
http://timestamp.sectigo.com
http://timestamp.comodoca.com

# GlobalSign
http://timestamp.globalsign.com/scripts/timstamp.dll
http://timestamp.globalsign.com/tsa/r6advanced1

# Entrust
http://timestamp.entrust.net/TSS/RFC3161sha2TS
```

**Usage**: Simply provide the TSA URL to your SDK when witnessing.

**Benefits**:
- No blockchain required
- Widely accepted standard (RFC 3161)
- Free for most public TSAs
- Instant timestamps

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Ethereum Witness">
**What you need**:
1. Ethereum wallet (MetaMask or mnemonic/private key)
2. ETH for gas fees (mainnet) or testnet ETH (Sepolia/Holesky)
3. Alchemy API key for witness verification

**Networks Supported**:
- **Mainnet**: Production use, requires real ETH for gas
- **Sepolia**: Testnet, free test ETH from faucets
- **Holesky**: Testnet, free test ETH from faucets

**Wallet Setup** (same as signing):

**Option 1: MetaMask**
- Install [MetaMask](https://metamask.io/)
- Ensure you're on the correct network (mainnet/sepolia/holesky)
- Have sufficient ETH for gas fees

**Option 2: Credentials File**
```json
{
  "mnemonic": "your twelve word mnemonic phrase here...",
  "wallet_address": "0xYourEthereumAddress"
}
```

**Get Test ETH** (for testnets):
- Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)
- Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)

**Alchemy API Key** (for verification):
1. Visit [alchemy.com](https://www.alchemy.com/)
2. Create free account
3. Create new app
4. Copy API key
5. [Detailed guide](https://www.alchemy.com/docs/how-to-create-access-keys)

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Nostr Witness">
**What you need**: Nostr secret key (nsec)

**How to get a Nostr key**:

**Option 1: Nostr Client App**
1. Download a Nostr app:
   - [Damus](https://damus.io/) (iOS)
   - [Amethyst](https://github.com/vitorpamplona/amethyst) (Android)
   - [Primal](https://primal.net/) (Web/Mobile)
2. Create new account or log in
3. App generates a key pair automatically
4. Your secret key starts with `nsec1...`
5. **Save it securely** - you'll need it for witnessing

**Option 2: Web Generator**
- Visit [nostr.com](https://nostr.com) or [nostrtool.com](https://nostrtool.com)
- Click "Generate Keys"
- Save your secret key (`nsec1...`)

<Callout type="warning" title="Security">
Your Nostr secret key is permanent. Anyone with it can post as you on Nostr relays. Keep it secure!
</Callout>

**Benefits**:
- Fully decentralized (no blockchain fees)
- Censorship-resistant
- Fast propagation across relays
- Free to use

**Protocol Support**: v3, v4
</Accordion>



## JavaScript SDK Usage (v3)

<Callout type="info" title="Prerequisites">
- Node.js version 19 or higher
- Install aqua-js-sdk: `npm install aqua-js-sdk`
</Callout>

### Complete Workflow Example

Follow these steps to notarize a file, sign it, and witness it using the JavaScript SDK (v3):

<Steps>
<Step title="Create Genesis Revision">

```typescript
import Aquafier, { FileObject } from 'aqua-js-sdk';
import { readFileSync } from 'fs';

// Read file content
const testFileContent = readFileSync("./test.txt", 'utf-8');

// Create file object
const aquaFileObject: FileObject = {
    fileName: "test.txt",
    fileContent: testFileContent,
    path: "./test.txt"
};

// Initialize Aquafier
const aquafier = new Aquafier();

// Create genesis revision (notarize the file)
const genesisResult = await aquafier.createGenesisRevision(aquaFileObject);

if (genesisResult.isOk()) {
    console.log("Genesis created successfully!");
    console.log("Aqua Tree:", genesisResult.data.aquaTree);
} else {
    console.error("Error creating genesis:", genesisResult.error);
}
```
</Step>

<Step title="Sign the Aqua Tree">

```typescript
import { AquaTreeWrapper, CredentialsData } from 'aqua-js-sdk';

// Prepare credentials (for MetaMask, can be empty object)
const creds: CredentialsData = {};

// Or for CLI signing with mnemonic:
// const creds: CredentialsData = {
//     mnemonic: "your twelve word mnemonic here",
//     wallet_address: "0xYourAddress"
// };

// Create wrapper (empty string for revision means sign latest)
const aquaWrapper: AquaTreeWrapper = {
    aquaTree: genesisResult.data.aquaTree,
    fileObject: aquaFileObject,
    revision: ""  // Sign latest revision
};

// Sign with MetaMask (or use "cli", "did", "p12")
const signedResult = await aquafier.signAquaTree(
    aquaWrapper,
    "metamask",  // Signature type
    creds,
    true         // Auto-increment
);

if (signedResult.isOk()) {
    console.log("Signature added successfully!");
} else {
    console.error("Signing failed:", signedResult.error);
}
```
</Step>

<Step title="Witness on Blockchain">

```typescript
// Update wrapper with signed tree
const witnessWrapper: AquaTreeWrapper = {
    aquaTree: signedResult.data.aquaTree,
    fileObject: aquaFileObject,
    revision: ""  // Witness latest revision
};

// Witness on Ethereum Sepolia testnet
const witnessResult = await aquafier.witnessAquaTree(
    witnessWrapper,
    "eth",        // Witness type (eth, tsa, or nostr)
    "sepolia",    // Network (sepolia, mainnet, holesky)
    "metamask",   // Signing method
    creds,
    true          // Auto-increment
);

if (witnessResult.isOk()) {
    console.log("Witnessing successful!");
    console.log("Transaction:", witnessResult.data.witness_transaction_hash);
} else {
    console.error("Witnessing failed:", witnessResult.error);
}
```
</Step>

<Step title="Verify the Aqua Tree">

```typescript
// Fetch aqua tree from storage, database, or state
const aquaTree = witnessResult.data.aquaTree;

// Prepare credentials for verification (needs Alchemy key for Ethereum witness)
const verifyCreds: CredentialsData = {
    alchemy_key: "your_alchemy_api_key"
};

// Verify the complete tree
const verificationResult = await aquafier.verifyAquaTree(
    aquaTree,
    [aquaFileObject],  // Array of file objects
    verifyCreds
);

if (verificationResult.isOk()) {
    console.log("✓ Verification successful!");
    console.log("Details:", JSON.stringify(verificationResult.data, null, 2));
} else {
    console.log("✗ Verification failed!");
    console.log("Details:", JSON.stringify(verificationResult.data, null, 2));
}
```
</Step>
</Steps>

### More Examples

<CardGrid cols={2}>
  <Card title="Complete Examples" icon="github" href="https://github.com/inblockio/aqua-js-sdk/tree/master/examples">
    Browse full working examples in the repository
  </Card>

  <Card title="API Documentation" icon="book" href="/docs/v3.0.2/tooling">
    Detailed API reference for JavaScript SDK
  </Card>
</CardGrid>

## Rust SDK Usage (v4)

<Callout type="info" title="Prerequisites">
- Rust 1.70 or higher
- Add to Cargo.toml: `aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }`
</Callout>

### Quick Example

```rust
use aqua_rs_sdk::primitives::Method;
use aqua_rs_sdk::schema::file_data::FileData;
use aqua_rs_sdk::Aquafier;
use std::path::PathBuf;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Read file content
    let filename = "test.txt".to_string();
    let file_content = tokio::fs::read(&filename).await?;

    // Create file data
    let file_data = FileData::new(
        filename.clone(),
        file_content,
        PathBuf::from(format!("./{}", filename)),
    );

    // Initialize Aquafier
    let aquafier = Aquafier::new(None, None);

    // Create genesis revision (notarize the file)
    let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

    match result {
        Ok(tree) => {
            println!("✓ Aqua chain created successfully!");
            println!("{}", serde_json::to_string_pretty(&tree)?);
        }
        Err(e) => {
            eprintln!("Error: {:#?}", e);
        }
    }

    Ok(())
}
```

### More Resources

<CardGrid cols={2}>
  <Card title="Rust SDK Guide" icon="code" href="/docs/v4.0.0/dev-tools/aqua-sdk">
    Complete guide for the Rust SDK
  </Card>

  <Card title="Schema Reference" icon="book" href="/docs/v4.0.0/schema-reference/introduction">
    v4 protocol specifications
  </Card>
</CardGrid>

## Next Steps

<CardGrid cols={2}>
  <Card title="Use Cases" icon="lightbulb" href="/docs/v4.0.0/use-cases/introduction">
    Explore real-world applications
  </Card>

  <Card title="Quick Start" icon="rocket" href="/docs/v4.0.0/quickstart">
    Build your first Aqua application
  </Card>

  <Card title="Examples Repository" icon="code" href="https://github.com/inblockio/aqua-examples">
    Browse complete examples
  </Card>

  <Card title="Get Support" icon="mail" href="mailto:info@inblock.io">
    Need help? Contact our team
  </Card>
</CardGrid>f:T3ac1,
<Callout type="info" title="Prerequisites">
We recommend completing the [Quick Start Guide](/docs/v4.0.0/quickstart) before diving into development details.
</Callout>

## Choose Your SDK

Aqua Protocol offers SDKs for different use cases:

<CardGrid cols={2}>
  <Card title="Rust SDK (v4)" icon="code" href="/docs/v4.0.0/dev-tools/aqua-sdk">
    **Beta** - Template system, WASM support, cross-platform

    Best for: New projects, performance-critical applications
  </Card>

  <Card title="JavaScript SDK (v3)" icon="code" href="/docs/v3.0.2/tooling">
    **Stable** - Production-ready, Node.js/Web/React Native

    Best for: Web applications, existing JavaScript projects
  </Card>

  <Card title="CLI Tool (v4)" icon="terminal" href="/docs/v4.0.0/dev-tools/aqua-cli">
    Command-line tool for quick operations

    Best for: Testing, CI/CD, scripting
  </Card>

  <Card title="Aquafier API (v3)" icon="globe" href="/docs/v4.0.0/dev-tools/aquafier-api">
    Web-based API for notarization

    Best for: No-code integration, demos
  </Card>
</CardGrid>

## Signing Methods

Aqua Protocol supports multiple signature types for different use cases:

| Method | Protocol Version | Use Case | Trust Model |
|--------|-----------------|----------|-------------|
| **DID (JWS)** | v3, v4 | Decentralized identities | W3C DID standard |
| **Ethereum (EIP-191)** | v3, v4 | Blockchain-native apps | Ethereum addresses |
| **RSA** | v4 only | Traditional PKI | Certificate authorities |
| **P12 Certificates** | v3 only | Enterprise/legal docs | Certificate authorities |


### Signing Setup Details

<Accordion title="DID Signature (W3C Decentralized Identifiers)">
**What you need**: A DID key pair

**How to generate**:

**Option 1: Using JavaScript**
```bash
npm install @digitalcredentials/did-method-key
```

```javascript
import { Ed25519VerificationKey2020 } from '@digitalcredentials/ed25519-verification-key-2020';
import { X25519KeyAgreementKey2020 } from '@digitalcredentials/x25519-key-agreement-key-2020';

const keyPair = await Ed25519VerificationKey2020.generate();
const did = `did:key:${keyPair.publicKeyMultibase}`;
console.log('DID:', did);
console.log('Private Key:', keyPair.privateKeyMultibase);
```

**Option 2: Online Generator**
- Visit [EBSI DID Generator](https://hub.ebsi.eu/tools/did-generator)
- Click "Generate Keys"
- Save your DID and private key securely

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Ethereum Signature (EIP-191)">
**What you need**: Ethereum wallet with private key or mnemonic

**Two supported methods**:

**1. MetaMask Browser Extension** (Recommended for development)
- Install [MetaMask](https://metamask.io/) in your browser
- Create or import a wallet
- The SDK will prompt for signature when needed

**2. Mnemonic/Private Key in Credentials File**

Create a `credentials.json` file:
```json
{
  "mnemonic": "your twelve word mnemonic phrase here...",
  "wallet_address": "0xYourEthereumAddress"
}
```

Or with private key:
```json
{
  "private_key": "0xYourPrivateKeyHex",
  "wallet_address": "0xYourEthereumAddress"
}
```

<Callout type="warning" title="Security">
Never commit credentials.json to version control! Add it to `.gitignore`.
</Callout>

Check your SDK documentation ([Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) | [JavaScript SDK](/docs/v3.0.2/tooling)) for how to pass credentials.

**Protocol Support**: v3, v4

</Accordion>

<Accordion title="RSA Signature (v4 only)">
**What you need**: RSA key pair (2048-bit or higher)

**Generate RSA keys**:

```bash
# Generate private key (2048-bit)
openssl genrsa -out private.pem 2048

# Extract public key
openssl rsa -in private.pem -pubout -out public.pem

# View keys
cat private.pem
cat public.pem
```

**For production**: Use keys from your organization's PKI infrastructure or certificate authority.

**Protocol Support**: v4 only
</Accordion>

<Accordion title="P12 Certificate Signature (v3 only)">
**What you need**: PKCS#12 certificate file (.p12/.pfx) with password

**For Development** (self-signed certificate):

```bash
# Generate private key
openssl genrsa -out private.key 2048

# Create certificate signing request
openssl req -new -key private.key -out certificate.csr

# For Windows/Git Bash, specify config:
# openssl req -new -key private.key -out certificate.csr -config "C:\Program Files\Git\usr\ssl\openssl.cnf"

# Generate self-signed certificate (valid for 365 days)
openssl x509 -req -days 365 -in certificate.csr -signkey private.key -out certificate.crt

# Create P12 file (you'll be prompted for export password)
openssl pkcs12 -export -out certificate.p12 -inkey private.key -in certificate.crt
```

**Convert to Base64** (required for SDK):
```bash
# macOS/Linux
base64 -i certificate.p12 -o certificate_base64.txt

# Windows (PowerShell)
[Convert]::ToBase64String([IO.File]::ReadAllBytes("certificate.p12")) | Out-File certificate_base64.txt

# Linux alternative
base64 certificate.p12 > certificate_base64.txt
```

**For Production** (trusted certificate):

 **1. Purchase from Certificate Authority**:
   - DigiCert, Sectigo, GlobalSign, etc.
   - Request "Code Signing" or "Document Signing" certificate
   - They'll provide a .p12/.pfx file directly

**2. If you receive separate files** (.crt + .key + intermediate):
   ```bash
   openssl pkcs12 -export -out certificate.p12 \
       -inkey privatekey.key \
       -in certificate.crt \
       -certfile intermediate.crt
   ```

**Usage in SDK**:
```json
{
  "p12_content": "base64_encoded_p12_content_here",
  "p12_password": "your_export_password"
}
```

**Protocol Support**: v3 only
</Accordion>

## Witnessing Methods

Witnessing anchors your Aqua revisions to external timestamping services for provable timestamps:

| Method | Networks | Cost | Verification |
|--------|----------|------|--------------|
| **Ethereum** | Mainnet, Sepolia, Holesky | Gas fees (testnet: free) | Blockchain explorer |
| **TSA** | RFC 3161 services | Free (public TSAs) | TSA verification |
| **Nostr** | Nostr relays | Free | Nostr event verification |

### Witnessing Setup Details

<Accordion title="TSA Witness (Time-Stamp Authority - RFC 3161)">
**What you need**: A TSA service URL

**Free Public TSA Services**:

```bash
# DigiCert
http://timestamp.digicert.com

# Sectigo (formerly Comodo)
http://timestamp.sectigo.com
http://timestamp.comodoca.com

# GlobalSign
http://timestamp.globalsign.com/scripts/timstamp.dll
http://timestamp.globalsign.com/tsa/r6advanced1

# Entrust
http://timestamp.entrust.net/TSS/RFC3161sha2TS
```

**Usage**: Simply provide the TSA URL to your SDK when witnessing.

**Benefits**:
- No blockchain required
- Widely accepted standard (RFC 3161)
- Free for most public TSAs
- Instant timestamps

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Ethereum Witness">
**What you need**:
1. Ethereum wallet (MetaMask or mnemonic/private key)
2. ETH for gas fees (mainnet) or testnet ETH (Sepolia/Holesky)
3. Alchemy API key for witness verification

**Networks Supported**:
- **Mainnet**: Production use, requires real ETH for gas
- **Sepolia**: Testnet, free test ETH from faucets
- **Holesky**: Testnet, free test ETH from faucets

**Wallet Setup** (same as signing):

**Option 1: MetaMask**
- Install [MetaMask](https://metamask.io/)
- Ensure you're on the correct network (mainnet/sepolia/holesky)
- Have sufficient ETH for gas fees

**Option 2: Credentials File**
```json
{
  "mnemonic": "your twelve word mnemonic phrase here...",
  "wallet_address": "0xYourEthereumAddress"
}
```

**Get Test ETH** (for testnets):
- Sepolia: [sepoliafaucet.com](https://sepoliafaucet.com)
- Holesky: [holesky-faucet.pk910.de](https://holesky-faucet.pk910.de)

**Alchemy API Key** (for verification):
1. Visit [alchemy.com](https://www.alchemy.com/)
2. Create free account
3. Create new app
4. Copy API key
5. [Detailed guide](https://www.alchemy.com/docs/how-to-create-access-keys)

**Protocol Support**: v3, v4
</Accordion>

<Accordion title="Nostr Witness">
**What you need**: Nostr secret key (nsec)

**How to get a Nostr key**:

**Option 1: Nostr Client App**
1. Download a Nostr app:
   - [Damus](https://damus.io/) (iOS)
   - [Amethyst](https://github.com/vitorpamplona/amethyst) (Android)
   - [Primal](https://primal.net/) (Web/Mobile)
2. Create new account or log in
3. App generates a key pair automatically
4. Your secret key starts with `nsec1...`
5. **Save it securely** - you'll need it for witnessing

**Option 2: Web Generator**
- Visit [nostr.com](https://nostr.com) or [nostrtool.com](https://nostrtool.com)
- Click "Generate Keys"
- Save your secret key (`nsec1...`)

<Callout type="warning" title="Security">
Your Nostr secret key is permanent. Anyone with it can post as you on Nostr relays. Keep it secure!
</Callout>

**Benefits**:
- Fully decentralized (no blockchain fees)
- Censorship-resistant
- Fast propagation across relays
- Free to use

**Protocol Support**: v3, v4
</Accordion>



## JavaScript SDK Usage (v3)

<Callout type="info" title="Prerequisites">
- Node.js version 19 or higher
- Install aqua-js-sdk: `npm install aqua-js-sdk`
</Callout>

### Complete Workflow Example

Follow these steps to notarize a file, sign it, and witness it using the JavaScript SDK (v3):

<Steps>
<Step title="Create Genesis Revision">

```typescript
import Aquafier, { FileObject } from 'aqua-js-sdk';
import { readFileSync } from 'fs';

// Read file content
const testFileContent = readFileSync("./test.txt", 'utf-8');

// Create file object
const aquaFileObject: FileObject = {
    fileName: "test.txt",
    fileContent: testFileContent,
    path: "./test.txt"
};

// Initialize Aquafier
const aquafier = new Aquafier();

// Create genesis revision (notarize the file)
const genesisResult = await aquafier.createGenesisRevision(aquaFileObject);

if (genesisResult.isOk()) {
    console.log("Genesis created successfully!");
    console.log("Aqua Tree:", genesisResult.data.aquaTree);
} else {
    console.error("Error creating genesis:", genesisResult.error);
}
```
</Step>

<Step title="Sign the Aqua Tree">

```typescript
import { AquaTreeWrapper, CredentialsData } from 'aqua-js-sdk';

// Prepare credentials (for MetaMask, can be empty object)
const creds: CredentialsData = {};

// Or for CLI signing with mnemonic:
// const creds: CredentialsData = {
//     mnemonic: "your twelve word mnemonic here",
//     wallet_address: "0xYourAddress"
// };

// Create wrapper (empty string for revision means sign latest)
const aquaWrapper: AquaTreeWrapper = {
    aquaTree: genesisResult.data.aquaTree,
    fileObject: aquaFileObject,
    revision: ""  // Sign latest revision
};

// Sign with MetaMask (or use "cli", "did", "p12")
const signedResult = await aquafier.signAquaTree(
    aquaWrapper,
    "metamask",  // Signature type
    creds,
    true         // Auto-increment
);

if (signedResult.isOk()) {
    console.log("Signature added successfully!");
} else {
    console.error("Signing failed:", signedResult.error);
}
```
</Step>

<Step title="Witness on Blockchain">

```typescript
// Update wrapper with signed tree
const witnessWrapper: AquaTreeWrapper = {
    aquaTree: signedResult.data.aquaTree,
    fileObject: aquaFileObject,
    revision: ""  // Witness latest revision
};

// Witness on Ethereum Sepolia testnet
const witnessResult = await aquafier.witnessAquaTree(
    witnessWrapper,
    "eth",        // Witness type (eth, tsa, or nostr)
    "sepolia",    // Network (sepolia, mainnet, holesky)
    "metamask",   // Signing method
    creds,
    true          // Auto-increment
);

if (witnessResult.isOk()) {
    console.log("Witnessing successful!");
    console.log("Transaction:", witnessResult.data.witness_transaction_hash);
} else {
    console.error("Witnessing failed:", witnessResult.error);
}
```
</Step>

<Step title="Verify the Aqua Tree">

```typescript
// Fetch aqua tree from storage, database, or state
const aquaTree = witnessResult.data.aquaTree;

// Prepare credentials for verification (needs Alchemy key for Ethereum witness)
const verifyCreds: CredentialsData = {
    alchemy_key: "your_alchemy_api_key"
};

// Verify the complete tree
const verificationResult = await aquafier.verifyAquaTree(
    aquaTree,
    [aquaFileObject],  // Array of file objects
    verifyCreds
);

if (verificationResult.isOk()) {
    console.log("✓ Verification successful!");
    console.log("Details:", JSON.stringify(verificationResult.data, null, 2));
} else {
    console.log("✗ Verification failed!");
    console.log("Details:", JSON.stringify(verificationResult.data, null, 2));
}
```
</Step>
</Steps>

### More Examples

<CardGrid cols={2}>
  <Card title="Complete Examples" icon="github" href="https://github.com/inblockio/aqua-js-sdk/tree/master/examples">
    Browse full working examples in the repository
  </Card>

  <Card title="API Documentation" icon="book" href="/docs/v3.0.2/tooling">
    Detailed API reference for JavaScript SDK
  </Card>
</CardGrid>

## Rust SDK Usage (v4)

<Callout type="info" title="Prerequisites">
- Rust 1.70 or higher
- Add to Cargo.toml: `aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }`
</Callout>

### Quick Example

```rust
use aqua_rs_sdk::primitives::Method;
use aqua_rs_sdk::schema::file_data::FileData;
use aqua_rs_sdk::Aquafier;
use std::path::PathBuf;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Read file content
    let filename = "test.txt".to_string();
    let file_content = tokio::fs::read(&filename).await?;

    // Create file data
    let file_data = FileData::new(
        filename.clone(),
        file_content,
        PathBuf::from(format!("./{}", filename)),
    );

    // Initialize Aquafier
    let aquafier = Aquafier::new(None, None);

    // Create genesis revision (notarize the file)
    let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

    match result {
        Ok(tree) => {
            println!("✓ Aqua chain created successfully!");
            println!("{}", serde_json::to_string_pretty(&tree)?);
        }
        Err(e) => {
            eprintln!("Error: {:#?}", e);
        }
    }

    Ok(())
}
```

### More Resources

<CardGrid cols={2}>
  <Card title="Rust SDK Guide" icon="code" href="/docs/v4.0.0/dev-tools/aqua-sdk">
    Complete guide for the Rust SDK
  </Card>

  <Card title="Schema Reference" icon="book" href="/docs/v4.0.0/schema-reference/introduction">
    v4 protocol specifications
  </Card>
</CardGrid>

## Next Steps

<CardGrid cols={2}>
  <Card title="Use Cases" icon="lightbulb" href="/docs/v4.0.0/use-cases/introduction">
    Explore real-world applications
  </Card>

  <Card title="Quick Start" icon="rocket" href="/docs/v4.0.0/quickstart">
    Build your first Aqua application
  </Card>

  <Card title="Examples Repository" icon="code" href="https://github.com/inblockio/aqua-examples">
    Browse complete examples
  </Card>

  <Card title="Get Support" icon="mail" href="mailto:info@inblock.io">
    Need help? Contact our team
  </Card>
</CardGrid>10:T355d,

This section provides the complete technical specification for Aqua Protocol v4. Here you'll find detailed documentation on data structures, revision types, validation rules, and implementation requirements.

## What is Aqua Protocol?

Aqua Protocol is a cryptographic protocol for creating verifiable, timestamped chains of revisions with signatures and blockchain anchoring. It enables:

- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is detectable
- **Multi-Party Signatures**: Multiple parties can sign revisions for authentication
- **Blockchain Timestamping**: Anchor revisions to Ethereum, Nostr, or TSA for provable timestamps
- **Provenance Tracking**: Link revisions to track data flow and transformations
- **Template Validation**: Enforce data schemas with JSON Schema

## Core Data Structure

When you notarize content with Aqua Protocol, the output is a JSON file called an **Aqua Tree**.

### Aqua Tree Structure

```json
{
  "revisions": {
    "0xhash1...": { /* revision object */ },
    "0xhash2...": { /* revision object */ }
  },
  "file_index": {
    "0xcontenthash1...": "document.pdf",
    "0xcontenthash2...": "image.png"
  }
}
```

The Aqua Tree contains two primary components:

- **[Revisions](/docs/v4.0.0/schema-reference/revision/revision)**: Map of verification hashes to revision objects
- **[File Index](/docs/v4.0.0/schema-reference/file-index)**: Map of content hashes to filenames

See the [Aqua Tree documentation](/docs/v4.0.0/schema-reference/aqua-tree) for complete details.

## Revision Types

Aqua Protocol v4 defines five revision types, each serving a specific purpose:

### 1. Object Revision
**Purpose**: Store data content (documents, files, structured data)

**Use for**:
- Genesis revisions (first revision in a chain)
- Document updates and modifications
- Data snapshots

**Learn more**: [Object Revision Reference](/docs/v4.0.0/schema-reference/revision/object-revision)

### 2. Template Revision
**Purpose**: Define data schemas and validation rules

**Use for**:
- Enforcing data structure with JSON Schema
- Creating reusable data models
- Validating object revision content

**Learn more**: [Template Revision Reference](/docs/v4.0.0/schema-reference/revision/template-revision)

### 3. Signature Revision
**Purpose**: Add cryptographic signatures for authentication

**Use for**:
- Proving authorship and authorization
- Multi-party approval workflows
- Non-repudiation

**Signature Types**:
- **RSA**: Traditional RSA signatures
- **EIP-191**: Ethereum-style signatures
- **DID:JWS**: Decentralized identifier signatures

**Learn more**: [Signature Revision Reference](/docs/v4.0.0/schema-reference/revision/signing-revision)

### 4. Witness Revision
**Purpose**: Anchor revisions to blockchain for timestamping

**Use for**:
- Proving existence at specific time
- Creating tamper-proof timestamps
- Regulatory compliance

**Networks Supported**:
- Ethereum (mainnet, Sepolia, Holesky)
- Nostr
- TSA (RFC 3161 Timestamping Authorities)

**Learn more**: [Witness Revision Reference](/docs/v4.0.0/schema-reference/revision/witness-revision)

### 5. Link Revision
**Purpose**: Connect to other Aqua Trees

**Use for**:
- Referencing dependencies
- Building composite documents
- Creating provenance graphs

**Learn more**: [Link Revision Reference](/docs/v4.0.0/schema-reference/revision/link-revision)

## Common Revision Fields

All revision types share these common fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revision_type` | string | Yes | Hash identifying the revision type |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when revision was created |
| `version` | string | Yes | Protocol version: `https://aqua-protocol.org/docs/v4/schema` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `previous_hash` | string | No | Hash of previous revision (absent in genesis) |

Additional fields depend on the specific revision type.

## Canonicalization Methods

Aqua Protocol v4 supports two methods for computing revision hashes:

### Scalar Method
**Best for**: Simple, straightforward hashing

```json
{
  "method": "scalar",
  // Content hashed as-is
}
```

The entire revision is serialized and hashed directly.

### Tree Method
**Best for**: Selective disclosure, large content

```json
{
  "method": "tree",
  "leaves": [
    "0xleaf1hash...",
    "0xleaf2hash..."
  ]
}
```

Content is broken into leaves, each hashed separately, then combined in a Merkle tree.

## Verification Hash

Each revision has a **verification hash** computed from its canonical form using SHA3-256:

```
verification_hash = SHA3-256(canonical_revision_json)
```

This hash serves as:
- Unique identifier for the revision
- Key in the revisions map
- Reference in `previous_hash` fields
- Proof of integrity

## Revision Chains

Revisions form chains through `previous_hash` references:

```
Genesis (no previous_hash)
    ↓
Revision A (previous_hash → Genesis)
    ↓
Signature B (previous_hash → Revision A)
    ↓
Witness C (previous_hash → Signature B)
```

### Genesis Revision

The first revision in a chain:
- Has no `previous_hash` field (or `previous_hash: null`)
- Typically an object or template revision
- Establishes the chain's starting point

### Subsequent Revisions

All revisions after genesis:
- Must have `previous_hash` pointing to an existing revision
- Build upon the chain's history
- Can be any revision type

## Example: Complete Aqua Tree

Here's a minimal example showing a document with signature and witness:

```json
{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "application/pdf",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Contract Document"
      }
    },
    "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "nonce": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d",
      "local_timestamp": 1704067260,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x8c9d0e1f...",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    },
    "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f": {
      "revision_type": "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f",
      "nonce": "0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e",
      "local_timestamp": 1704067320,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "merkle_root": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "timestamp": 1704067320,
      "network": "sepolia",
      "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      "transaction_hash": "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9",
      "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
      "merkle_proof": []
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "contract.pdf"
  }
}
```

This tree contains:
1. **Object Revision** (genesis): Document content hash
2. **Signature Revision**: EIP-191 signature from wallet
3. **Witness Revision**: Ethereum Sepolia timestamp

## Built-in Templates

Aqua Protocol v4 includes several built-in templates:

| Template | Purpose | Hash |
|----------|---------|------|
| **Object** | Generic object revision | `0x742b74c87ccd7bfc...` |
| **Template** | Template definition | `0x9c2f4e6a8c0b1d3f...` |
| **Signature** | Signature revision | `0x8e5b2f9c4d3a1e7b...` |
| **Witness** | Witness revision | `0x1c3e5a7b9d2f4e6a...` |
| **Link** | Link revision | `0x4a6c8e0b2d4f6a8c...` |
| **File** | File content | `0x5b7d9f1a3c5e7b9d...` |
| **Domain** | Domain name | `0x6c8e0b2d4f6a8c0b...` |
| **Email** | Email address | `0x7d9f1a3c5e7b9d2f...` |

Each built-in template has a specific hash that serves as its `revision_type` identifier.

## Hash Format

All hashes in Aqua Protocol v4 use consistent formatting:

- **Algorithm**: SHA3-256 (FIPS 202)
- **Format**: Hex string prefixed with `0x`
- **Length**: 66 characters (`0x` + 64 hex digits)
- **Example**: `0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`

## Timestamp Format

Timestamps use Unix epoch format:

- **Type**: Integer (seconds since January 1, 1970 UTC)
- **Example**: `1704067200` = January 1, 2024 00:00:00 UTC

## Validation Rules

An Aqua Tree is valid if:

1. **All revisions have valid hashes**: Computed hash matches the key
2. **Previous hashes exist**: All `previous_hash` values reference existing revisions (except genesis)
3. **No cycles**: Following `previous_hash` eventually reaches genesis
4. **Signatures verify**: All signature revisions have valid cryptographic signatures
5. **Templates validate**: Object revisions with templates match their schema
6. **Witnesses exist**: Witness revisions reference valid blockchain transactions

## Schema Version

All revisions in Aqua Protocol v4 use:

```json
{
  "version": "https://aqua-protocol.org/docs/v4/schema"
}
```

This identifies the protocol version and schema specification.

## Implementation Guidelines

### Creating Revisions

1. **Generate nonce**: Create random 16-byte hex string
2. **Set timestamp**: Use current Unix timestamp
3. **Add content**: Include revision-specific fields
4. **Set previous_hash**: Reference prior revision (if not genesis)
5. **Compute hash**: Canonicalize and hash the revision
6. **Use hash as key**: Store in revisions map with hash as key

### Verifying Chains

1. **Find genesis**: Locate revision with no `previous_hash`
2. **Traverse chain**: Follow `previous_hash` references
3. **Verify hashes**: Recompute and compare each verification hash
4. **Check signatures**: Validate all cryptographic signatures
5. **Verify witnesses**: Check blockchain transactions
6. **Validate templates**: Ensure object data matches schemas

## File Storage

Aqua Trees are typically stored as JSON files:

```bash
document.aqua.json
contract-2024-01-01.aqua.json
```

The `.aqua.json` extension identifies Aqua Protocol files.

## Use Cases

Aqua Protocol v4 schema supports diverse applications:

- **Document Notarization**: Legal documents, contracts, agreements
- **Supply Chain**: Product tracking, provenance verification
- **Credentials**: Diplomas, certificates, licenses
- **Data Integrity**: Scientific data, audit logs, compliance records
- **Multi-Party Workflows**: Approvals, reviews, collaborative editing

## Navigation

Explore the detailed specifications for each component:

<CardGrid cols={2}>
  <Card title="Aqua Tree" icon="tree" href="/docs/v4.0.0/schema-reference/aqua-tree">
    Root data structure containing revisions and file index
  </Card>

  <Card title="File Index" icon="folder" href="/docs/v4.0.0/schema-reference/file-index">
    Mapping content hashes to filenames
  </Card>

  <Card title="Revision Types" icon="code-branch" href="/docs/v4.0.0/schema-reference/revision/revision">
    Overview of all revision types
  </Card>

  <Card title="Object Revision" icon="file" href="/docs/v4.0.0/schema-reference/revision/object-revision">
    Store document and data content
  </Card>

  <Card title="Template Revision" icon="table" href="/docs/v4.0.0/schema-reference/revision/template-revision">
    Define schemas with JSON Schema
  </Card>

  <Card title="Signature Revision" icon="signature" href="/docs/v4.0.0/schema-reference/revision/signing-revision">
    Add cryptographic signatures
  </Card>

  <Card title="Witness Revision" icon="clock" href="/docs/v4.0.0/schema-reference/revision/witness-revision">
    Blockchain timestamping
  </Card>

  <Card title="Link Revision" icon="link" href="/docs/v4.0.0/schema-reference/revision/link-revision">
    Connect to other Aqua Trees
  </Card>
</CardGrid>

## Additional Resources

- [Quick Start Guide](/docs/v4.0.0/quickstart) - Get started with Aqua Protocol
- [Use Cases](/docs/v4.0.0/use-cases/introduction) - Real-world applications
- [Aqua SDK](/docs/v4.0.0/dev-tools/aqua-sdk) - Rust SDK for implementation
- [Aqua CLI](/docs/v4.0.0/dev-tools/aqua-cli) - Command-line tool

## Version History

**Current Version**: 4.0.0 (Beta)

Aqua Protocol v4 introduces:
- Template system with JSON Schema validation
- Enhanced revision type system
- Improved canonicalization methods
- Better support for complex data structures

For previous versions, see:
- [Version 3 Documentation](/docs/v3.0.2/introduction) - JavaScript SDK (Stable)
- [Version 2 Documentation](/docs/v2.0.2/introduction) - Legacy
- [Version 1 Documentation](/docs/v1.1.0/introduction) - Legacy
11:T355d,

This section provides the complete technical specification for Aqua Protocol v4. Here you'll find detailed documentation on data structures, revision types, validation rules, and implementation requirements.

## What is Aqua Protocol?

Aqua Protocol is a cryptographic protocol for creating verifiable, timestamped chains of revisions with signatures and blockchain anchoring. It enables:

- **Tamper-Proof Records**: Cryptographic hashes ensure any modification is detectable
- **Multi-Party Signatures**: Multiple parties can sign revisions for authentication
- **Blockchain Timestamping**: Anchor revisions to Ethereum, Nostr, or TSA for provable timestamps
- **Provenance Tracking**: Link revisions to track data flow and transformations
- **Template Validation**: Enforce data schemas with JSON Schema

## Core Data Structure

When you notarize content with Aqua Protocol, the output is a JSON file called an **Aqua Tree**.

### Aqua Tree Structure

```json
{
  "revisions": {
    "0xhash1...": { /* revision object */ },
    "0xhash2...": { /* revision object */ }
  },
  "file_index": {
    "0xcontenthash1...": "document.pdf",
    "0xcontenthash2...": "image.png"
  }
}
```

The Aqua Tree contains two primary components:

- **[Revisions](/docs/v4.0.0/schema-reference/revision/revision)**: Map of verification hashes to revision objects
- **[File Index](/docs/v4.0.0/schema-reference/file-index)**: Map of content hashes to filenames

See the [Aqua Tree documentation](/docs/v4.0.0/schema-reference/aqua-tree) for complete details.

## Revision Types

Aqua Protocol v4 defines five revision types, each serving a specific purpose:

### 1. Object Revision
**Purpose**: Store data content (documents, files, structured data)

**Use for**:
- Genesis revisions (first revision in a chain)
- Document updates and modifications
- Data snapshots

**Learn more**: [Object Revision Reference](/docs/v4.0.0/schema-reference/revision/object-revision)

### 2. Template Revision
**Purpose**: Define data schemas and validation rules

**Use for**:
- Enforcing data structure with JSON Schema
- Creating reusable data models
- Validating object revision content

**Learn more**: [Template Revision Reference](/docs/v4.0.0/schema-reference/revision/template-revision)

### 3. Signature Revision
**Purpose**: Add cryptographic signatures for authentication

**Use for**:
- Proving authorship and authorization
- Multi-party approval workflows
- Non-repudiation

**Signature Types**:
- **RSA**: Traditional RSA signatures
- **EIP-191**: Ethereum-style signatures
- **DID:JWS**: Decentralized identifier signatures

**Learn more**: [Signature Revision Reference](/docs/v4.0.0/schema-reference/revision/signing-revision)

### 4. Witness Revision
**Purpose**: Anchor revisions to blockchain for timestamping

**Use for**:
- Proving existence at specific time
- Creating tamper-proof timestamps
- Regulatory compliance

**Networks Supported**:
- Ethereum (mainnet, Sepolia, Holesky)
- Nostr
- TSA (RFC 3161 Timestamping Authorities)

**Learn more**: [Witness Revision Reference](/docs/v4.0.0/schema-reference/revision/witness-revision)

### 5. Link Revision
**Purpose**: Connect to other Aqua Trees

**Use for**:
- Referencing dependencies
- Building composite documents
- Creating provenance graphs

**Learn more**: [Link Revision Reference](/docs/v4.0.0/schema-reference/revision/link-revision)

## Common Revision Fields

All revision types share these common fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revision_type` | string | Yes | Hash identifying the revision type |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when revision was created |
| `version` | string | Yes | Protocol version: `https://aqua-protocol.org/docs/v4/schema` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `previous_hash` | string | No | Hash of previous revision (absent in genesis) |

Additional fields depend on the specific revision type.

## Canonicalization Methods

Aqua Protocol v4 supports two methods for computing revision hashes:

### Scalar Method
**Best for**: Simple, straightforward hashing

```json
{
  "method": "scalar",
  // Content hashed as-is
}
```

The entire revision is serialized and hashed directly.

### Tree Method
**Best for**: Selective disclosure, large content

```json
{
  "method": "tree",
  "leaves": [
    "0xleaf1hash...",
    "0xleaf2hash..."
  ]
}
```

Content is broken into leaves, each hashed separately, then combined in a Merkle tree.

## Verification Hash

Each revision has a **verification hash** computed from its canonical form using SHA3-256:

```
verification_hash = SHA3-256(canonical_revision_json)
```

This hash serves as:
- Unique identifier for the revision
- Key in the revisions map
- Reference in `previous_hash` fields
- Proof of integrity

## Revision Chains

Revisions form chains through `previous_hash` references:

```
Genesis (no previous_hash)
    ↓
Revision A (previous_hash → Genesis)
    ↓
Signature B (previous_hash → Revision A)
    ↓
Witness C (previous_hash → Signature B)
```

### Genesis Revision

The first revision in a chain:
- Has no `previous_hash` field (or `previous_hash: null`)
- Typically an object or template revision
- Establishes the chain's starting point

### Subsequent Revisions

All revisions after genesis:
- Must have `previous_hash` pointing to an existing revision
- Build upon the chain's history
- Can be any revision type

## Example: Complete Aqua Tree

Here's a minimal example showing a document with signature and witness:

```json
{
  "revisions": {
    "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e": {
      "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
      "local_timestamp": 1704067200,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "payload": {
        "payload_type": "application/pdf",
        "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
        "hash_type": "FIPS_202-SHA3-256",
        "descriptor": "Contract Document"
      }
    },
    "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b": {
      "revision_type": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "nonce": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d",
      "local_timestamp": 1704067260,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
      "signature_type": "eip191",
      "signature": "0x8c9d0e1f...",
      "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
    },
    "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f": {
      "revision_type": "0x1c3e5a7b9d2f4e6a8c0b1d3f5e7a9c2b4d6e8f0a1c3e5a7b9d2f4e6a8c0b1d3f",
      "nonce": "0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e",
      "local_timestamp": 1704067320,
      "version": "https://aqua-protocol.org/docs/v4/schema",
      "method": "scalar",
      "hash_type": "FIPS_202-SHA3-256",
      "previous_hash": "0x8e5b2f9c4d3a1e7b6c8f9d0e2a5b3c4d1e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
      "merkle_root": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "timestamp": 1704067320,
      "network": "sepolia",
      "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      "transaction_hash": "0x3b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9",
      "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
      "merkle_proof": []
    }
  },
  "file_index": {
    "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08": "contract.pdf"
  }
}
```

This tree contains:
1. **Object Revision** (genesis): Document content hash
2. **Signature Revision**: EIP-191 signature from wallet
3. **Witness Revision**: Ethereum Sepolia timestamp

## Built-in Templates

Aqua Protocol v4 includes several built-in templates:

| Template | Purpose | Hash |
|----------|---------|------|
| **Object** | Generic object revision | `0x742b74c87ccd7bfc...` |
| **Template** | Template definition | `0x9c2f4e6a8c0b1d3f...` |
| **Signature** | Signature revision | `0x8e5b2f9c4d3a1e7b...` |
| **Witness** | Witness revision | `0x1c3e5a7b9d2f4e6a...` |
| **Link** | Link revision | `0x4a6c8e0b2d4f6a8c...` |
| **File** | File content | `0x5b7d9f1a3c5e7b9d...` |
| **Domain** | Domain name | `0x6c8e0b2d4f6a8c0b...` |
| **Email** | Email address | `0x7d9f1a3c5e7b9d2f...` |

Each built-in template has a specific hash that serves as its `revision_type` identifier.

## Hash Format

All hashes in Aqua Protocol v4 use consistent formatting:

- **Algorithm**: SHA3-256 (FIPS 202)
- **Format**: Hex string prefixed with `0x`
- **Length**: 66 characters (`0x` + 64 hex digits)
- **Example**: `0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`

## Timestamp Format

Timestamps use Unix epoch format:

- **Type**: Integer (seconds since January 1, 1970 UTC)
- **Example**: `1704067200` = January 1, 2024 00:00:00 UTC

## Validation Rules

An Aqua Tree is valid if:

1. **All revisions have valid hashes**: Computed hash matches the key
2. **Previous hashes exist**: All `previous_hash` values reference existing revisions (except genesis)
3. **No cycles**: Following `previous_hash` eventually reaches genesis
4. **Signatures verify**: All signature revisions have valid cryptographic signatures
5. **Templates validate**: Object revisions with templates match their schema
6. **Witnesses exist**: Witness revisions reference valid blockchain transactions

## Schema Version

All revisions in Aqua Protocol v4 use:

```json
{
  "version": "https://aqua-protocol.org/docs/v4/schema"
}
```

This identifies the protocol version and schema specification.

## Implementation Guidelines

### Creating Revisions

1. **Generate nonce**: Create random 16-byte hex string
2. **Set timestamp**: Use current Unix timestamp
3. **Add content**: Include revision-specific fields
4. **Set previous_hash**: Reference prior revision (if not genesis)
5. **Compute hash**: Canonicalize and hash the revision
6. **Use hash as key**: Store in revisions map with hash as key

### Verifying Chains

1. **Find genesis**: Locate revision with no `previous_hash`
2. **Traverse chain**: Follow `previous_hash` references
3. **Verify hashes**: Recompute and compare each verification hash
4. **Check signatures**: Validate all cryptographic signatures
5. **Verify witnesses**: Check blockchain transactions
6. **Validate templates**: Ensure object data matches schemas

## File Storage

Aqua Trees are typically stored as JSON files:

```bash
document.aqua.json
contract-2024-01-01.aqua.json
```

The `.aqua.json` extension identifies Aqua Protocol files.

## Use Cases

Aqua Protocol v4 schema supports diverse applications:

- **Document Notarization**: Legal documents, contracts, agreements
- **Supply Chain**: Product tracking, provenance verification
- **Credentials**: Diplomas, certificates, licenses
- **Data Integrity**: Scientific data, audit logs, compliance records
- **Multi-Party Workflows**: Approvals, reviews, collaborative editing

## Navigation

Explore the detailed specifications for each component:

<CardGrid cols={2}>
  <Card title="Aqua Tree" icon="tree" href="/docs/v4.0.0/schema-reference/aqua-tree">
    Root data structure containing revisions and file index
  </Card>

  <Card title="File Index" icon="folder" href="/docs/v4.0.0/schema-reference/file-index">
    Mapping content hashes to filenames
  </Card>

  <Card title="Revision Types" icon="code-branch" href="/docs/v4.0.0/schema-reference/revision/revision">
    Overview of all revision types
  </Card>

  <Card title="Object Revision" icon="file" href="/docs/v4.0.0/schema-reference/revision/object-revision">
    Store document and data content
  </Card>

  <Card title="Template Revision" icon="table" href="/docs/v4.0.0/schema-reference/revision/template-revision">
    Define schemas with JSON Schema
  </Card>

  <Card title="Signature Revision" icon="signature" href="/docs/v4.0.0/schema-reference/revision/signing-revision">
    Add cryptographic signatures
  </Card>

  <Card title="Witness Revision" icon="clock" href="/docs/v4.0.0/schema-reference/revision/witness-revision">
    Blockchain timestamping
  </Card>

  <Card title="Link Revision" icon="link" href="/docs/v4.0.0/schema-reference/revision/link-revision">
    Connect to other Aqua Trees
  </Card>
</CardGrid>

## Additional Resources

- [Quick Start Guide](/docs/v4.0.0/quickstart) - Get started with Aqua Protocol
- [Use Cases](/docs/v4.0.0/use-cases/introduction) - Real-world applications
- [Aqua SDK](/docs/v4.0.0/dev-tools/aqua-sdk) - Rust SDK for implementation
- [Aqua CLI](/docs/v4.0.0/dev-tools/aqua-cli) - Command-line tool

## Version History

**Current Version**: 4.0.0 (Beta)

Aqua Protocol v4 introduces:
- Template system with JSON Schema validation
- Enhanced revision type system
- Improved canonicalization methods
- Better support for complex data structures

For previous versions, see:
- [Version 3 Documentation](/docs/v3.0.2/introduction) - JavaScript SDK (Stable)
- [Version 2 Documentation](/docs/v2.0.2/introduction) - Legacy
- [Version 1 Documentation](/docs/v1.1.0/introduction) - Legacy
12:T13e8,
# Aqua Protocol v4

Aqua Protocol v4 is the latest version of the protocol, introducing significant improvements in structure, flexibility, and capabilities. This version is currently in beta.

## Overview

Aqua Protocol v4 provides a robust framework for creating cryptographically verifiable chains of revisions. Each revision in a chain can represent different types of operations, from storing data to signing, witnessing, and linking to other chains.

## Core Concepts

### Revisions

A revision is the fundamental unit in Aqua Protocol. There are five types of revisions in v4:

1. **Object Revision** - Stores data with an associated template
2. **Template Revision** - Defines the schema for object revisions
3. **Signature Revision** - Adds cryptographic signatures to verify authenticity
4. **Witness Revision** - Provides timestamped proof of existence via blockchain
5. **Link Revision** - Creates verifiable connections to other revision chains

### Revision Chains

Revisions form chains by referencing previous revisions through cryptographic hashes. The first revision in a chain is called the "genesis revision" and has no previous revision reference.

### Methods

Aqua Protocol v4 supports two canonicalization methods:

- **scalar**: Direct JSON canonicalization (default for most use cases)
- **tree**: Merkle tree-based canonicalization for large datasets

### Hash Types

Currently, v4 supports:
- **FIPS_202-SHA3-256**: SHA-3 256-bit hashing algorithm

## Common Fields

All revision types share these common fields:

| Field | Type | Description |
|-------|------|-------------|
| `version` | string | Protocol version URL: `https://aqua-protocol.org/docs/v4/schema` |
| `revision_type` | string/RevisionLink | Type identifier for the revision |
| `nonce` | string | Random 16-byte hex string (prefixed with `0x`) for uniqueness |
| `local_timestamp` | number | Unix timestamp when the revision was created |
| `method` | string | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Hashing algorithm: `"FIPS_202-SHA3-256"` |
| `previous_revision` | string | Hash reference to the previous revision (optional for genesis) |

## Schema Structure

The v4 schema is designed to be:

- **Extensible**: New revision types can be added without breaking existing chains
- **Verifiable**: Every revision can be independently verified through hash computation
- **Composable**: Chains can link to other chains, creating complex data structures
- **Flexible**: Templates allow custom data structures while maintaining validation

## Key Improvements from Previous Versions

### 1. Unified Revision Structure
All revision types follow a consistent structure with common fields, making implementation and validation simpler.

### 2. Template-Based Validation
Object revisions reference templates via hash, ensuring data conformity to predefined schemas.

### 3. Multiple Signature Types
Support for RSA, Ethereum (EIP-191), and DID-based signatures provides flexibility for different use cases.

### 4. Enhanced Witnessing
Improved witness structure with detailed transaction information and merkle proof support.

### 5. Explicit Linking
Link revisions create verifiable connections between separate revision chains.

## Getting Started

To understand the v4 schema in detail, visit the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) section, where each revision type is documented with examples and field specifications.

## Tooling

### Aqua RS SDK

The official Rust SDK for Aqua Protocol v4 provides:
- Type-safe revision creation and validation
- Cryptographic operations (signing, hashing)
- Witnessing capabilities (Ethereum, Nostr, TSA)
- WASM compilation for web applications

**Repository**: [github.com/inblockio/aqua-rs-sdk](https://github.com/inblockio/aqua-rs-sdk)

**Installation:**
```bash
# For Rust projects
cargo add aqua-rs-sdk

# For WASM builds
wasm-pack build --target web --no-default-features --features wasm
```

### CLI Tools

Command-line utilities built on the v4 SDK enable:
- Creating and validating revision chains
- Signing revisions with various methods
- Witnessing to blockchain networks
- Verifying complete chains

## Use Cases

Aqua Protocol v4 is designed for:

- **Document Integrity**: Verifiable audit trails for documents and data
- **Supply Chain**: Tracking provenance and authenticity
- **Digital Identity**: Self-sovereign identity with verifiable credentials
- **Notarization**: Timestamped proof of existence
- **Data Provenance**: Complete history tracking with cryptographic guarantees
- **Decentralized Attestations**: Peer-to-peer verification without central authorities

## Next Steps

- Explore the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) to understand each revision type
- Review example revision chains in the SDK repository
- Try the CLI tools to create your first revision chain
- Read about specific use cases and implementation patterns

For questions or feedback about v4, please visit the [Aqua Protocol GitHub repository](https://github.com/inblockio).
13:T13e8,
# Aqua Protocol v4

Aqua Protocol v4 is the latest version of the protocol, introducing significant improvements in structure, flexibility, and capabilities. This version is currently in beta.

## Overview

Aqua Protocol v4 provides a robust framework for creating cryptographically verifiable chains of revisions. Each revision in a chain can represent different types of operations, from storing data to signing, witnessing, and linking to other chains.

## Core Concepts

### Revisions

A revision is the fundamental unit in Aqua Protocol. There are five types of revisions in v4:

1. **Object Revision** - Stores data with an associated template
2. **Template Revision** - Defines the schema for object revisions
3. **Signature Revision** - Adds cryptographic signatures to verify authenticity
4. **Witness Revision** - Provides timestamped proof of existence via blockchain
5. **Link Revision** - Creates verifiable connections to other revision chains

### Revision Chains

Revisions form chains by referencing previous revisions through cryptographic hashes. The first revision in a chain is called the "genesis revision" and has no previous revision reference.

### Methods

Aqua Protocol v4 supports two canonicalization methods:

- **scalar**: Direct JSON canonicalization (default for most use cases)
- **tree**: Merkle tree-based canonicalization for large datasets

### Hash Types

Currently, v4 supports:
- **FIPS_202-SHA3-256**: SHA-3 256-bit hashing algorithm

## Common Fields

All revision types share these common fields:

| Field | Type | Description |
|-------|------|-------------|
| `version` | string | Protocol version URL: `https://aqua-protocol.org/docs/v4/schema` |
| `revision_type` | string/RevisionLink | Type identifier for the revision |
| `nonce` | string | Random 16-byte hex string (prefixed with `0x`) for uniqueness |
| `local_timestamp` | number | Unix timestamp when the revision was created |
| `method` | string | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Hashing algorithm: `"FIPS_202-SHA3-256"` |
| `previous_revision` | string | Hash reference to the previous revision (optional for genesis) |

## Schema Structure

The v4 schema is designed to be:

- **Extensible**: New revision types can be added without breaking existing chains
- **Verifiable**: Every revision can be independently verified through hash computation
- **Composable**: Chains can link to other chains, creating complex data structures
- **Flexible**: Templates allow custom data structures while maintaining validation

## Key Improvements from Previous Versions

### 1. Unified Revision Structure
All revision types follow a consistent structure with common fields, making implementation and validation simpler.

### 2. Template-Based Validation
Object revisions reference templates via hash, ensuring data conformity to predefined schemas.

### 3. Multiple Signature Types
Support for RSA, Ethereum (EIP-191), and DID-based signatures provides flexibility for different use cases.

### 4. Enhanced Witnessing
Improved witness structure with detailed transaction information and merkle proof support.

### 5. Explicit Linking
Link revisions create verifiable connections between separate revision chains.

## Getting Started

To understand the v4 schema in detail, visit the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) section, where each revision type is documented with examples and field specifications.

## Tooling

### Aqua RS SDK

The official Rust SDK for Aqua Protocol v4 provides:
- Type-safe revision creation and validation
- Cryptographic operations (signing, hashing)
- Witnessing capabilities (Ethereum, Nostr, TSA)
- WASM compilation for web applications

**Repository**: [github.com/inblockio/aqua-rs-sdk](https://github.com/inblockio/aqua-rs-sdk)

**Installation:**
```bash
# For Rust projects
cargo add aqua-rs-sdk

# For WASM builds
wasm-pack build --target web --no-default-features --features wasm
```

### CLI Tools

Command-line utilities built on the v4 SDK enable:
- Creating and validating revision chains
- Signing revisions with various methods
- Witnessing to blockchain networks
- Verifying complete chains

## Use Cases

Aqua Protocol v4 is designed for:

- **Document Integrity**: Verifiable audit trails for documents and data
- **Supply Chain**: Tracking provenance and authenticity
- **Digital Identity**: Self-sovereign identity with verifiable credentials
- **Notarization**: Timestamped proof of existence
- **Data Provenance**: Complete history tracking with cryptographic guarantees
- **Decentralized Attestations**: Peer-to-peer verification without central authorities

## Next Steps

- Explore the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) to understand each revision type
- Review example revision chains in the SDK repository
- Try the CLI tools to create your first revision chain
- Read about specific use cases and implementation patterns

For questions or feedback about v4, please visit the [Aqua Protocol GitHub repository](https://github.com/inblockio).
14:Tc7d,

The Aqua CLI is a command-line tool for creating, signing, witnessing, and verifying Aqua Protocol chains. Built with Rust, it provides a simple interface for working with Aqua chains without writing code.

## Features

- **Chain Validation**: Verify Aqua chain integrity and signatures
- **Signing**: Add cryptographic signatures to revisions
- **Witnessing**: Anchor chains to Ethereum networks (mainnet, Sepolia, Holesky)
- **Batch Operations**: Process multiple chains efficiently
- **Environment Configuration**: Flexible configuration via environment variables

## Installation

### From Source

```bash
git clone https://github.com/inblockio/aqua-cli-rs
cd aqua-cli-rs
cargo build --release
```

The binary will be available at `target/release/aqua-cli`

### Local Development

```bash
cargo build
cd target/debug
./aqua-cli --help
```

## Configuration

Configure the CLI using environment variables:

```bash
# Optional: Domain identifier (auto-generated if not specified)
export aqua_domain="your_domain"

# Network for witnessing (default: sepolia)
export aqua_network="sepolia"  # or "holesky" or "mainnet"

# Verification platform (default: none)
export verification_platform="alchemy"  # or "infura" or "self"

# Blockchain for witnessing (default: none)
export chain="sepolia"  # or "mainnet" or "holesky"

# API key for Alchemy or Infura
export api_key="your_api_key"

# Path to keys file for signing
export keys_file="path/to/keys.json"
```

## Basic Usage

Get started with the CLI:

```bash
# Display help
./aqua-cli --help

# Verify an Aqua chain
./aqua-cli verify --file chain.aqua.json

# Sign a chain
./aqua-cli sign --file chain.aqua.json --keys keys.json

# Witness a chain on Sepolia testnet
./aqua-cli witness --file chain.aqua.json --network sepolia
```

## Keys File Format

Create a `keys.json` file for signing operations:

```json
{
  "private_key": "your_private_key_hex",
  "wallet_address": "0xYourEthereumAddress"
}
```

**Security Note**: Use a wallet without MetaMask for CLI operations. Keep your keys file secure and never commit it to version control.

## Versioning

Ensure the CLI version matches your Aqua Protocol version:
- Use CLI version `4.0.x` for Aqua Protocol v4 chains
- Use CLI version `3.x.x` for Aqua Protocol v3 chains

## Testing

The repository includes a test script for verifying functionality:

```bash
# Grant execution permissions
chmod +x test_aqua_cli.sh

# Run tests
./test_aqua_cli.sh
```

## Use Cases

- **Quick Verification**: Validate chain integrity without building applications
- **CI/CD Integration**: Automate verification in deployment pipelines
- **Batch Processing**: Process multiple chains in scripts
- **Development Testing**: Quickly test chain creation and verification
- **System Administration**: Manage Aqua chains from the command line

## Repository

**GitHub**: [github.com/inblockio/aqua-cli-rs](https://github.com/inblockio/aqua-cli-rs)

## Documentation

For more information about Aqua Protocol v4:
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction)

## Version

**Current Version**: 4.0.0

Built using the [Aqua Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) for Aqua Protocol v4 support.
15:Tc7d,

The Aqua CLI is a command-line tool for creating, signing, witnessing, and verifying Aqua Protocol chains. Built with Rust, it provides a simple interface for working with Aqua chains without writing code.

## Features

- **Chain Validation**: Verify Aqua chain integrity and signatures
- **Signing**: Add cryptographic signatures to revisions
- **Witnessing**: Anchor chains to Ethereum networks (mainnet, Sepolia, Holesky)
- **Batch Operations**: Process multiple chains efficiently
- **Environment Configuration**: Flexible configuration via environment variables

## Installation

### From Source

```bash
git clone https://github.com/inblockio/aqua-cli-rs
cd aqua-cli-rs
cargo build --release
```

The binary will be available at `target/release/aqua-cli`

### Local Development

```bash
cargo build
cd target/debug
./aqua-cli --help
```

## Configuration

Configure the CLI using environment variables:

```bash
# Optional: Domain identifier (auto-generated if not specified)
export aqua_domain="your_domain"

# Network for witnessing (default: sepolia)
export aqua_network="sepolia"  # or "holesky" or "mainnet"

# Verification platform (default: none)
export verification_platform="alchemy"  # or "infura" or "self"

# Blockchain for witnessing (default: none)
export chain="sepolia"  # or "mainnet" or "holesky"

# API key for Alchemy or Infura
export api_key="your_api_key"

# Path to keys file for signing
export keys_file="path/to/keys.json"
```

## Basic Usage

Get started with the CLI:

```bash
# Display help
./aqua-cli --help

# Verify an Aqua chain
./aqua-cli verify --file chain.aqua.json

# Sign a chain
./aqua-cli sign --file chain.aqua.json --keys keys.json

# Witness a chain on Sepolia testnet
./aqua-cli witness --file chain.aqua.json --network sepolia
```

## Keys File Format

Create a `keys.json` file for signing operations:

```json
{
  "private_key": "your_private_key_hex",
  "wallet_address": "0xYourEthereumAddress"
}
```

**Security Note**: Use a wallet without MetaMask for CLI operations. Keep your keys file secure and never commit it to version control.

## Versioning

Ensure the CLI version matches your Aqua Protocol version:
- Use CLI version `4.0.x` for Aqua Protocol v4 chains
- Use CLI version `3.x.x` for Aqua Protocol v3 chains

## Testing

The repository includes a test script for verifying functionality:

```bash
# Grant execution permissions
chmod +x test_aqua_cli.sh

# Run tests
./test_aqua_cli.sh
```

## Use Cases

- **Quick Verification**: Validate chain integrity without building applications
- **CI/CD Integration**: Automate verification in deployment pipelines
- **Batch Processing**: Process multiple chains in scripts
- **Development Testing**: Quickly test chain creation and verification
- **System Administration**: Manage Aqua chains from the command line

## Repository

**GitHub**: [github.com/inblockio/aqua-cli-rs](https://github.com/inblockio/aqua-cli-rs)

## Documentation

For more information about Aqua Protocol v4:
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction)

## Version

**Current Version**: 4.0.0

Built using the [Aqua Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) for Aqua Protocol v4 support.
16:Tebf,This Page contains sdk details of version 4 of the Aqua Protocol.To Use version 3 which is stable visit [quickstart](/docs/v4.0.0/quickstart)
The Aqua SDK is a Rust library that provides the core functionality for creating, signing, witnessing, and verifying Aqua Protocol chains. It supports Aqua Protocol v4 and includes WebAssembly (WASM) bindings for cross-platform compatibility.

## Features

- **Create Aqua Chains**: Build revision chains with objects, templates, signatures, witnesses, and links
- **Template System**: Define and validate structured data using JSON Schema
- **Multiple Signature Methods**: Support for RSA, Ethereum EIP-191, and DID:JWS signatures
- **Blockchain Witnessing**: Anchor revisions to Ethereum (mainnet, Sepolia, Holesky), Nostr, or TSA
- **Chain Verification**: Cryptographically verify complete revision chains
- **Cross-Platform**: WASM support enables use in web browsers, Node.js, and native applications

## Installation

Add the SDK to your Rust project:

```toml cargo.toml
[dependencies]
aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }
```

## Quick Example

```rust main.rs
    use aqua_rs_sdk::primitives::Method;
    use aqua_rs_sdk::schema::file_data::FileData;
    use aqua_rs_sdk::Aquafier;
    use std::path::PathBuf;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating Aqua chain...");

        // Read file content
        let filename = "test.txt".to_string();
        let file_content = tokio::fs::read(&filename).await?;

        // Create file data
        let file_data = FileData::new(
            filename.clone(),
            file_content,
            PathBuf::from(format!("./{}", filename)),
        );

        // Initialize Aquafier
        let aquafier = Aquafier::new(None, None);

        // Create genesis revision (notarize the file)
        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

        match result {
            Ok(tree) => {
                println!("✓ Aqua chain created successfully!");
                println!("{}", serde_json::to_string_pretty(&tree)?);

                println!("\nYou can now:");
                println!("- Add a signature revision");
                println!("- Witness on blockchain");
                println!("- Verify the chain");

                // Sign the revision
                // let signature = sign_revision(&object_revision, &signing_key)?;

                // Witness on blockchain
                // let witness = witness_revision(&signature, EthereumNetwork::Sepolia)?;

                // Verify the complete chain
                // let is_valid = verify_chain(&aqua_chain)?;

            }
            Err(e) => {
                eprintln!("Error: {:#?}", e);
            }
        }

        Ok(())
    }


```

## Use Cases

- **Application Integration**: Embed Aqua Protocol directly into your Rust applications
- **Custom Tools**: Build specialized tools for specific workflows
- **Smart Contracts**: Integrate with blockchain applications using WASM
- **Web Applications**: Use WASM bindings to run in browsers
- **Server Applications**: Build backend services with native Rust performance

## Repository

**GitHub**: [github.com/inblockio/aqua-verifier-rs](https://github.com/inblockio/aqua-rs-sdk)

## Documentation

For detailed API documentation, examples, and guides:
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction)
- [API Documentation](https://docs.rs/aqua-rs-sdk)

## Version

**Current Version**: 4.0.0 (Beta)

The SDK implements Aqua Protocol v4 with the template system and enhanced revision types. For production-stable implementations, consider the [JavaScript SDK (v3)](/docs/v3.0.2/tooling).
17:Tebf,This Page contains sdk details of version 4 of the Aqua Protocol.To Use version 3 which is stable visit [quickstart](/docs/v4.0.0/quickstart)
The Aqua SDK is a Rust library that provides the core functionality for creating, signing, witnessing, and verifying Aqua Protocol chains. It supports Aqua Protocol v4 and includes WebAssembly (WASM) bindings for cross-platform compatibility.

## Features

- **Create Aqua Chains**: Build revision chains with objects, templates, signatures, witnesses, and links
- **Template System**: Define and validate structured data using JSON Schema
- **Multiple Signature Methods**: Support for RSA, Ethereum EIP-191, and DID:JWS signatures
- **Blockchain Witnessing**: Anchor revisions to Ethereum (mainnet, Sepolia, Holesky), Nostr, or TSA
- **Chain Verification**: Cryptographically verify complete revision chains
- **Cross-Platform**: WASM support enables use in web browsers, Node.js, and native applications

## Installation

Add the SDK to your Rust project:

```toml cargo.toml
[dependencies]
aqua-rs-sdk = { git = "https://github.com/inblockio/aqua-verifier-rs" }
```

## Quick Example

```rust main.rs
    use aqua_rs_sdk::primitives::Method;
    use aqua_rs_sdk::schema::file_data::FileData;
    use aqua_rs_sdk::Aquafier;
    use std::path::PathBuf;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating Aqua chain...");

        // Read file content
        let filename = "test.txt".to_string();
        let file_content = tokio::fs::read(&filename).await?;

        // Create file data
        let file_data = FileData::new(
            filename.clone(),
            file_content,
            PathBuf::from(format!("./{}", filename)),
        );

        // Initialize Aquafier
        let aquafier = Aquafier::new(None, None);

        // Create genesis revision (notarize the file)
        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

        match result {
            Ok(tree) => {
                println!("✓ Aqua chain created successfully!");
                println!("{}", serde_json::to_string_pretty(&tree)?);

                println!("\nYou can now:");
                println!("- Add a signature revision");
                println!("- Witness on blockchain");
                println!("- Verify the chain");

                // Sign the revision
                // let signature = sign_revision(&object_revision, &signing_key)?;

                // Witness on blockchain
                // let witness = witness_revision(&signature, EthereumNetwork::Sepolia)?;

                // Verify the complete chain
                // let is_valid = verify_chain(&aqua_chain)?;

            }
            Err(e) => {
                eprintln!("Error: {:#?}", e);
            }
        }

        Ok(())
    }


```

## Use Cases

- **Application Integration**: Embed Aqua Protocol directly into your Rust applications
- **Custom Tools**: Build specialized tools for specific workflows
- **Smart Contracts**: Integrate with blockchain applications using WASM
- **Web Applications**: Use WASM bindings to run in browsers
- **Server Applications**: Build backend services with native Rust performance

## Repository

**GitHub**: [github.com/inblockio/aqua-verifier-rs](https://github.com/inblockio/aqua-rs-sdk)

## Documentation

For detailed API documentation, examples, and guides:
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction)
- [API Documentation](https://docs.rs/aqua-rs-sdk)

## Version

**Current Version**: 4.0.0 (Beta)

The SDK implements Aqua Protocol v4 with the template system and enhanced revision types. For production-stable implementations, consider the [JavaScript SDK (v3)](/docs/v3.0.2/tooling).
18:T127d,

Aquafier is a web-based reference implementation of Aqua Protocol v3, providing a user-friendly interface and HTTP API for digital content signing, provenance verification, and integrity validation. It demonstrates how Aqua Protocol features can be integrated into modern web applications.

## Overview

Aquafier combines a Fastify backend with React frontend to deliver a complete solution for document notarization and verification. It's designed as both a production tool and a reference implementation for developers building Aqua-based applications.

## Features

- **Digital Content Signing**: Sign documents and data with multiple signature methods
- **Provenance Verification**: Track and verify document history and authenticity
- **Integrity Validation**: Cryptographically verify document integrity
- **Web Interface**: User-friendly React interface for non-technical users
- **HTTP API**: RESTful API for programmatic access
- **Multi-Party Workflows**: Support for documents requiring multiple signatures

## Technology Stack

**Backend**:
- Fastify (Node.js web framework)
- Prisma ORM
- PostgreSQL database
- Aqua JavaScript SDK (v3)

**Frontend**:
- React with TypeScript
- Chakra UI components
- End-to-end testing with Playwright

## Hosted Instances

**Production**: [aquafier.inblock.io](https://aquafier.inblock.io/)
- Stable production environment
- For live document notarization and verification

**Development/Testing**: [dev.inblock.io](https://dev.inblock.io/)
- Testing environment for new features
- Use for development and experimentation

## Use Cases

- **Document Notarization**: Notarize legal documents, contracts, and agreements
- **Certificate Issuance**: Issue verifiable certificates and credentials
- **Multi-Party Signing**: Collect signatures from multiple parties
- **Audit Trail Creation**: Build immutable audit trails for compliance
- **Proof of Concept**: Demonstrate Aqua Protocol capabilities
- **API Integration**: Integrate notarization into existing systems

## API Access

Aquafier provides a RESTful HTTP API for programmatic access. Developers can integrate notarization and verification into their applications without building infrastructure from scratch.

Common API operations:
- Create genesis revisions
- Add signatures to existing chains
- Witness chains on blockchain
- Verify chain integrity
- Retrieve chain history

## Development

Aquafier-JS is open source and can be self-hosted for custom deployments.

### Requirements
- Docker and Docker Compose
- PostgreSQL database
- Node.js environment

### Deployment

Deploy using Docker Compose:

```bash
# Prepare environment file
cp deployment/.env.sample .env

# Start services
docker compose -f deployment/docker-compose-prod.yml up -d
```

**Deployment Options**:
- **Local**: No proxy, exposed ports for development
- **Dev**: With Let's Encrypt SSL and DNS
- **Prod**: Production configuration with SSL

### Configuration

Key environment variables:

```bash
# Database
DATABASE_URL=postgres://user:password@host:port/database

# Server
HOST=0.0.0.0
PORT=3000

# Frontend/Backend URLs (for proxy)
FRONTEND_URL=https://your-domain.com
BACKEND_URL=https://api.your-domain.com

# Twilio (optional, for SMS verification)
TWILIO_ACCOUNT_SID=your_sid
TWILIO_AUTH_TOKEN=your_token
```

## Architecture

Aquafier's modular architecture makes it suitable as a foundation for custom applications:

- **API Layer**: RESTful endpoints for all Aqua operations
- **Service Layer**: Business logic for chain management
- **Data Layer**: Prisma ORM with PostgreSQL
- **Storage**: File system or S3-compatible storage
- **Backup**: Automated backup with configurable retention

## Protocol Version

**Aqua Protocol v3**: Aquafier implements the stable JavaScript SDK

For v3 technical details:
- [Version 3 Introduction](/docs/v3.0.2/introduction)
- [Version 3 Concepts](/docs/v3.0.2/concepts)
- [Version 3 SDK](/docs/v3.0.2/tooling)

## Repository

**GitHub**: [github.com/inblockio/aquafier-js](https://github.com/inblockio/aquafier-js)

## Development Team

- Tim Bansemer - Project Manager
- Publius Dirac - Research / Developer
- Arthur Kamau - Developer
- Dalmas Nyaboga Ogembo - Developer
- Florian Zeps - DevOps


## Getting Started

1. Visit [aquafier.inblock.io](https://aquafier.inblock.io/) to use the hosted version
2. Try the [dev environment](https://dev.inblock.io/) for testing
3. Explore the API documentation for programmatic integration
4. Check the [GitHub repository](https://github.com/inblockio/aquafier-js) for self-hosting

For building custom applications, consider using the [Aqua JavaScript SDK](/docs/v3.0.2/tooling) directly or the [Aqua Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) for v4 features.
19:T127d,

Aquafier is a web-based reference implementation of Aqua Protocol v3, providing a user-friendly interface and HTTP API for digital content signing, provenance verification, and integrity validation. It demonstrates how Aqua Protocol features can be integrated into modern web applications.

## Overview

Aquafier combines a Fastify backend with React frontend to deliver a complete solution for document notarization and verification. It's designed as both a production tool and a reference implementation for developers building Aqua-based applications.

## Features

- **Digital Content Signing**: Sign documents and data with multiple signature methods
- **Provenance Verification**: Track and verify document history and authenticity
- **Integrity Validation**: Cryptographically verify document integrity
- **Web Interface**: User-friendly React interface for non-technical users
- **HTTP API**: RESTful API for programmatic access
- **Multi-Party Workflows**: Support for documents requiring multiple signatures

## Technology Stack

**Backend**:
- Fastify (Node.js web framework)
- Prisma ORM
- PostgreSQL database
- Aqua JavaScript SDK (v3)

**Frontend**:
- React with TypeScript
- Chakra UI components
- End-to-end testing with Playwright

## Hosted Instances

**Production**: [aquafier.inblock.io](https://aquafier.inblock.io/)
- Stable production environment
- For live document notarization and verification

**Development/Testing**: [dev.inblock.io](https://dev.inblock.io/)
- Testing environment for new features
- Use for development and experimentation

## Use Cases

- **Document Notarization**: Notarize legal documents, contracts, and agreements
- **Certificate Issuance**: Issue verifiable certificates and credentials
- **Multi-Party Signing**: Collect signatures from multiple parties
- **Audit Trail Creation**: Build immutable audit trails for compliance
- **Proof of Concept**: Demonstrate Aqua Protocol capabilities
- **API Integration**: Integrate notarization into existing systems

## API Access

Aquafier provides a RESTful HTTP API for programmatic access. Developers can integrate notarization and verification into their applications without building infrastructure from scratch.

Common API operations:
- Create genesis revisions
- Add signatures to existing chains
- Witness chains on blockchain
- Verify chain integrity
- Retrieve chain history

## Development

Aquafier-JS is open source and can be self-hosted for custom deployments.

### Requirements
- Docker and Docker Compose
- PostgreSQL database
- Node.js environment

### Deployment

Deploy using Docker Compose:

```bash
# Prepare environment file
cp deployment/.env.sample .env

# Start services
docker compose -f deployment/docker-compose-prod.yml up -d
```

**Deployment Options**:
- **Local**: No proxy, exposed ports for development
- **Dev**: With Let's Encrypt SSL and DNS
- **Prod**: Production configuration with SSL

### Configuration

Key environment variables:

```bash
# Database
DATABASE_URL=postgres://user:password@host:port/database

# Server
HOST=0.0.0.0
PORT=3000

# Frontend/Backend URLs (for proxy)
FRONTEND_URL=https://your-domain.com
BACKEND_URL=https://api.your-domain.com

# Twilio (optional, for SMS verification)
TWILIO_ACCOUNT_SID=your_sid
TWILIO_AUTH_TOKEN=your_token
```

## Architecture

Aquafier's modular architecture makes it suitable as a foundation for custom applications:

- **API Layer**: RESTful endpoints for all Aqua operations
- **Service Layer**: Business logic for chain management
- **Data Layer**: Prisma ORM with PostgreSQL
- **Storage**: File system or S3-compatible storage
- **Backup**: Automated backup with configurable retention

## Protocol Version

**Aqua Protocol v3**: Aquafier implements the stable JavaScript SDK

For v3 technical details:
- [Version 3 Introduction](/docs/v3.0.2/introduction)
- [Version 3 Concepts](/docs/v3.0.2/concepts)
- [Version 3 SDK](/docs/v3.0.2/tooling)

## Repository

**GitHub**: [github.com/inblockio/aquafier-js](https://github.com/inblockio/aquafier-js)

## Development Team

- Tim Bansemer - Project Manager
- Publius Dirac - Research / Developer
- Arthur Kamau - Developer
- Dalmas Nyaboga Ogembo - Developer
- Florian Zeps - DevOps


## Getting Started

1. Visit [aquafier.inblock.io](https://aquafier.inblock.io/) to use the hosted version
2. Try the [dev environment](https://dev.inblock.io/) for testing
3. Explore the API documentation for programmatic integration
4. Check the [GitHub repository](https://github.com/inblockio/aquafier-js) for self-hosting

For building custom applications, consider using the [Aqua JavaScript SDK](/docs/v3.0.2/tooling) directly or the [Aqua Rust SDK](/docs/v4.0.0/dev-tools/aqua-sdk) for v4 features.
1a:T4256,
# Link Revision

A Link Revision creates verifiable connections between separate revision chains. It allows you to establish relationships, dependencies, or references between different objects, effectively creating a graph structure of interconnected chains. Link revisions are essential for composing complex data structures and maintaining provenance across multiple chains.

## Overview

Link revisions enable:
- **Chain Composition**: Connect multiple independent chains together
- **Dependency Tracking**: Express that one chain depends on others
- **Multi-Party Collaboration**: Combine contributions from different parties
- **Provenance Graphs**: Build complex data relationship structures
- **Verification Aggregation**: Group related chains for batch verification

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the previous revision in this chain |
| `revision_type` | string | Yes | Always `"link"` for link revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the link was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `link_verification_hashes` | array | Yes | Array of revision hashes being linked to |

### Field Details

#### link_verification_hashes
- **Type**: Array of hex strings
- **Format**: Each element is a lowercase hex string prefixed with `0x`
- **Purpose**: References to other revision chains
- **Minimum**: Can be empty array (though typically contains at least one link)
- **Maximum**: No strict limit, but practical limits depend on implementation
- **Order**: Order may be significant depending on use case

## Example

### Basic Link Revision

Linking to two other chains:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "link",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
  ]
}
```

### Single Link

Linking to a single chain:

```json
{
  "previous_revision": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f",
  "revision_type": "link",
  "nonce": "0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d"
  ]
}
```

### Multiple Links (Aggregation)

Aggregating many chains:

```json
{
  "previous_revision": "0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c",
  "revision_type": "link",
  "nonce": "0xa1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1111111111111111111111111111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222222222222222222222222222",
    "0x3333333333333333333333333333333333333333333333333333333333333333",
    "0x4444444444444444444444444444444444444444444444444444444444444444",
    "0x5555555555555555555555555555555555555555555555555555555555555555"
  ]
}
```

## Validation Rules

A Link Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"link"`
3. **Previous Revision**: References a valid existing revision
4. **Link Array**: `link_verification_hashes` is a valid array
5. **Link Format**: Each element in the array is a valid hex string with `0x` prefix
6. **Link Targets**: Each referenced revision should exist and be verifiable (optional strict validation)
7. **No Duplicates**: Typically shouldn't contain duplicate hashes (application-specific)
8. **Hash Verification**: The computed hash of the link revision is correct

## Common Use Cases

### 1. Document Dependencies

Link a document to its source materials:

<Mermaid
  chart={`
    graph TD
      Contract[Contract Document - Object]
      Link[Link Revision]
      Ref1[Reference Doc 1]
      Ref2[Reference Doc 2]
      Ref3[Reference Doc 3]

      Contract --> Link
      Link -.->|references| Ref1
      Link -.->|references| Ref2
      Link -.->|references| Ref3
  `}
  caption="Document dependencies using link revision"
/>

### 2. Multi-Party Signing

Combine independent signatures:

<Mermaid
  chart={`
    graph TD
      Doc[Document Object]
      SigA[Signature - Alice]
      SigB[Signature - Bob]
      SigC[Signature - Carol]
      Link[Link Revision]
      Witness[Witness - Timestamp all]

      Doc --> SigA
      Doc --> SigB
      Doc --> SigC
      SigA --> Link
      SigB --> Link
      SigC --> Link
      Link --> Witness
  `}
  caption="Multi-party signing with link revision"
/>

### 3. Bill of Materials

Link a product to its components:

<Mermaid
  chart={`
    graph TD
      Product[Product Object]
      Link[Link Revision]
      Comp1[Component 1 Chain]
      Comp2[Component 2 Chain]
      Comp3[Component 3 Chain]

      Product --> Link
      Link -.->|references| Comp1
      Link -.->|references| Comp2
      Link -.->|references| Comp3
  `}
  caption="Bill of materials with component chains"
/>

Each component has its own provenance chain.

### 4. Credential Bundling

Group related credentials:

<Mermaid
  chart={`
    graph TD
      Profile[Profile Object]
      Link[Link Revision]
      Email[Email Credential]
      Domain[Domain Credential]
      GitHub[GitHub Credential]

      Profile --> Link
      Link -.->|references| Email
      Link -.->|references| Domain
      Link -.->|references| GitHub
  `}
  caption="Credential bundling with link revision"
/>

### 5. Supply Chain Aggregation

Combine supply chain events:

<Mermaid
  chart={`
    graph TD
      Tracking[Shipment Tracking]
      Link[Link Revision]
      Manufacturer[Manufacturer Chain]
      Shipper[Shipper Chain]
      Customs[Customs Chain]
      Final[Final Delivery Confirmation]

      Tracking --> Link
      Link -.->|references| Manufacturer
      Link -.->|references| Shipper
      Link -.->|references| Customs
      Link --> Final
  `}
  caption="Supply chain aggregation"
/>

### 6. Academic Citation

Link a paper to cited works:

<Mermaid
  chart={`
    graph TD
      Paper[Research Paper - Object]
      Link[Link Revision]
      Cite1[Citation 1 Chain]
      Cite2[Citation 2 Chain]
      CiteN[Citation N Chain]

      Paper --> Link
      Link -.->|references| Cite1
      Link -.->|references| Cite2
      Link -.->|references| CiteN
  `}
  caption="Academic citation with link revision"
/>

### 7. Version History

Link to previous versions:

<Mermaid
  chart={`
    graph TD
      V3[Document v3 - Object]
      Link[Link Revision]
      V1[Document v1 Final]
      V2[Document v2 Final]

      V3 --> Link
      Link -.->|references| V1
      Link -.->|references| V2
  `}
  caption="Version history with link revision"
/>

### 8. Approval Workflow Merge

Merge parallel approval processes:

<Mermaid
  chart={`
    graph TD
      Draft[Document Draft]
      ReviewA[Review A]
      ReviewB[Review B]
      ApproveA[Approve A]
      ApproveB[Approve B]
      Link[Link Revision]
      Final[Final Version]

      Draft --> ReviewA
      Draft --> ReviewB
      ReviewA --> ApproveA
      ReviewB --> ApproveB
      ApproveA --> Link
      ApproveB --> Link
      Link --> Final
  `}
  caption="Approval workflow merge with link revision"
/>

## Link Patterns

### Pattern 1: Linear Dependency Chain

<Mermaid
  chart={`
    graph LR
      A[Object A]
      LinkAB[Link]
      B[Object B]
      LinkBC[Link]
      C[Object C]

      A --> LinkAB
      LinkAB -.->|references| B
      B --> LinkBC
      LinkBC -.->|references| C
  `}
  caption="Linear dependency chain"
/>

Each object depends on the previous one.

### Pattern 2: Star Pattern (Aggregation)

<Mermaid
  chart={`
    graph TD
      Link[Link Revision]
      A[Chain A]
      B[Chain B]
      C[Chain C]
      D[Chain D]
      E[Chain E]

      Link -.->|references| A
      Link -.->|references| B
      Link -.->|references| C
      Link -.->|references| D
      Link -.->|references| E
  `}
  caption="Star pattern - one link references multiple chains"
/>

One link revision references multiple chains.

### Pattern 3: Tree Pattern

<Mermaid
  chart={`
    graph TD
      Root[Root Object]
      Link1[Link to A, B]
      LinkA[Link to A1, A2]
      LinkB[Link to B1, B2]
      A1[A1]
      A2[A2]
      B1[B1]
      B2[B2]

      Root --> Link1
      Link1 -.-> LinkA
      Link1 -.-> LinkB
      LinkA -.->|references| A1
      LinkA -.->|references| A2
      LinkB -.->|references| B1
      LinkB -.->|references| B2
  `}
  caption="Tree pattern - hierarchical structure using links"
/>

Hierarchical structure using links.

### Pattern 4: Graph Pattern

<Mermaid
  chart={`
    graph TD
      A[A]
      B[B]
      C[C]
      D[D]
      E[E]
      LinkA[Link from A]
      LinkB[Link from B]
      LinkC[Link from C]

      A --> LinkA
      LinkA -.->|references| B
      LinkA -.->|references| C

      B --> LinkB
      LinkB -.->|references| C
      LinkB -.->|references| D

      C --> LinkC
      LinkC -.->|references| A
      LinkC -.->|references| E
  `}
  caption="Graph pattern - complex graph with cycles and multiple connections"
/>

Complex graph with cycles and multiple connections.

## Implementation Notes

### Creating a Link Revision

1. Identify the chains to link
2. Get the head (latest) revision hash from each chain
3. Collect hashes into `link_verification_hashes` array
4. Determine the `previous_revision` for this link
5. Generate nonce and timestamp
6. Create the link revision structure
7. Compute and verify the hash

### Verifying a Link Revision

#### Basic Verification
```
1. Verify link revision structure
2. Validate each hash in link_verification_hashes
3. Compute link revision hash
```

#### Deep Verification
```
1. Perform basic verification
2. For each linked hash:
   a. Retrieve the referenced revision
   b. Verify the referenced revision chain
   c. Check signatures and witnesses
3. Validate all linked chains
```

### Link Resolution

When traversing links:

```
1. Start with link revision
2. Extract link_verification_hashes
3. For each hash:
   a. Resolve to actual revision
   b. Load revision chain
   c. Verify chain integrity
4. Build complete relationship graph
```

## Advanced Topics

### Cyclic References

Links can create cycles:

<Mermaid
  chart={`
    graph LR
      A[Chain A]
      LinkA[Link from A]
      B[Chain B]
      LinkB[Link from B]

      A --> LinkA
      LinkA -.->|references| B
      B --> LinkB
      LinkB -.->|references| A
  `}
  caption="Cyclic references between chains"
/>

**Handling**:
- Detect cycles during traversal
- Use visited set to prevent infinite loops
- Cycles may be valid depending on use case

### Temporal Ordering

Links create a temporal relationship:

```
Link created at timestamp T references chains that existed before T
```

**Validation**:
- Linked revisions should have timestamps < link timestamp
- Prevents linking to "future" revisions

### Partial vs Complete References

**Complete Reference**: Link to final revision of a chain
```
Link → [Complete Chain A, Complete Chain B]
```

**Partial Reference**: Link to intermediate revision
```
Link → [Chain A @ Revision 5, Chain B @ Revision 3]
```

### Link Updates

To update links over time:

<Mermaid
  chart={`
    graph TD
      Obj[Object]
      Link1[Link v1 - references A, B]
      Link2[Link v2 - references A, B, C]
      Link3[Link v3 - references A, C]

      Obj --> Link1
      Link1 --> Link2
      Link2 --> Link3
  `}
  caption="Link updates tracking changes over time"
/>

Each link revision chains to the previous, tracking changes.

### Link Metadata

While the standard link revision doesn't include metadata, you can add it by:

1. Creating an object revision with link metadata
2. Following it with a link revision

<Mermaid
  chart={`
    graph TD
      Obj[Object - metadata: 'This links dependencies']
      Link[Link Revision]
      Dep1[Dep1]
      Dep2[Dep2]
      Dep3[Dep3]

      Obj --> Link
      Link -.->|references| Dep1
      Link -.->|references| Dep2
      Link -.->|references| Dep3
  `}
  caption="Link metadata using object revision"
/>

## Relationship with Other Revisions

- **Object Revisions**: Can be linked, and can precede link revisions
- **Signature Revisions**: Can be linked (e.g., aggregating signatures)
- **Witness Revisions**: Can be linked, or can follow link revisions
- **Template Revisions**: Typically not linked (they're standalone)

## Security Considerations

### 1. Link Validation

**Verify Existence**: Ensure linked revisions actually exist before creating link
**Verify Integrity**: Validate linked chains are not corrupted

### 2. Circular Dependencies

**Detection**: Implement cycle detection in verification
**Policy**: Decide if cycles are allowed in your application

### 3. Link Spam

**Prevention**: Validate that links are meaningful and authorized
**Rate Limiting**: Prevent excessive linking in systems

### 4. Temporal Consistency

**Timestamp Checking**: Ensure links don't reference "future" revisions
**Causality**: Maintain causal ordering of events

### 5. Authorization

**Link Permission**: Verify the creator has rights to link to target chains
**Privacy**: Linking may reveal relationships between otherwise private chains

## Performance Considerations

### Link Depth

Deep link hierarchies impact verification time:

```
Object → Link (10 chains) → Each chain has Link (5 chains)
Total: 1 + 10 + 50 = 61 chains to verify
```

**Optimization**: Cache verified chains, use lazy loading

### Link Width

Wide links (many references) increase storage and bandwidth:

```
Link → [1000 chains]
```

**Optimization**: Paginate links, use link batching

### Verification Strategy

**Lazy**: Only verify linked chains when accessed
**Eager**: Verify all linked chains upfront
**Selective**: Verify critical paths only

## Comparison with Other Approaches

### vs Direct References

**Direct Reference** (in object payload):
```json
{
  "payload": {
    "dependencies": ["0xabc...", "0xdef..."]
  }
}
```

**Link Revision**:
```json
{
  "link_verification_hashes": ["0xabc...", "0xdef..."]
}
```

**Advantages of Link Revision**:
- Explicit in protocol (not application-specific)
- Verifiable without parsing payload
- Consistent structure across applications
- Can be signed and witnessed separately

### vs Witness Batching

**Witness Batching**: Uses Merkle tree for efficient blockchain anchoring
**Link Revision**: Creates explicit relationships between chains

**Key Difference**: Witness is about timestamping, Link is about relationships.

## Best Practices

### 1. Use Descriptive Ordering

Order links meaningfully:
```
["primary_source", "secondary_source", "tertiary_source"]
```

### 2. Link to Stable Points

Link to revisions that are finalized (signed/witnessed):

<Mermaid
  chart={`
    graph LR
      Obj[Object]
      Sign[Sign]
      Witness[Witness]
      Link[Link references this witnessed revision]

      Obj --> Sign
      Sign --> Witness
      Witness -.-> Link
  `}
  caption="Linking to stable, witnessed revisions"
/>

### 3. Document Link Semantics

Precede link with an object explaining the relationships:

<Mermaid
  chart={`
    graph TD
      Obj[Object - description: 'These are the project dependencies']
      Link[Link Revision]
      Deps[Dependency chains]

      Obj --> Link
      Link -.->|references| Deps
  `}
  caption="Documenting link semantics with object metadata"
/>

### 4. Consider Verification Cost

Limit link depth and width for practical verification times.

### 5. Use Links for Cross-Chain Only

Don't use links for intra-chain references (use `previous_revision` instead).

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Often linked
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Can aggregate via links
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Often follows links
- [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) - Mathematical foundation for link structures
1b:T4256,
# Link Revision

A Link Revision creates verifiable connections between separate revision chains. It allows you to establish relationships, dependencies, or references between different objects, effectively creating a graph structure of interconnected chains. Link revisions are essential for composing complex data structures and maintaining provenance across multiple chains.

## Overview

Link revisions enable:
- **Chain Composition**: Connect multiple independent chains together
- **Dependency Tracking**: Express that one chain depends on others
- **Multi-Party Collaboration**: Combine contributions from different parties
- **Provenance Graphs**: Build complex data relationship structures
- **Verification Aggregation**: Group related chains for batch verification

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the previous revision in this chain |
| `revision_type` | string | Yes | Always `"link"` for link revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the link was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `link_verification_hashes` | array | Yes | Array of revision hashes being linked to |

### Field Details

#### link_verification_hashes
- **Type**: Array of hex strings
- **Format**: Each element is a lowercase hex string prefixed with `0x`
- **Purpose**: References to other revision chains
- **Minimum**: Can be empty array (though typically contains at least one link)
- **Maximum**: No strict limit, but practical limits depend on implementation
- **Order**: Order may be significant depending on use case

## Example

### Basic Link Revision

Linking to two other chains:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "link",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
  ]
}
```

### Single Link

Linking to a single chain:

```json
{
  "previous_revision": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f",
  "revision_type": "link",
  "nonce": "0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d"
  ]
}
```

### Multiple Links (Aggregation)

Aggregating many chains:

```json
{
  "previous_revision": "0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c",
  "revision_type": "link",
  "nonce": "0xa1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "link_verification_hashes": [
    "0x1111111111111111111111111111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222222222222222222222222222",
    "0x3333333333333333333333333333333333333333333333333333333333333333",
    "0x4444444444444444444444444444444444444444444444444444444444444444",
    "0x5555555555555555555555555555555555555555555555555555555555555555"
  ]
}
```

## Validation Rules

A Link Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"link"`
3. **Previous Revision**: References a valid existing revision
4. **Link Array**: `link_verification_hashes` is a valid array
5. **Link Format**: Each element in the array is a valid hex string with `0x` prefix
6. **Link Targets**: Each referenced revision should exist and be verifiable (optional strict validation)
7. **No Duplicates**: Typically shouldn't contain duplicate hashes (application-specific)
8. **Hash Verification**: The computed hash of the link revision is correct

## Common Use Cases

### 1. Document Dependencies

Link a document to its source materials:

<Mermaid
  chart={`
    graph TD
      Contract[Contract Document - Object]
      Link[Link Revision]
      Ref1[Reference Doc 1]
      Ref2[Reference Doc 2]
      Ref3[Reference Doc 3]

      Contract --> Link
      Link -.->|references| Ref1
      Link -.->|references| Ref2
      Link -.->|references| Ref3
  `}
  caption="Document dependencies using link revision"
/>

### 2. Multi-Party Signing

Combine independent signatures:

<Mermaid
  chart={`
    graph TD
      Doc[Document Object]
      SigA[Signature - Alice]
      SigB[Signature - Bob]
      SigC[Signature - Carol]
      Link[Link Revision]
      Witness[Witness - Timestamp all]

      Doc --> SigA
      Doc --> SigB
      Doc --> SigC
      SigA --> Link
      SigB --> Link
      SigC --> Link
      Link --> Witness
  `}
  caption="Multi-party signing with link revision"
/>

### 3. Bill of Materials

Link a product to its components:

<Mermaid
  chart={`
    graph TD
      Product[Product Object]
      Link[Link Revision]
      Comp1[Component 1 Chain]
      Comp2[Component 2 Chain]
      Comp3[Component 3 Chain]

      Product --> Link
      Link -.->|references| Comp1
      Link -.->|references| Comp2
      Link -.->|references| Comp3
  `}
  caption="Bill of materials with component chains"
/>

Each component has its own provenance chain.

### 4. Credential Bundling

Group related credentials:

<Mermaid
  chart={`
    graph TD
      Profile[Profile Object]
      Link[Link Revision]
      Email[Email Credential]
      Domain[Domain Credential]
      GitHub[GitHub Credential]

      Profile --> Link
      Link -.->|references| Email
      Link -.->|references| Domain
      Link -.->|references| GitHub
  `}
  caption="Credential bundling with link revision"
/>

### 5. Supply Chain Aggregation

Combine supply chain events:

<Mermaid
  chart={`
    graph TD
      Tracking[Shipment Tracking]
      Link[Link Revision]
      Manufacturer[Manufacturer Chain]
      Shipper[Shipper Chain]
      Customs[Customs Chain]
      Final[Final Delivery Confirmation]

      Tracking --> Link
      Link -.->|references| Manufacturer
      Link -.->|references| Shipper
      Link -.->|references| Customs
      Link --> Final
  `}
  caption="Supply chain aggregation"
/>

### 6. Academic Citation

Link a paper to cited works:

<Mermaid
  chart={`
    graph TD
      Paper[Research Paper - Object]
      Link[Link Revision]
      Cite1[Citation 1 Chain]
      Cite2[Citation 2 Chain]
      CiteN[Citation N Chain]

      Paper --> Link
      Link -.->|references| Cite1
      Link -.->|references| Cite2
      Link -.->|references| CiteN
  `}
  caption="Academic citation with link revision"
/>

### 7. Version History

Link to previous versions:

<Mermaid
  chart={`
    graph TD
      V3[Document v3 - Object]
      Link[Link Revision]
      V1[Document v1 Final]
      V2[Document v2 Final]

      V3 --> Link
      Link -.->|references| V1
      Link -.->|references| V2
  `}
  caption="Version history with link revision"
/>

### 8. Approval Workflow Merge

Merge parallel approval processes:

<Mermaid
  chart={`
    graph TD
      Draft[Document Draft]
      ReviewA[Review A]
      ReviewB[Review B]
      ApproveA[Approve A]
      ApproveB[Approve B]
      Link[Link Revision]
      Final[Final Version]

      Draft --> ReviewA
      Draft --> ReviewB
      ReviewA --> ApproveA
      ReviewB --> ApproveB
      ApproveA --> Link
      ApproveB --> Link
      Link --> Final
  `}
  caption="Approval workflow merge with link revision"
/>

## Link Patterns

### Pattern 1: Linear Dependency Chain

<Mermaid
  chart={`
    graph LR
      A[Object A]
      LinkAB[Link]
      B[Object B]
      LinkBC[Link]
      C[Object C]

      A --> LinkAB
      LinkAB -.->|references| B
      B --> LinkBC
      LinkBC -.->|references| C
  `}
  caption="Linear dependency chain"
/>

Each object depends on the previous one.

### Pattern 2: Star Pattern (Aggregation)

<Mermaid
  chart={`
    graph TD
      Link[Link Revision]
      A[Chain A]
      B[Chain B]
      C[Chain C]
      D[Chain D]
      E[Chain E]

      Link -.->|references| A
      Link -.->|references| B
      Link -.->|references| C
      Link -.->|references| D
      Link -.->|references| E
  `}
  caption="Star pattern - one link references multiple chains"
/>

One link revision references multiple chains.

### Pattern 3: Tree Pattern

<Mermaid
  chart={`
    graph TD
      Root[Root Object]
      Link1[Link to A, B]
      LinkA[Link to A1, A2]
      LinkB[Link to B1, B2]
      A1[A1]
      A2[A2]
      B1[B1]
      B2[B2]

      Root --> Link1
      Link1 -.-> LinkA
      Link1 -.-> LinkB
      LinkA -.->|references| A1
      LinkA -.->|references| A2
      LinkB -.->|references| B1
      LinkB -.->|references| B2
  `}
  caption="Tree pattern - hierarchical structure using links"
/>

Hierarchical structure using links.

### Pattern 4: Graph Pattern

<Mermaid
  chart={`
    graph TD
      A[A]
      B[B]
      C[C]
      D[D]
      E[E]
      LinkA[Link from A]
      LinkB[Link from B]
      LinkC[Link from C]

      A --> LinkA
      LinkA -.->|references| B
      LinkA -.->|references| C

      B --> LinkB
      LinkB -.->|references| C
      LinkB -.->|references| D

      C --> LinkC
      LinkC -.->|references| A
      LinkC -.->|references| E
  `}
  caption="Graph pattern - complex graph with cycles and multiple connections"
/>

Complex graph with cycles and multiple connections.

## Implementation Notes

### Creating a Link Revision

1. Identify the chains to link
2. Get the head (latest) revision hash from each chain
3. Collect hashes into `link_verification_hashes` array
4. Determine the `previous_revision` for this link
5. Generate nonce and timestamp
6. Create the link revision structure
7. Compute and verify the hash

### Verifying a Link Revision

#### Basic Verification
```
1. Verify link revision structure
2. Validate each hash in link_verification_hashes
3. Compute link revision hash
```

#### Deep Verification
```
1. Perform basic verification
2. For each linked hash:
   a. Retrieve the referenced revision
   b. Verify the referenced revision chain
   c. Check signatures and witnesses
3. Validate all linked chains
```

### Link Resolution

When traversing links:

```
1. Start with link revision
2. Extract link_verification_hashes
3. For each hash:
   a. Resolve to actual revision
   b. Load revision chain
   c. Verify chain integrity
4. Build complete relationship graph
```

## Advanced Topics

### Cyclic References

Links can create cycles:

<Mermaid
  chart={`
    graph LR
      A[Chain A]
      LinkA[Link from A]
      B[Chain B]
      LinkB[Link from B]

      A --> LinkA
      LinkA -.->|references| B
      B --> LinkB
      LinkB -.->|references| A
  `}
  caption="Cyclic references between chains"
/>

**Handling**:
- Detect cycles during traversal
- Use visited set to prevent infinite loops
- Cycles may be valid depending on use case

### Temporal Ordering

Links create a temporal relationship:

```
Link created at timestamp T references chains that existed before T
```

**Validation**:
- Linked revisions should have timestamps < link timestamp
- Prevents linking to "future" revisions

### Partial vs Complete References

**Complete Reference**: Link to final revision of a chain
```
Link → [Complete Chain A, Complete Chain B]
```

**Partial Reference**: Link to intermediate revision
```
Link → [Chain A @ Revision 5, Chain B @ Revision 3]
```

### Link Updates

To update links over time:

<Mermaid
  chart={`
    graph TD
      Obj[Object]
      Link1[Link v1 - references A, B]
      Link2[Link v2 - references A, B, C]
      Link3[Link v3 - references A, C]

      Obj --> Link1
      Link1 --> Link2
      Link2 --> Link3
  `}
  caption="Link updates tracking changes over time"
/>

Each link revision chains to the previous, tracking changes.

### Link Metadata

While the standard link revision doesn't include metadata, you can add it by:

1. Creating an object revision with link metadata
2. Following it with a link revision

<Mermaid
  chart={`
    graph TD
      Obj[Object - metadata: 'This links dependencies']
      Link[Link Revision]
      Dep1[Dep1]
      Dep2[Dep2]
      Dep3[Dep3]

      Obj --> Link
      Link -.->|references| Dep1
      Link -.->|references| Dep2
      Link -.->|references| Dep3
  `}
  caption="Link metadata using object revision"
/>

## Relationship with Other Revisions

- **Object Revisions**: Can be linked, and can precede link revisions
- **Signature Revisions**: Can be linked (e.g., aggregating signatures)
- **Witness Revisions**: Can be linked, or can follow link revisions
- **Template Revisions**: Typically not linked (they're standalone)

## Security Considerations

### 1. Link Validation

**Verify Existence**: Ensure linked revisions actually exist before creating link
**Verify Integrity**: Validate linked chains are not corrupted

### 2. Circular Dependencies

**Detection**: Implement cycle detection in verification
**Policy**: Decide if cycles are allowed in your application

### 3. Link Spam

**Prevention**: Validate that links are meaningful and authorized
**Rate Limiting**: Prevent excessive linking in systems

### 4. Temporal Consistency

**Timestamp Checking**: Ensure links don't reference "future" revisions
**Causality**: Maintain causal ordering of events

### 5. Authorization

**Link Permission**: Verify the creator has rights to link to target chains
**Privacy**: Linking may reveal relationships between otherwise private chains

## Performance Considerations

### Link Depth

Deep link hierarchies impact verification time:

```
Object → Link (10 chains) → Each chain has Link (5 chains)
Total: 1 + 10 + 50 = 61 chains to verify
```

**Optimization**: Cache verified chains, use lazy loading

### Link Width

Wide links (many references) increase storage and bandwidth:

```
Link → [1000 chains]
```

**Optimization**: Paginate links, use link batching

### Verification Strategy

**Lazy**: Only verify linked chains when accessed
**Eager**: Verify all linked chains upfront
**Selective**: Verify critical paths only

## Comparison with Other Approaches

### vs Direct References

**Direct Reference** (in object payload):
```json
{
  "payload": {
    "dependencies": ["0xabc...", "0xdef..."]
  }
}
```

**Link Revision**:
```json
{
  "link_verification_hashes": ["0xabc...", "0xdef..."]
}
```

**Advantages of Link Revision**:
- Explicit in protocol (not application-specific)
- Verifiable without parsing payload
- Consistent structure across applications
- Can be signed and witnessed separately

### vs Witness Batching

**Witness Batching**: Uses Merkle tree for efficient blockchain anchoring
**Link Revision**: Creates explicit relationships between chains

**Key Difference**: Witness is about timestamping, Link is about relationships.

## Best Practices

### 1. Use Descriptive Ordering

Order links meaningfully:
```
["primary_source", "secondary_source", "tertiary_source"]
```

### 2. Link to Stable Points

Link to revisions that are finalized (signed/witnessed):

<Mermaid
  chart={`
    graph LR
      Obj[Object]
      Sign[Sign]
      Witness[Witness]
      Link[Link references this witnessed revision]

      Obj --> Sign
      Sign --> Witness
      Witness -.-> Link
  `}
  caption="Linking to stable, witnessed revisions"
/>

### 3. Document Link Semantics

Precede link with an object explaining the relationships:

<Mermaid
  chart={`
    graph TD
      Obj[Object - description: 'These are the project dependencies']
      Link[Link Revision]
      Deps[Dependency chains]

      Obj --> Link
      Link -.->|references| Deps
  `}
  caption="Documenting link semantics with object metadata"
/>

### 4. Consider Verification Cost

Limit link depth and width for practical verification times.

### 5. Use Links for Cross-Chain Only

Don't use links for intra-chain references (use `previous_revision` instead).

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Often linked
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Can aggregate via links
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Often follows links
- [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) - Mathematical foundation for link structures
1c:T20c7,
# Object Revision

An Object Revision is the primary data-carrying revision type in Aqua Protocol v4. It stores arbitrary structured data that conforms to a template schema. Object revisions are typically the first revision in a chain (genesis) or follow other object revisions.

## Overview

Object revisions serve as containers for application data. Each object revision:
- References a template (via `revision_type` field) that defines its schema
- Contains a `payload` with the actual data
- Can be the genesis revision (no `previous_revision`) or link to a previous revision
- Must conform to the validation rules defined by its template

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Conditional | Hash reference to the previous revision. **Optional for genesis revisions**, **Required for subsequent revisions** |
| `revision_type` | string | Yes | Hash reference to the template that defines the payload schema |
| `nonce` | string | Yes | Random 16-byte hex string (e.g., `0x2ba6a8b9b987cf8c3567f72871812ae9`) for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp (seconds since epoch) when the revision was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `payload` | object | Yes | The actual data, must conform to the referenced template schema |

### Field Details

#### previous_revision
- **Format**: Lowercase hex string prefixed with `0x` (e.g., `0x3f8a...`)
- **Length**: Variable (typically 64 characters for SHA3-256 hashes)
- **Omitted**: Only in genesis revisions (the first revision in a chain)
- **Purpose**: Creates the chain linkage and ensures revision ordering

#### revision_type
- **Format**: Hash reference pointing to a Template Revision
- **Purpose**: Identifies which template validates this object's payload
- **Example**: `0x1234abcd...` (hash of a template revision)
- **Validation**: The template's schema must validate the payload

#### payload
- **Type**: JSON object
- **Validation**: Must conform to the JSON Schema defined in the referenced template
- **Flexibility**: Can contain any structured data as long as it matches the template
- **Size**: Depends on the method:
  - `scalar`: Entire payload is hashed directly
  - `tree`: Payload is broken into leaves for merkle tree construction

## Methods

### Scalar Method

The `scalar` method treats the entire object as a single unit. The payload is serialized, canonicalized, and hashed as one block.

**Best for:**
- Small to medium-sized objects
- When you need to verify the entire object at once
- Simple use cases

### Tree Method

The `tree` method breaks the payload into leaves using JSON pointers, creating a merkle tree structure.

**Best for:**
- Large objects where partial verification is needed
- When you want to prove specific fields without revealing the entire object
- Advanced use cases requiring selective disclosure

## Examples

### Example 1: Genesis Object Revision (File)

This is a genesis revision (first in chain) using the File template:

```json
{
  "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
  "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "payload_type": "application/pdf",
    "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "hash_type": "FIPS_202-SHA3-256",
    "descriptor": "Important Contract Document"
  }
}
```

**Note**: No `previous_revision` field because this is a genesis revision.

### Example 2: Subsequent Object Revision (Domain Claim)

This revision follows another revision in the chain:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "0x8b3e4c7d9f1a2b5c6e8f0a3b4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "domain": "example.com",
    "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
  }
}
```

### Example 3: Object with Tree Method

Using the tree method for a larger object:

```json
{
  "previous_revision": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b",
  "revision_type": "0x4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "tree",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "name": "John Doe",
    "email": "john@example.com",
    "phone": "+1234567890",
    "address": {
      "street": "123 Main St",
      "city": "Anytown",
      "country": "USA"
    },
    "metadata": {
      "created": "2024-01-01",
      "verified": true
    }
  }
}
```

**With tree method**: Each field (using JSON pointers like `/name`, `/email`, `/address/city`) becomes a leaf in the merkle tree.

## Validation Rules

An Object Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Version**: The `version` field matches `"https://aqua-protocol.org/docs/v4/schema"`
3. **Method**: The `method` is either `"scalar"` or `"tree"`
4. **Hash Type**: The `hash_type` is a recognized algorithm (e.g., `"FIPS_202-SHA3-256"`)
5. **Nonce**: Is a valid 16-byte hex string prefixed with `0x`
6. **Timestamp**: Is a valid Unix timestamp
7. **Previous Revision**:
   - Must be absent for genesis revisions
   - Must be present and valid for non-genesis revisions
   - Must reference an existing revision
8. **Revision Type**: Must reference a valid template revision
9. **Payload**: Must conform to the JSON Schema defined in the referenced template
10. **Hash Verification**: The computed hash matches what's expected

## Common Use Cases

### Document Storage
Store file metadata with hash references:
```json
{
  "payload": {
    "payload_type": "application/pdf",
    "hash": "0x...",
    "hash_type": "FIPS_202-SHA3-256",
    "descriptor": "Legal Agreement 2024"
  }
}
```

### Identity Claims
Store verifiable claims about entities:
```json
{
  "payload": {
    "domain": "company.com",
    "wallet_address": "0x742d35Cc..."
  }
}
```

### Credential Data
Store structured credential information:
```json
{
  "payload": {
    "credential_type": "EmailVerification",
    "subject": "user@example.com",
    "issuer": "0x...",
    "issued_at": 1704067200
  }
}
```

## Relationship with Other Revisions

After creating an Object Revision, you typically:

1. **Sign it** - Add a Signature Revision to prove authenticity
2. **Witness it** - Add a Witness Revision for timestamped proof
3. **Update it** - Create a new Object Revision that references this one
4. **Link it** - Create a Link Revision to connect to other chains

## Implementation Notes

### Creating an Object Revision

When implementing object revision creation:

1. Validate payload against the template schema first
2. Generate a random 16-byte nonce
3. Capture the current timestamp
4. Include `previous_revision` only if not genesis
5. Serialize according to the chosen method
6. Compute the hash for verification

### Verifying an Object Revision

To verify an object revision:

1. Check all required fields are present
2. Validate field types and formats
3. Verify the referenced template exists
4. Validate payload against template schema
5. Recompute the hash and compare
6. If not genesis, verify `previous_revision` exists and is valid

## See Also

- [Template Revision](/docs/v4.0.0/schema-reference/revision/template-revision) - Defines the schema for object payloads
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Sign object revisions
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Add timestamped proof
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Connect to other chains
1d:T20c7,
# Object Revision

An Object Revision is the primary data-carrying revision type in Aqua Protocol v4. It stores arbitrary structured data that conforms to a template schema. Object revisions are typically the first revision in a chain (genesis) or follow other object revisions.

## Overview

Object revisions serve as containers for application data. Each object revision:
- References a template (via `revision_type` field) that defines its schema
- Contains a `payload` with the actual data
- Can be the genesis revision (no `previous_revision`) or link to a previous revision
- Must conform to the validation rules defined by its template

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Conditional | Hash reference to the previous revision. **Optional for genesis revisions**, **Required for subsequent revisions** |
| `revision_type` | string | Yes | Hash reference to the template that defines the payload schema |
| `nonce` | string | Yes | Random 16-byte hex string (e.g., `0x2ba6a8b9b987cf8c3567f72871812ae9`) for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp (seconds since epoch) when the revision was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `payload` | object | Yes | The actual data, must conform to the referenced template schema |

### Field Details

#### previous_revision
- **Format**: Lowercase hex string prefixed with `0x` (e.g., `0x3f8a...`)
- **Length**: Variable (typically 64 characters for SHA3-256 hashes)
- **Omitted**: Only in genesis revisions (the first revision in a chain)
- **Purpose**: Creates the chain linkage and ensures revision ordering

#### revision_type
- **Format**: Hash reference pointing to a Template Revision
- **Purpose**: Identifies which template validates this object's payload
- **Example**: `0x1234abcd...` (hash of a template revision)
- **Validation**: The template's schema must validate the payload

#### payload
- **Type**: JSON object
- **Validation**: Must conform to the JSON Schema defined in the referenced template
- **Flexibility**: Can contain any structured data as long as it matches the template
- **Size**: Depends on the method:
  - `scalar`: Entire payload is hashed directly
  - `tree`: Payload is broken into leaves for merkle tree construction

## Methods

### Scalar Method

The `scalar` method treats the entire object as a single unit. The payload is serialized, canonicalized, and hashed as one block.

**Best for:**
- Small to medium-sized objects
- When you need to verify the entire object at once
- Simple use cases

### Tree Method

The `tree` method breaks the payload into leaves using JSON pointers, creating a merkle tree structure.

**Best for:**
- Large objects where partial verification is needed
- When you want to prove specific fields without revealing the entire object
- Advanced use cases requiring selective disclosure

## Examples

### Example 1: Genesis Object Revision (File)

This is a genesis revision (first in chain) using the File template:

```json
{
  "revision_type": "0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e",
  "nonce": "0x3fa8b1c2d3e4f5a67b8c9d0e1f2a3b4c",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "payload_type": "application/pdf",
    "hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "hash_type": "FIPS_202-SHA3-256",
    "descriptor": "Important Contract Document"
  }
}
```

**Note**: No `previous_revision` field because this is a genesis revision.

### Example 2: Subsequent Object Revision (Domain Claim)

This revision follows another revision in the chain:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "0x8b3e4c7d9f1a2b5c6e8f0a3b4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "domain": "example.com",
    "wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
  }
}
```

### Example 3: Object with Tree Method

Using the tree method for a larger object:

```json
{
  "previous_revision": "0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b",
  "revision_type": "0x4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "tree",
  "hash_type": "FIPS_202-SHA3-256",
  "payload": {
    "name": "John Doe",
    "email": "john@example.com",
    "phone": "+1234567890",
    "address": {
      "street": "123 Main St",
      "city": "Anytown",
      "country": "USA"
    },
    "metadata": {
      "created": "2024-01-01",
      "verified": true
    }
  }
}
```

**With tree method**: Each field (using JSON pointers like `/name`, `/email`, `/address/city`) becomes a leaf in the merkle tree.

## Validation Rules

An Object Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Version**: The `version` field matches `"https://aqua-protocol.org/docs/v4/schema"`
3. **Method**: The `method` is either `"scalar"` or `"tree"`
4. **Hash Type**: The `hash_type` is a recognized algorithm (e.g., `"FIPS_202-SHA3-256"`)
5. **Nonce**: Is a valid 16-byte hex string prefixed with `0x`
6. **Timestamp**: Is a valid Unix timestamp
7. **Previous Revision**:
   - Must be absent for genesis revisions
   - Must be present and valid for non-genesis revisions
   - Must reference an existing revision
8. **Revision Type**: Must reference a valid template revision
9. **Payload**: Must conform to the JSON Schema defined in the referenced template
10. **Hash Verification**: The computed hash matches what's expected

## Common Use Cases

### Document Storage
Store file metadata with hash references:
```json
{
  "payload": {
    "payload_type": "application/pdf",
    "hash": "0x...",
    "hash_type": "FIPS_202-SHA3-256",
    "descriptor": "Legal Agreement 2024"
  }
}
```

### Identity Claims
Store verifiable claims about entities:
```json
{
  "payload": {
    "domain": "company.com",
    "wallet_address": "0x742d35Cc..."
  }
}
```

### Credential Data
Store structured credential information:
```json
{
  "payload": {
    "credential_type": "EmailVerification",
    "subject": "user@example.com",
    "issuer": "0x...",
    "issued_at": 1704067200
  }
}
```

## Relationship with Other Revisions

After creating an Object Revision, you typically:

1. **Sign it** - Add a Signature Revision to prove authenticity
2. **Witness it** - Add a Witness Revision for timestamped proof
3. **Update it** - Create a new Object Revision that references this one
4. **Link it** - Create a Link Revision to connect to other chains

## Implementation Notes

### Creating an Object Revision

When implementing object revision creation:

1. Validate payload against the template schema first
2. Generate a random 16-byte nonce
3. Capture the current timestamp
4. Include `previous_revision` only if not genesis
5. Serialize according to the chosen method
6. Compute the hash for verification

### Verifying an Object Revision

To verify an object revision:

1. Check all required fields are present
2. Validate field types and formats
3. Verify the referenced template exists
4. Validate payload against template schema
5. Recompute the hash and compare
6. If not genesis, verify `previous_revision` exists and is valid

## See Also

- [Template Revision](/docs/v4.0.0/schema-reference/revision/template-revision) - Defines the schema for object payloads
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Sign object revisions
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Add timestamped proof
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Connect to other chains
1e:T1109,
Revisions are content-identifiable envelops in Aqua-Protocol. They are atomic and form a graph structure in a hash-tree. It represents the evolutionary, iterative, and historical essence of the atomic objects in the Aqua Protocol.


- Revision Chaining: Revisions form chains via optional previous_revision (a SHA3-256 hash), marking genesis if absent.
- Type Identification: revision_type specifies the revision's purpose either a reference to a [template](/docs/v4.0.0/schema-reference/revision/template-revision) (32-hex hash) (for [Object](/docs/v4.0.0/schema-reference/revision/object-revision) revisions) or built-in types like "[template](/docs/v4.0.0/schema-reference/revision/template-revision)", "[signature](/docs/v4.0.0/schema-reference/revision/signing-revision)", or "[link](/docs/v4.0.0/schema-reference/revision/link-revision)".
- Timing and Entropy: Includes a Unix timestamp (local_timestamp, unsigned 64-bit) and a random nonce (128-bit hex) for ordering and anti-collision.
- Versioning: version points to a protocol schema URL or a hash/custom string (up to 128 chars) for compatibility.
- Canonicalisation Method: method chooses between "scalar" (simple object hash for efficiency) or "tree" (Merkle tree for granular proofs, e.g., selective disclosure).
- Hash Type: identifier of the hashing function to generate the hash ID of the revision
- Schema Integration: Optional schema embeds a full JSON Schema (Draft 2020-12) for validating custom data in templates.


```JSON
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://aqua-protocol.org/docs/v4/metaschema",
  "title": "Aqua Protocol Metaschema",
  "description": "Schema for metadata in Aqua Protocol revisions",
  "type": "object",
  "properties": {
    "previous_revision": {
      "description": "SHA3-256 hash of the previous revision. If not present, this is a genesis revision.",
      "type": "string",
      "pattern": "^[0-9a-fA-F]{64}$"
    },
    "revision_type": {
      "description": "Non-traversable reference to a template or one of the specified types.",
      "oneOf": [
        {
          "type": "string",
          "pattern": "^[0-9a-fA-F]{32}$"
          "description": "Non-traversable reference to a template revision hash."
        },
        {
          "type": "string",
          "enum": ["template", "signature", "link"]
          "description": "Fundamental revision types within Aqua Protocol"
        }
      ]
    },
    "local_timestamp": {
      "description": "Unsigned 64-bit integer Unix timestamp.",
      "type": "integer",
      "minimum": 0,
      "maximum": 18446744073709551615
    },
    "nonce": {
      "description": "128-bit random bytes for entropy, hex-encoded.",
      "type": "string",
      "pattern": "^[0-9a-fA-F]{32}$"
    },
    "version": {
      "description": "Version identifier: either a specific URL or a SHA256 hash.",
      "oneOf": [
        {
          "type": "string",
          "const": "https://aqua-protocol.org/docs/v4/schema | FIPS_202-SHA3-256"
        },
        {
          "type": "string",
          "pattern": "^{32}"
          "maxLength": 128,
        }
      ]
    },
    "hash_type": {
      "description": "Hash function identifier: either FIPS_202-SHA3-256 or a custom hashing type.",
      "oneOf": [
        {
          "type": "string",
          "const": "FIPS_202-SHA3-256"
        },
        {
          "type": "string",
          "pattern": "^{32}"
          "maxLength": 128,
        }
      ]
    }
    "method": {
      "description": "Method type.",
      "type": "string",
      "enum": ["tree", "scalar"]
      "description": "Scalar: Is a simple hash of the stringified revision object. This is the default method for performance reasons. Tree: Creates a merkle tree of all the values. This allows a more granular verification. This is used for e.g. selective disclosure",
    }
    "schema": {
	    "description": "Schema definition found in template revisions",
	    "type": "object",
	    "$ref": "https://json-schema.org/draft/2020-12/schema"
    }
  },
  "required": ["revision_type", "local_timestamp", "nonce", "version", "hash_type", "method"],
  // This is to allow other revision types like link revision and signature revision
  // Its the responsibility of the implementation to be more or less permissive
  "additionalFields": true
}



```1f:T1109,
Revisions are content-identifiable envelops in Aqua-Protocol. They are atomic and form a graph structure in a hash-tree. It represents the evolutionary, iterative, and historical essence of the atomic objects in the Aqua Protocol.


- Revision Chaining: Revisions form chains via optional previous_revision (a SHA3-256 hash), marking genesis if absent.
- Type Identification: revision_type specifies the revision's purpose either a reference to a [template](/docs/v4.0.0/schema-reference/revision/template-revision) (32-hex hash) (for [Object](/docs/v4.0.0/schema-reference/revision/object-revision) revisions) or built-in types like "[template](/docs/v4.0.0/schema-reference/revision/template-revision)", "[signature](/docs/v4.0.0/schema-reference/revision/signing-revision)", or "[link](/docs/v4.0.0/schema-reference/revision/link-revision)".
- Timing and Entropy: Includes a Unix timestamp (local_timestamp, unsigned 64-bit) and a random nonce (128-bit hex) for ordering and anti-collision.
- Versioning: version points to a protocol schema URL or a hash/custom string (up to 128 chars) for compatibility.
- Canonicalisation Method: method chooses between "scalar" (simple object hash for efficiency) or "tree" (Merkle tree for granular proofs, e.g., selective disclosure).
- Hash Type: identifier of the hashing function to generate the hash ID of the revision
- Schema Integration: Optional schema embeds a full JSON Schema (Draft 2020-12) for validating custom data in templates.


```JSON
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://aqua-protocol.org/docs/v4/metaschema",
  "title": "Aqua Protocol Metaschema",
  "description": "Schema for metadata in Aqua Protocol revisions",
  "type": "object",
  "properties": {
    "previous_revision": {
      "description": "SHA3-256 hash of the previous revision. If not present, this is a genesis revision.",
      "type": "string",
      "pattern": "^[0-9a-fA-F]{64}$"
    },
    "revision_type": {
      "description": "Non-traversable reference to a template or one of the specified types.",
      "oneOf": [
        {
          "type": "string",
          "pattern": "^[0-9a-fA-F]{32}$"
          "description": "Non-traversable reference to a template revision hash."
        },
        {
          "type": "string",
          "enum": ["template", "signature", "link"]
          "description": "Fundamental revision types within Aqua Protocol"
        }
      ]
    },
    "local_timestamp": {
      "description": "Unsigned 64-bit integer Unix timestamp.",
      "type": "integer",
      "minimum": 0,
      "maximum": 18446744073709551615
    },
    "nonce": {
      "description": "128-bit random bytes for entropy, hex-encoded.",
      "type": "string",
      "pattern": "^[0-9a-fA-F]{32}$"
    },
    "version": {
      "description": "Version identifier: either a specific URL or a SHA256 hash.",
      "oneOf": [
        {
          "type": "string",
          "const": "https://aqua-protocol.org/docs/v4/schema | FIPS_202-SHA3-256"
        },
        {
          "type": "string",
          "pattern": "^{32}"
          "maxLength": 128,
        }
      ]
    },
    "hash_type": {
      "description": "Hash function identifier: either FIPS_202-SHA3-256 or a custom hashing type.",
      "oneOf": [
        {
          "type": "string",
          "const": "FIPS_202-SHA3-256"
        },
        {
          "type": "string",
          "pattern": "^{32}"
          "maxLength": 128,
        }
      ]
    }
    "method": {
      "description": "Method type.",
      "type": "string",
      "enum": ["tree", "scalar"]
      "description": "Scalar: Is a simple hash of the stringified revision object. This is the default method for performance reasons. Tree: Creates a merkle tree of all the values. This allows a more granular verification. This is used for e.g. selective disclosure",
    }
    "schema": {
	    "description": "Schema definition found in template revisions",
	    "type": "object",
	    "$ref": "https://json-schema.org/draft/2020-12/schema"
    }
  },
  "required": ["revision_type", "local_timestamp", "nonce", "version", "hash_type", "method"],
  // This is to allow other revision types like link revision and signature revision
  // Its the responsibility of the implementation to be more or less permissive
  "additionalFields": true
}



```20:T2ef5,
# Signature Revision

A Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.

## Overview

Signature revisions provide:
- **Authentication**: Proof that a specific entity created or approved the previous revision
- **Integrity**: Assurance that the signed revision hasn't been tampered with
- **Non-repudiation**: The signer cannot deny having signed the revision
- **Flexibility**: Support for multiple cryptographic signature schemes

## Schema Structure

### Common Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the revision being signed |
| `revision_type` | string | Yes | Always `"signature"` for signature revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `signature` | object | Yes | Signature value object (varies by signature type) |

### Signature Value Object

The `signature` field is an object with different structures depending on the signature type.

## Signature Types

### 1. RSA Signature

Uses RSA public-key cryptography with PKCS#1 v1.5 padding.

#### Structure
```json
{
  "signature_type": "rsa",
  "signature": "0x...",
  "public_key": "0x..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"rsa"` |
| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |
| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |

#### Validation Rules
- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)
- Public key must be DER-encoded and between 200-600 bytes
- Both fields must be lowercase hex strings prefixed with `0x`

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "rsa",
    "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d",
    "public_key": "0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001"
  }
}
```

---

### 2. Ethereum (EIP-191) Signature

Uses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.

#### Structure
```json
{
  "signature_type": "ethereum:eip-191",
  "signature": "0x...",
  "signature_wallet_address": "0x..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"ethereum:eip-191"` |
| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |
| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |

#### Validation Rules
- Signature must be exactly 65 bytes
- Wallet address must be a valid EIP-55 checksummed address
- Both fields must be hex strings prefixed with `0x`
- Address checksum must be validated

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "ethereum:eip-191",
    "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c",
    "signature_wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
  }
}
```

**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).

---

### 3. DID JWS Signature

Uses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).

#### Structure
```json
{
  "signature_type": "did:jws",
  "jws": "eyJ...",
  "did": "did:key:..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"did:jws"` |
| `jws` | string | Compact JWS (JSON Web Signature) |
| `did` | string | Decentralized Identifier of the signer |

#### Validation Rules
- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)
- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)
- The DID document must be resolvable to verify the signature

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "did:jws",
    "jws": "eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ",
    "did": "did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK"
  }
}
```

---

## What Gets Signed

The signature is computed over the **hash of the previous revision**, not the revision itself.

### Signing Process

1. Compute the hash of the `previous_revision`
2. For Ethereum: Add EIP-191 prefix (`\x19Ethereum Signed Message:\n32`)
3. Sign the hash using the appropriate method
4. Create the signature revision with the signature value
5. Compute the hash of the signature revision

### Example Signing Flow

```
Object Revision => Compute Hash => Sign Hash => Signature Revision
     |
0x3f8a7b2c... (previous_revision in signature)
```

## Validation Rules

A Signature Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"signature"`
3. **Previous Revision**: References a valid existing revision
4. **Signature Type**: One of `"rsa"`, `"ethereum:eip-191"`, or `"did:jws"`
5. **Signature Format**: Matches the requirements for the specific signature type
6. **No Unknown Fields**: The signature object contains only recognized fields
7. **Signature Verification**: The signature can be cryptographically verified
   - For RSA: Verify using the provided public key
   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`
   - For DID:JWS: Resolve DID and verify JWS signature

## Multiple Signatures

To add multiple signatures to the same revision:

```
Object Revision
    |
Signature 1 (Alice signs object)
    |
Signature 2 (Bob signs Signature 1)
    |
Signature 3 (Carol signs Signature 2)
```

Each signature revision signs the previous revision, creating a chain of signatures.

### Multi-Party Signing

For independent multi-party signing (all signing the same object):

```
        Object Revision
      |        |            |
Signature A  Signature B  Signature C
         |    |    |
        Link Revision
```

Use a Link Revision to combine multiple independent signature branches.

## Common Use Cases

### 1. Document Signing
Sign file object revisions to prove authorship:
```
File Object => Signature (Author) => Witness (Timestamp)
```

### 2. Approval Workflows
Multiple parties sign in sequence:
```
Document => Sign (Creator) => Sign (Reviewer) => Sign (Approver)
```

### 3. Notarization
Professional notary signs an object:
```
Object => Signature (Notary's RSA key) => Witness (Blockchain)
```

### 4. Smart Contract Interaction
Ethereum wallet signs for on-chain verification:
```
Claim => Signature (EIP-191) => Submit to Smart Contract
```

### 5. Decentralized Identity
DID-based signatures for verifiable credentials:
```
Credential => Signature (Issuer's DID) => Holder stores
```

## Implementation Notes

### Creating a Signature Revision

1. Identify the revision to sign
2. Compute its hash (the `previous_revision` value)
3. Prepare the message to sign (hash, with any required prefixes)
4. Generate the signature using chosen method
5. Construct the signature revision object
6. Validate the signature can be verified
7. Compute and store the signature revision hash

### Verifying a Signature Revision

#### RSA Verification
```
1. Extract public_key from signature object
2. Extract signature bytes
3. Reconstruct signed message (hash of previous_revision)
4. Verify signature using RSA public key
```

#### EIP-191 Verification
```
1. Reconstruct EIP-191 message: "\x19Ethereum Signed Message:\n32" + hash
2. Recover address from signature
3. Compare recovered address to signature_wallet_address
```

#### DID:JWS Verification
```
1. Resolve DID to get DID document
2. Extract verification method (public key)
3. Verify JWS signature using verification method
4. Validate JWS payload matches revision data
```

## Security Considerations

### 1. Key Management
- RSA: Protect private key files, use strong key sizes (e2048 bits)
- EIP-191: Secure wallet seed phrases/private keys
- DID: Maintain DID document security and key rotation policies

### 2. Signature Reuse
- Each signature should sign a unique revision
- Nonces prevent replay attacks

### 3. Timestamp Validation
- Check `local_timestamp` is reasonable (not far future/past)
- Compare with witness timestamps for consistency

### 4. Address Validation
- For EIP-191: Always validate EIP-55 checksum
- Reject non-checksummed addresses

### 5. DID Resolution
- Ensure DID resolver is trustworthy
- Cache DID documents appropriately
- Handle resolution failures gracefully

## Relationship with Other Revisions

- **Object Revisions**: Typically what gets signed first
- **Witness Revisions**: Often follow signatures to add timestamping
- **Link Revisions**: Can combine multiple signature branches
- **Template Revisions**: Can also be signed, though less common

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - What typically gets signed
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Add timestamps after signing
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Combine signature branches
- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard
- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers
- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures
21:T2ef5,
# Signature Revision

A Signature Revision adds cryptographic proof of authenticity and authorship to a revision chain. It references a previous revision and includes a digital signature that can be verified using the associated public key or address. Aqua Protocol v4 supports three signature types: RSA, Ethereum (EIP-191), and DID-based signatures.

## Overview

Signature revisions provide:
- **Authentication**: Proof that a specific entity created or approved the previous revision
- **Integrity**: Assurance that the signed revision hasn't been tampered with
- **Non-repudiation**: The signer cannot deny having signed the revision
- **Flexibility**: Support for multiple cryptographic signature schemes

## Schema Structure

### Common Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the revision being signed |
| `revision_type` | string | Yes | Always `"signature"` for signature revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the signature was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `signature` | object | Yes | Signature value object (varies by signature type) |

### Signature Value Object

The `signature` field is an object with different structures depending on the signature type.

## Signature Types

### 1. RSA Signature

Uses RSA public-key cryptography with PKCS#1 v1.5 padding.

#### Structure
```json
{
  "signature_type": "rsa",
  "signature": "0x...",
  "public_key": "0x..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"rsa"` |
| `signature` | string | Hex-encoded RSA signature (256 bytes for RSA-2048, 512 bytes for RSA-4096) |
| `public_key` | string | Hex-encoded DER-encoded RSA public key (200-600 bytes) |

#### Validation Rules
- Signature must be 256 bytes (RSA-2048) or 512 bytes (RSA-4096)
- Public key must be DER-encoded and between 200-600 bytes
- Both fields must be lowercase hex strings prefixed with `0x`

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "rsa",
    "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d",
    "public_key": "0x308201a2300d06092a864886f70d01010105000382018f003082018a0282018100c9c4d8e3f7a1b5c9d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e0f4a8b2c6d0e4f8a2b6c0d4e8f2a6b0c4d8e2f6a0b4c8d2e6f0a4b8c2d6e00203010001"
  }
}
```

---

### 2. Ethereum (EIP-191) Signature

Uses Ethereum's personal sign method (EIP-191) with ECDSA on the secp256k1 curve.

#### Structure
```json
{
  "signature_type": "ethereum:eip-191",
  "signature": "0x...",
  "signature_wallet_address": "0x..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"ethereum:eip-191"` |
| `signature` | string | Hex-encoded ECDSA signature (65 bytes: r=32, s=32, v=1) |
| `signature_wallet_address` | string | EIP-55 checksummed Ethereum address (20 bytes) |

#### Validation Rules
- Signature must be exactly 65 bytes
- Wallet address must be a valid EIP-55 checksummed address
- Both fields must be hex strings prefixed with `0x`
- Address checksum must be validated

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "ethereum:eip-191",
    "signature": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d1c",
    "signature_wallet_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8"
  }
}
```

**Note**: The `signature_wallet_address` must use proper EIP-55 checksumming (mixed case).

---

### 3. DID JWS Signature

Uses Decentralized Identifiers (DIDs) with JSON Web Signatures (JWS).

#### Structure
```json
{
  "signature_type": "did:jws",
  "jws": "eyJ...",
  "did": "did:key:..."
}
```

#### Fields

| Field | Type | Description |
|-------|------|-------------|
| `signature_type` | string | Must be `"did:jws"` |
| `jws` | string | Compact JWS (JSON Web Signature) |
| `did` | string | Decentralized Identifier of the signer |

#### Validation Rules
- JWS must be in compact serialization format (three base64url-encoded parts separated by dots)
- DID must be a valid DID string (e.g., `did:key:z6Mk...`, `did:web:example.com`)
- The DID document must be resolvable to verify the signature

#### Example
```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "signature",
  "nonce": "0x5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a",
  "local_timestamp": 1704074400,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "signature": {
    "signature_type": "did:jws",
    "jws": "eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kKvXJ_qjJRtGQFLpRvQlCdXMFD8sSE4DTlbMmLqg0BJ9FQKLHvX7y_z5Pr8u0xT8D2vCj9qL1KzN4rP2MzKfBQ",
    "did": "did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK"
  }
}
```

---

## What Gets Signed

The signature is computed over the **hash of the previous revision**, not the revision itself.

### Signing Process

1. Compute the hash of the `previous_revision`
2. For Ethereum: Add EIP-191 prefix (`\x19Ethereum Signed Message:\n32`)
3. Sign the hash using the appropriate method
4. Create the signature revision with the signature value
5. Compute the hash of the signature revision

### Example Signing Flow

```
Object Revision => Compute Hash => Sign Hash => Signature Revision
     |
0x3f8a7b2c... (previous_revision in signature)
```

## Validation Rules

A Signature Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"signature"`
3. **Previous Revision**: References a valid existing revision
4. **Signature Type**: One of `"rsa"`, `"ethereum:eip-191"`, or `"did:jws"`
5. **Signature Format**: Matches the requirements for the specific signature type
6. **No Unknown Fields**: The signature object contains only recognized fields
7. **Signature Verification**: The signature can be cryptographically verified
   - For RSA: Verify using the provided public key
   - For EIP-191: Recover address from signature and compare to `signature_wallet_address`
   - For DID:JWS: Resolve DID and verify JWS signature

## Multiple Signatures

To add multiple signatures to the same revision:

```
Object Revision
    |
Signature 1 (Alice signs object)
    |
Signature 2 (Bob signs Signature 1)
    |
Signature 3 (Carol signs Signature 2)
```

Each signature revision signs the previous revision, creating a chain of signatures.

### Multi-Party Signing

For independent multi-party signing (all signing the same object):

```
        Object Revision
      |        |            |
Signature A  Signature B  Signature C
         |    |    |
        Link Revision
```

Use a Link Revision to combine multiple independent signature branches.

## Common Use Cases

### 1. Document Signing
Sign file object revisions to prove authorship:
```
File Object => Signature (Author) => Witness (Timestamp)
```

### 2. Approval Workflows
Multiple parties sign in sequence:
```
Document => Sign (Creator) => Sign (Reviewer) => Sign (Approver)
```

### 3. Notarization
Professional notary signs an object:
```
Object => Signature (Notary's RSA key) => Witness (Blockchain)
```

### 4. Smart Contract Interaction
Ethereum wallet signs for on-chain verification:
```
Claim => Signature (EIP-191) => Submit to Smart Contract
```

### 5. Decentralized Identity
DID-based signatures for verifiable credentials:
```
Credential => Signature (Issuer's DID) => Holder stores
```

## Implementation Notes

### Creating a Signature Revision

1. Identify the revision to sign
2. Compute its hash (the `previous_revision` value)
3. Prepare the message to sign (hash, with any required prefixes)
4. Generate the signature using chosen method
5. Construct the signature revision object
6. Validate the signature can be verified
7. Compute and store the signature revision hash

### Verifying a Signature Revision

#### RSA Verification
```
1. Extract public_key from signature object
2. Extract signature bytes
3. Reconstruct signed message (hash of previous_revision)
4. Verify signature using RSA public key
```

#### EIP-191 Verification
```
1. Reconstruct EIP-191 message: "\x19Ethereum Signed Message:\n32" + hash
2. Recover address from signature
3. Compare recovered address to signature_wallet_address
```

#### DID:JWS Verification
```
1. Resolve DID to get DID document
2. Extract verification method (public key)
3. Verify JWS signature using verification method
4. Validate JWS payload matches revision data
```

## Security Considerations

### 1. Key Management
- RSA: Protect private key files, use strong key sizes (e2048 bits)
- EIP-191: Secure wallet seed phrases/private keys
- DID: Maintain DID document security and key rotation policies

### 2. Signature Reuse
- Each signature should sign a unique revision
- Nonces prevent replay attacks

### 3. Timestamp Validation
- Check `local_timestamp` is reasonable (not far future/past)
- Compare with witness timestamps for consistency

### 4. Address Validation
- For EIP-191: Always validate EIP-55 checksum
- Reject non-checksummed addresses

### 5. DID Resolution
- Ensure DID resolver is trustworthy
- Cache DID documents appropriately
- Handle resolution failures gracefully

## Relationship with Other Revisions

- **Object Revisions**: Typically what gets signed first
- **Witness Revisions**: Often follow signatures to add timestamping
- **Link Revisions**: Can combine multiple signature branches
- **Template Revisions**: Can also be signed, though less common

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - What typically gets signed
- [Witness Revision](/docs/v4.0.0/schema-reference/revision/witness-revision) - Add timestamps after signing
- [Link Revision](/docs/v4.0.0/schema-reference/revision/link-revision) - Combine signature branches
- [EIP-191 Specification](https://eips.ethereum.org/EIPS/eip-191) - Ethereum signing standard
- [DID Core Specification](https://www.w3.org/TR/did-core/) - Decentralized Identifiers
- [JWS Specification](https://www.rfc-editor.org/rfc/rfc7515) - JSON Web Signatures
22:T2ca2,
# Template Revision

A Template Revision defines the structure and validation rules for Object Revisions. Templates use JSON Schema to specify what data fields are required, their types, formats, and constraints. Template revisions are standalone (they don't have a `previous_revision` field) and are referenced by object revisions via their hash.

## Overview

Template revisions serve as the "type system" for Aqua Protocol. They:
- Define schemas using JSON Schema (Draft 2020-12)
- Are immutable once created (identified by their hash)
- Can be reused by multiple object revisions
- Optionally reference code implementations
- Enable validation and type safety

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revision_type` | string | Yes | Always `"template"` for template revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the template was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` (typically `"scalar"`) |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `schema` | object | Yes | JSON Schema (Draft 2020-12) that validates object payloads |
| `code_revision_ref` | string | No | Optional hash reference to code that implements this template |

### Field Details

#### revision_type
- **Value**: Always `"template"`
- **Purpose**: Identifies this as a template revision
- **Note**: Unlike object revisions, this is a string constant, not a hash reference

#### schema
- **Format**: Valid JSON Schema (Draft 2020-12 specification)
- **Purpose**: Defines validation rules for object revision payloads
- **Required fields in schema**:
  - `$schema`: Should be `"https://json-schema.org/draft/2020-12/schema"`
  - `type`: Typically `"object"`
  - `properties`: Defines the payload structure
  - `required`: Lists mandatory fields
  - `additionalProperties`: Usually `false` for strict validation

#### code_revision_ref
- **Format**: Hex string reference to another revision (optional)
- **Purpose**: Links to executable code or scripts that work with this template
- **Use case**: For templates that need associated processing logic
- **Example**: Reference to smart contract code, validation scripts, or transformation functions

## Examples

### Example 1: File Template

A template for storing file metadata:

```json
{
  "revision_type": "template",
  "nonce": "0x2ba6a8b9b987cf8c3567f72871812ae9",
  "local_timestamp": 1762266013,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "payload_type": {
        "type": "string",
        "maxLength": 128
      },
      "hash": {
        "type": "string",
        "pattern": "^0x[0-9a-f]{64,128}$"
      },
      "hash_type": {
        "description": "Hash function identifier",
        "anyOf": [
          {
            "type": "string",
            "const": "FIPS_202-SHA3-256"
          },
          {
            "type": "string",
            "minLength": 1,
            "maxLength": 128
          }
        ]
      },
      "descriptor": {
        "type": "string",
        "maxLength": 140
      }
    },
    "required": [
      "payload_type",
      "hash",
      "hash_type",
      "descriptor"
    ],
    "additionalProperties": false
  }
}
```

**Hash of this template**: `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e`

This hash is what object revisions use in their `revision_type` field to reference this template.

### Example 2: Domain Claim Template

A template for domain ownership claims:

```json
{
  "revision_type": "template",
  "nonce": "0x0da37dc1685f4d78a87c9462b0e87685",
  "local_timestamp": 1762817552,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "domain": {
        "type": "string",
        "format": "idn-hostname"
      },
      "wallet_address": {
        "type": "string",
        "pattern": "^0x[0-9a-fA-F]{40}$"
      }
    },
    "required": [
      "domain",
      "wallet_address"
    ],
    "additionalProperties": false
  }
}
```

### Example 3: Email Claim Template

A template for email verification claims:

```json
{
  "revision_type": "template",
  "nonce": "0x5c8f9a1b2d3e4f5a6b7c8d9e0f1a2b3c",
  "local_timestamp": 1762820000,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "email": {
        "type": "string",
        "format": "email"
      },
      "wallet_address": {
        "type": "string",
        "pattern": "^0x[0-9a-fA-F]{40}$"
      },
      "verified_at": {
        "type": "integer",
        "description": "Unix timestamp of verification"
      }
    },
    "required": [
      "email",
      "wallet_address"
    ],
    "additionalProperties": false
  }
}
```

### Example 4: Template with Code Reference

A template that references associated code:

```json
{
  "revision_type": "template",
  "nonce": "0x7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "local_timestamp": 1762825000,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "calculation_type": {
        "type": "string",
        "enum": ["sum", "average", "weighted"]
      },
      "values": {
        "type": "array",
        "items": {
          "type": "number"
        }
      }
    },
    "required": ["calculation_type", "values"],
    "additionalProperties": false
  },
  "code_revision_ref": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a"
}
```

## Built-in Templates

The Aqua RS SDK provides several built-in templates with pre-computed hashes:

| Template | Purpose | Hash Reference |
|----------|---------|----------------|
| File | File metadata storage | `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e` |
| Domain | Domain ownership claims | (computed at runtime) |
| Email | Email verification | (computed at runtime) |
| Name | Name claims | (computed at runtime) |
| Phone | Phone verification | (computed at runtime) |
| Attestation | General attestations | (computed at runtime) |

These templates are defined in the SDK at `src/schema/templates/` and can be used directly without creating new template revisions.

## JSON Schema Features

Template schemas support all JSON Schema Draft 2020-12 features:

### Type Validation
```json
{
  "type": "string"  // or "number", "integer", "boolean", "array", "object", "null"
}
```

### Format Validation
```json
{
  "type": "string",
  "format": "email"  // or "date", "date-time", "uri", "hostname", etc.
}
```

### Pattern Matching
```json
{
  "type": "string",
  "pattern": "^0x[0-9a-f]{40}$"
}
```

### Length Constraints
```json
{
  "type": "string",
  "minLength": 1,
  "maxLength": 100
}
```

### Numeric Constraints
```json
{
  "type": "number",
  "minimum": 0,
  "maximum": 100,
  "multipleOf": 0.01
}
```

### Array Constraints
```json
{
  "type": "array",
  "items": { "type": "string" },
  "minItems": 1,
  "maxItems": 10,
  "uniqueItems": true
}
```

### Enumerations
```json
{
  "type": "string",
  "enum": ["option1", "option2", "option3"]
}
```

### Conditional Schemas
```json
{
  "anyOf": [
    { "type": "string", "const": "FIPS_202-SHA3-256" },
    { "type": "string", "minLength": 1 }
  ]
}
```

## Validation Rules

A Template Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` field is exactly `"template"`
3. **Version**: Matches `"https://aqua-protocol.org/docs/v4/schema"`
4. **Schema**: Is a valid JSON Schema (Draft 2020-12)
5. **Schema Root**: The schema should define an object type at the root level
6. **No Previous Revision**: Templates never have a `previous_revision` field
7. **Code Reference**: If present, `code_revision_ref` must be a valid hash reference
8. **Hash Verification**: The computed hash can be verified

## Template Lifecycle

### 1. Creation
```
Create JSON Schema � Generate Template Revision � Compute Hash
```

### 2. Publication
```
Template Hash � Used by Object Revisions � Enables Validation
```

### 3. Reuse
```
Multiple Objects � Reference Same Template � Consistent Validation
```

## Best Practices

### 1. Use Descriptive Property Names
```json
{
  "properties": {
    "email_address": { "type": "string", "format": "email" },
    "verified_at_timestamp": { "type": "integer" }
  }
}
```

### 2. Always Set additionalProperties
```json
{
  "additionalProperties": false  // Strict validation
}
```

### 3. Include Descriptions
```json
{
  "properties": {
    "status": {
      "type": "string",
      "description": "Current verification status: pending, verified, or rejected"
    }
  }
}
```

### 4. Use Appropriate Constraints
```json
{
  "email": {
    "type": "string",
    "format": "email",
    "maxLength": 254  // RFC 5321 limit
  }
}
```

### 5. Plan for Forward Compatibility
- Avoid overly restrictive patterns
- Use `anyOf` for accepting multiple formats
- Consider optional fields for future extensions

## Relationship with Other Revisions

- **Object Revisions**: Reference templates via their `revision_type` field
- **Code Revisions**: Can be referenced via `code_revision_ref` (optional)
- **No Chaining**: Templates don't form chains; they're standalone definitions

## Implementation Notes

### Creating a Template

1. Design your JSON Schema based on your data requirements
2. Validate the schema itself is valid JSON Schema
3. Create the template revision structure
4. Generate a random nonce
5. Compute the template hash
6. Store the hash for use in object revisions

### Using a Template

1. Reference the template hash in the object's `revision_type`
2. Ensure payload conforms to the template schema
3. Validate payload against schema before creating object revision

### Template Validation

When validating an object against a template:

```
1. Retrieve template by hash
2. Extract JSON Schema from template
3. Validate object payload against schema
4. Check validation result
```

## Common Use Cases

### Document Templates
Define structure for document metadata, file hashes, and descriptors.

### Credential Templates
Specify required fields for verifiable credentials (email, domain, phone, etc.).

### Data Exchange Templates
Standardize data formats for interoperability between systems.

### Smart Contract Templates
Link templates to on-chain contract code for decentralized validation.

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Use templates to validate objects
- [JSON Schema Specification](https://json-schema.org/draft/2020-12/json-schema-core.html) - Full JSON Schema documentation
23:T2ca2,
# Template Revision

A Template Revision defines the structure and validation rules for Object Revisions. Templates use JSON Schema to specify what data fields are required, their types, formats, and constraints. Template revisions are standalone (they don't have a `previous_revision` field) and are referenced by object revisions via their hash.

## Overview

Template revisions serve as the "type system" for Aqua Protocol. They:
- Define schemas using JSON Schema (Draft 2020-12)
- Are immutable once created (identified by their hash)
- Can be reused by multiple object revisions
- Optionally reference code implementations
- Enable validation and type safety

## Schema Structure

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `revision_type` | string | Yes | Always `"template"` for template revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the template was created |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` or `"tree"` (typically `"scalar"`) |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `schema` | object | Yes | JSON Schema (Draft 2020-12) that validates object payloads |
| `code_revision_ref` | string | No | Optional hash reference to code that implements this template |

### Field Details

#### revision_type
- **Value**: Always `"template"`
- **Purpose**: Identifies this as a template revision
- **Note**: Unlike object revisions, this is a string constant, not a hash reference

#### schema
- **Format**: Valid JSON Schema (Draft 2020-12 specification)
- **Purpose**: Defines validation rules for object revision payloads
- **Required fields in schema**:
  - `$schema`: Should be `"https://json-schema.org/draft/2020-12/schema"`
  - `type`: Typically `"object"`
  - `properties`: Defines the payload structure
  - `required`: Lists mandatory fields
  - `additionalProperties`: Usually `false` for strict validation

#### code_revision_ref
- **Format**: Hex string reference to another revision (optional)
- **Purpose**: Links to executable code or scripts that work with this template
- **Use case**: For templates that need associated processing logic
- **Example**: Reference to smart contract code, validation scripts, or transformation functions

## Examples

### Example 1: File Template

A template for storing file metadata:

```json
{
  "revision_type": "template",
  "nonce": "0x2ba6a8b9b987cf8c3567f72871812ae9",
  "local_timestamp": 1762266013,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "payload_type": {
        "type": "string",
        "maxLength": 128
      },
      "hash": {
        "type": "string",
        "pattern": "^0x[0-9a-f]{64,128}$"
      },
      "hash_type": {
        "description": "Hash function identifier",
        "anyOf": [
          {
            "type": "string",
            "const": "FIPS_202-SHA3-256"
          },
          {
            "type": "string",
            "minLength": 1,
            "maxLength": 128
          }
        ]
      },
      "descriptor": {
        "type": "string",
        "maxLength": 140
      }
    },
    "required": [
      "payload_type",
      "hash",
      "hash_type",
      "descriptor"
    ],
    "additionalProperties": false
  }
}
```

**Hash of this template**: `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e`

This hash is what object revisions use in their `revision_type` field to reference this template.

### Example 2: Domain Claim Template

A template for domain ownership claims:

```json
{
  "revision_type": "template",
  "nonce": "0x0da37dc1685f4d78a87c9462b0e87685",
  "local_timestamp": 1762817552,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "domain": {
        "type": "string",
        "format": "idn-hostname"
      },
      "wallet_address": {
        "type": "string",
        "pattern": "^0x[0-9a-fA-F]{40}$"
      }
    },
    "required": [
      "domain",
      "wallet_address"
    ],
    "additionalProperties": false
  }
}
```

### Example 3: Email Claim Template

A template for email verification claims:

```json
{
  "revision_type": "template",
  "nonce": "0x5c8f9a1b2d3e4f5a6b7c8d9e0f1a2b3c",
  "local_timestamp": 1762820000,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "email": {
        "type": "string",
        "format": "email"
      },
      "wallet_address": {
        "type": "string",
        "pattern": "^0x[0-9a-fA-F]{40}$"
      },
      "verified_at": {
        "type": "integer",
        "description": "Unix timestamp of verification"
      }
    },
    "required": [
      "email",
      "wallet_address"
    ],
    "additionalProperties": false
  }
}
```

### Example 4: Template with Code Reference

A template that references associated code:

```json
{
  "revision_type": "template",
  "nonce": "0x7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "local_timestamp": 1762825000,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "schema": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
      "calculation_type": {
        "type": "string",
        "enum": ["sum", "average", "weighted"]
      },
      "values": {
        "type": "array",
        "items": {
          "type": "number"
        }
      }
    },
    "required": ["calculation_type", "values"],
    "additionalProperties": false
  },
  "code_revision_ref": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a"
}
```

## Built-in Templates

The Aqua RS SDK provides several built-in templates with pre-computed hashes:

| Template | Purpose | Hash Reference |
|----------|---------|----------------|
| File | File metadata storage | `0x742b74c87ccd7bfc76eaec416027a0bc039b59b9c2d452ea55a5c0e9b0e3f08e` |
| Domain | Domain ownership claims | (computed at runtime) |
| Email | Email verification | (computed at runtime) |
| Name | Name claims | (computed at runtime) |
| Phone | Phone verification | (computed at runtime) |
| Attestation | General attestations | (computed at runtime) |

These templates are defined in the SDK at `src/schema/templates/` and can be used directly without creating new template revisions.

## JSON Schema Features

Template schemas support all JSON Schema Draft 2020-12 features:

### Type Validation
```json
{
  "type": "string"  // or "number", "integer", "boolean", "array", "object", "null"
}
```

### Format Validation
```json
{
  "type": "string",
  "format": "email"  // or "date", "date-time", "uri", "hostname", etc.
}
```

### Pattern Matching
```json
{
  "type": "string",
  "pattern": "^0x[0-9a-f]{40}$"
}
```

### Length Constraints
```json
{
  "type": "string",
  "minLength": 1,
  "maxLength": 100
}
```

### Numeric Constraints
```json
{
  "type": "number",
  "minimum": 0,
  "maximum": 100,
  "multipleOf": 0.01
}
```

### Array Constraints
```json
{
  "type": "array",
  "items": { "type": "string" },
  "minItems": 1,
  "maxItems": 10,
  "uniqueItems": true
}
```

### Enumerations
```json
{
  "type": "string",
  "enum": ["option1", "option2", "option3"]
}
```

### Conditional Schemas
```json
{
  "anyOf": [
    { "type": "string", "const": "FIPS_202-SHA3-256" },
    { "type": "string", "minLength": 1 }
  ]
}
```

## Validation Rules

A Template Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` field is exactly `"template"`
3. **Version**: Matches `"https://aqua-protocol.org/docs/v4/schema"`
4. **Schema**: Is a valid JSON Schema (Draft 2020-12)
5. **Schema Root**: The schema should define an object type at the root level
6. **No Previous Revision**: Templates never have a `previous_revision` field
7. **Code Reference**: If present, `code_revision_ref` must be a valid hash reference
8. **Hash Verification**: The computed hash can be verified

## Template Lifecycle

### 1. Creation
```
Create JSON Schema � Generate Template Revision � Compute Hash
```

### 2. Publication
```
Template Hash � Used by Object Revisions � Enables Validation
```

### 3. Reuse
```
Multiple Objects � Reference Same Template � Consistent Validation
```

## Best Practices

### 1. Use Descriptive Property Names
```json
{
  "properties": {
    "email_address": { "type": "string", "format": "email" },
    "verified_at_timestamp": { "type": "integer" }
  }
}
```

### 2. Always Set additionalProperties
```json
{
  "additionalProperties": false  // Strict validation
}
```

### 3. Include Descriptions
```json
{
  "properties": {
    "status": {
      "type": "string",
      "description": "Current verification status: pending, verified, or rejected"
    }
  }
}
```

### 4. Use Appropriate Constraints
```json
{
  "email": {
    "type": "string",
    "format": "email",
    "maxLength": 254  // RFC 5321 limit
  }
}
```

### 5. Plan for Forward Compatibility
- Avoid overly restrictive patterns
- Use `anyOf` for accepting multiple formats
- Consider optional fields for future extensions

## Relationship with Other Revisions

- **Object Revisions**: Reference templates via their `revision_type` field
- **Code Revisions**: Can be referenced via `code_revision_ref` (optional)
- **No Chaining**: Templates don't form chains; they're standalone definitions

## Implementation Notes

### Creating a Template

1. Design your JSON Schema based on your data requirements
2. Validate the schema itself is valid JSON Schema
3. Create the template revision structure
4. Generate a random nonce
5. Compute the template hash
6. Store the hash for use in object revisions

### Using a Template

1. Reference the template hash in the object's `revision_type`
2. Ensure payload conforms to the template schema
3. Validate payload against schema before creating object revision

### Template Validation

When validating an object against a template:

```
1. Retrieve template by hash
2. Extract JSON Schema from template
3. Validate object payload against schema
4. Check validation result
```

## Common Use Cases

### Document Templates
Define structure for document metadata, file hashes, and descriptors.

### Credential Templates
Specify required fields for verifiable credentials (email, domain, phone, etc.).

### Data Exchange Templates
Standardize data formats for interoperability between systems.

### Smart Contract Templates
Link templates to on-chain contract code for decentralized validation.

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - Use templates to validate objects
- [JSON Schema Specification](https://json-schema.org/draft/2020-12/json-schema-core.html) - Full JSON Schema documentation
24:T3378,
# Witness Revision

A Witness Revision provides cryptographic proof that a revision existed at a specific point in time. It anchors revision hashes to external systems like blockchains (Ethereum), decentralized networks (Nostr), or Trusted Timestamping Authorities (TSA). This creates an immutable, verifiable timestamp that cannot be backdated.

## Overview

Witness revisions provide:
- **Timestamping**: Cryptographic proof of when a revision existed
- **Immutability**: Blockchain or TSA anchoring prevents backdating
- **Verifiability**: Anyone can verify the witness independently
- **Batch Efficiency**: Multiple revisions can be witnessed in a single transaction via Merkle trees
- **Decentralization**: Uses public blockchains or decentralized networks

## Schema Structure

### Common Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the revision being witnessed |
| `revision_type` | string | Yes | Always `"witness"` for witness revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the witness was created locally |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `witness` | object | Yes | Witness value object containing proof details |

### Witness Value Object

The `witness` field contains details about the witnessing transaction:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `merkle_proof` | array | Yes | Array of hex strings forming the Merkle proof path |
| `sender_account_address` | string | Yes | Address that submitted the witness transaction |
| `transaction_hash` | string | Yes | Transaction hash on the blockchain or network |
| `smart_contract_address` | string | Yes | Address of the witness contract (or endpoint URL) |
| `network` | string | Yes | Network identifier: `"mainnet"`, `"sepolia"`, `"holesky"`, `"tsa"`, or `"nostr"` |
| `merkle_root` | string | Yes | Root hash of the Merkle tree stored on-chain |
| `timestamp` | number | Yes | Unix timestamp from the blockchain/network |

## Network Types

### 1. Ethereum Networks

#### Mainnet
- **Network**: `"mainnet"`
- **Purpose**: Production witnessing on Ethereum mainnet
- **Cost**: Higher gas fees
- **Security**: Maximum security and permanence

#### Sepolia (Testnet)
- **Network**: `"sepolia"`
- **Purpose**: Testing and development
- **Cost**: Free testnet ETH
- **Security**: Testnet only, subject to resets

#### Holesky (Testnet)
- **Network**: `"holesky"`
- **Purpose**: Testing and development
- **Cost**: Free testnet ETH
- **Security**: Testnet only, newer Ethereum testnet

### 2. Trusted Timestamping Authority (TSA)

- **Network**: `"tsa"`
- **Purpose**: RFC 3161 compliant timestamping
- **Provider**: DigiCert or other TSA services
- **Verification**: Via TSA public certificates

### 3. Nostr

- **Network**: `"nostr"`
- **Purpose**: Decentralized social network timestamping
- **Verification**: Via Nostr relays and events
- **Cost**: Typically free

## Example

### Ethereum Witness (Sepolia)

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "witness",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "witness": {
    "merkle_proof": [
      "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "0x567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234"
    ],
    "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
    "transaction_hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "network": "sepolia",
    "merkle_root": "0xa3bf4f1b2b0b822cd15d6c15b0f00a089f86d081884c7d659a2feaa0c55ad015",
    "timestamp": 1704067250
  }
}
```

### Single Revision Witness

When witnessing a single revision (no batching), the Merkle proof is empty:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "witness",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "witness": {
    "merkle_proof": [],
    "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
    "transaction_hash": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d",
    "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "network": "mainnet",
    "merkle_root": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
    "timestamp": 1704070850
  }
}
```

**Note**: When `merkle_proof` is empty, `merkle_root` equals `previous_revision`.

## Merkle Tree Batching

To reduce costs, multiple revisions can be witnessed in a single transaction using Merkle trees.

### Process

1. **Collect Revisions**: Gather multiple revision hashes to witness
2. **Build Merkle Tree**: Create a Merkle tree from the revision hashes
3. **Submit Root**: Submit only the Merkle root to the blockchain
4. **Generate Proofs**: For each revision, generate its Merkle proof
5. **Create Witnesses**: Create witness revisions with proofs

### Example: Witnessing 4 Revisions

```
Revision Hashes:
- Rev1: 0xaaaa...
- Rev2: 0xbbbb...
- Rev3: 0xcccc...
- Rev4: 0xdddd...

Merkle Tree:
           Root
          /    \
       H12      H34
      /  \     /  \
    Rev1 Rev2 Rev3 Rev4

Submit to blockchain: Root hash only

Witness for Rev1:
  merkle_proof: [H12's sibling (Rev2), H12's parent's sibling (H34)]
  merkle_root: Root
```

### Proof Verification

To verify a revision was witnessed:

1. Start with revision hash
2. Apply Merkle proof hashes (sibling hashes)
3. Compute up the tree to get root
4. Verify computed root matches `merkle_root`
5. Verify `merkle_root` is on blockchain at `transaction_hash`

## Validation Rules

A Witness Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"witness"`
3. **Previous Revision**: References a valid existing revision
4. **Network**: One of the supported network values
5. **Timestamp Consistency**:
   - `witness.timestamp` should be close to `local_timestamp`
   - Both should be reasonable (not far in future)
6. **Merkle Proof**: If present, must be valid array of hex strings
7. **Transaction Verification**: The `transaction_hash` exists on the specified `network`
8. **Merkle Root Verification**: If batched, Merkle proof must lead to merkle_root
9. **On-Chain Verification**: The `merkle_root` is stored at the `smart_contract_address` in the transaction
10. **Address Format**: All addresses must be valid hex strings

## Witness Smart Contract

### Ethereum Contract Interface

The witness contract typically has a method like:

```solidity
function witness(bytes32 merkleRoot) public returns (bool)
```

### Verification Process

1. Query blockchain for transaction at `transaction_hash`
2. Verify transaction called the `smart_contract_address`
3. Extract the witnessed value (merkle_root) from transaction data
4. Verify it matches the `merkle_root` in the witness revision
5. Check transaction timestamp matches `timestamp` field

## Common Use Cases

### 1. Document Notarization

```
Document Object → Signature → Witness (Ethereum)
```

Proves the document existed and was signed at a specific time.

### 2. Batch Processing

```
100 Documents → Compute Hashes → Build Merkle Tree → Single Witness Transaction
```

Economical witnessing of many documents at once.

### 3. Legal Evidence

```
Evidence Object → Signature (Parties) → Witness (Mainnet)
```

Creates tamper-proof timestamp for legal proceedings.

### 4. Supply Chain

```
Shipment Event → Witness (Every checkpoint) → Audit Trail
```

Immutable record of supply chain events.

### 5. Credential Issuance

```
VC Issuance → Signature (Issuer) → Witness (Public verification)
```

Publicly verifiable credential issuance timestamps.

## Timestamp Interpretation

### local_timestamp
- Created by client when preparing witness revision
- Not trusted (can be manipulated)
- Used for user display and rough ordering

### witness.timestamp
- Provided by blockchain/TSA
- Trusted (immutable on-chain)
- Authoritative time proof
- Should be used for verification and legal purposes

**Best Practice**: Always use `witness.timestamp` for critical timestamp verification.

## Cost Considerations

### Ethereum

| Network | Cost | When to Use |
|---------|------|-------------|
| Mainnet | ~$5-50 per transaction | Production, legal, high-value |
| Sepolia | Free (testnet) | Development, testing |
| Holesky | Free (testnet) | Development, testing |

**Gas Optimization**: Batch multiple witnesses into one transaction using Merkle trees.

### TSA
- Typically $0.10-1.00 per timestamp
- Good for compliance requirements
- RFC 3161 standard

### Nostr
- Free (decentralized network)
- Lower trust than blockchain
- Good for social proof

## Implementation Notes

### Creating a Witness Revision

1. Identify the revision(s) to witness
2. Choose network (mainnet, sepolia, etc.)
3. If batching, build Merkle tree
4. Submit transaction to blockchain
5. Wait for transaction confirmation
6. Extract transaction details
7. Generate Merkle proofs (if batched)
8. Create witness revision(s)

### Verifying a Witness Revision

#### Single Revision (No Batching)
```
1. Verify merkle_proof is empty
2. Verify merkle_root equals previous_revision
3. Query blockchain for transaction_hash
4. Verify transaction exists and is confirmed
5. Extract witnessed value from transaction
6. Verify it matches merkle_root
7. Check transaction timestamp
```

#### Batched Revision
```
1. Verify merkle_proof is non-empty
2. Compute Merkle root using proof and previous_revision
3. Verify computed root matches merkle_root
4. Query blockchain for transaction_hash
5. Verify merkle_root is stored on-chain
6. Validate transaction timestamp
```

### Error Handling

Common issues and solutions:

| Issue | Solution |
|-------|----------|
| Transaction not found | Wait longer (may not be confirmed yet) |
| Wrong network | Check transaction on correct network |
| Merkle proof invalid | Regenerate proof from original tree |
| Timestamp mismatch | Check blockchain time vs local time |
| Gas estimation failed | Check wallet balance and gas price |

## Security Considerations

### 1. Network Selection
- Use mainnet for production/legal purposes
- Use testnets only for development
- Consider compliance requirements

### 2. Confirmation Depth
- Wait for sufficient confirmations (6+ for mainnet)
- More confirmations = higher security
- Balance security vs speed requirements

### 3. Merkle Proof Storage
- Store proofs securely
- Without proof, batched witness can't be verified
- Consider proof backup strategies

### 4. Timestamp Trust
- Trust blockchain timestamp over local_timestamp
- Account for block time variability
- Consider block reorganizations

### 5. Cost Management
- Batch witnesses to reduce costs
- Monitor gas prices
- Use appropriate network for use case

## Advanced Topics

### Multi-Network Witnessing

Witness the same revision on multiple networks for redundancy:

```
Object → Signature → Witness (Ethereum) → Witness (Nostr) → Witness (TSA)
```

Each witness provides independent proof.

### Periodic Re-Witnessing

For long-term preservation, periodically re-witness important revisions:

```
2024: Object → Witness (Mainnet)
2025: Link to Object → Witness (Mainnet)
2026: Link to 2025 → Witness (Mainnet)
```

### Cross-Chain Verification

Witness on multiple blockchains for increased trust:

```
Object → Witness (Ethereum Mainnet) → Witness (Polygon) → Witness (Arbitrum)
```

## Relationship with Other Revisions

- **Object Revisions**: Primary target for witnessing
- **Signature Revisions**: Often witnessed after signing
- **Link Revisions**: Can be witnessed to prove connection timestamp
- **Template Revisions**: Rarely witnessed (they're standalone)

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - What typically gets witnessed
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Often combined with witnessing
- [RFC 3161 - Timestamping](https://www.rfc-editor.org/rfc/rfc3161) - TSA standard
- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/) - On-chain witnessing
- [Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) - Batch witnessing structure
25:T3378,
# Witness Revision

A Witness Revision provides cryptographic proof that a revision existed at a specific point in time. It anchors revision hashes to external systems like blockchains (Ethereum), decentralized networks (Nostr), or Trusted Timestamping Authorities (TSA). This creates an immutable, verifiable timestamp that cannot be backdated.

## Overview

Witness revisions provide:
- **Timestamping**: Cryptographic proof of when a revision existed
- **Immutability**: Blockchain or TSA anchoring prevents backdating
- **Verifiability**: Anyone can verify the witness independently
- **Batch Efficiency**: Multiple revisions can be witnessed in a single transaction via Merkle trees
- **Decentralization**: Uses public blockchains or decentralized networks

## Schema Structure

### Common Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_revision` | string | Yes | Hash reference to the revision being witnessed |
| `revision_type` | string | Yes | Always `"witness"` for witness revisions |
| `nonce` | string | Yes | Random 16-byte hex string for uniqueness |
| `local_timestamp` | number | Yes | Unix timestamp when the witness was created locally |
| `version` | string | Yes | Protocol version: `"https://aqua-protocol.org/docs/v4/schema"` |
| `method` | string | Yes | Canonicalization method: `"scalar"` (typical) or `"tree"` |
| `hash_type` | string | Yes | Hash algorithm: `"FIPS_202-SHA3-256"` |
| `witness` | object | Yes | Witness value object containing proof details |

### Witness Value Object

The `witness` field contains details about the witnessing transaction:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `merkle_proof` | array | Yes | Array of hex strings forming the Merkle proof path |
| `sender_account_address` | string | Yes | Address that submitted the witness transaction |
| `transaction_hash` | string | Yes | Transaction hash on the blockchain or network |
| `smart_contract_address` | string | Yes | Address of the witness contract (or endpoint URL) |
| `network` | string | Yes | Network identifier: `"mainnet"`, `"sepolia"`, `"holesky"`, `"tsa"`, or `"nostr"` |
| `merkle_root` | string | Yes | Root hash of the Merkle tree stored on-chain |
| `timestamp` | number | Yes | Unix timestamp from the blockchain/network |

## Network Types

### 1. Ethereum Networks

#### Mainnet
- **Network**: `"mainnet"`
- **Purpose**: Production witnessing on Ethereum mainnet
- **Cost**: Higher gas fees
- **Security**: Maximum security and permanence

#### Sepolia (Testnet)
- **Network**: `"sepolia"`
- **Purpose**: Testing and development
- **Cost**: Free testnet ETH
- **Security**: Testnet only, subject to resets

#### Holesky (Testnet)
- **Network**: `"holesky"`
- **Purpose**: Testing and development
- **Cost**: Free testnet ETH
- **Security**: Testnet only, newer Ethereum testnet

### 2. Trusted Timestamping Authority (TSA)

- **Network**: `"tsa"`
- **Purpose**: RFC 3161 compliant timestamping
- **Provider**: DigiCert or other TSA services
- **Verification**: Via TSA public certificates

### 3. Nostr

- **Network**: `"nostr"`
- **Purpose**: Decentralized social network timestamping
- **Verification**: Via Nostr relays and events
- **Cost**: Typically free

## Example

### Ethereum Witness (Sepolia)

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "witness",
  "nonce": "0x7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "local_timestamp": 1704067200,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "witness": {
    "merkle_proof": [
      "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "0x567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234"
    ],
    "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
    "transaction_hash": "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "network": "sepolia",
    "merkle_root": "0xa3bf4f1b2b0b822cd15d6c15b0f00a089f86d081884c7d659a2feaa0c55ad015",
    "timestamp": 1704067250
  }
}
```

### Single Revision Witness

When witnessing a single revision (no batching), the Merkle proof is empty:

```json
{
  "previous_revision": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
  "revision_type": "witness",
  "nonce": "0x9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
  "local_timestamp": 1704070800,
  "version": "https://aqua-protocol.org/docs/v4/schema",
  "method": "scalar",
  "hash_type": "FIPS_202-SHA3-256",
  "witness": {
    "merkle_proof": [],
    "sender_account_address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb8",
    "transaction_hash": "0x8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d",
    "smart_contract_address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "network": "mainnet",
    "merkle_root": "0x3f8a7b2c9d1e4f5a6b8c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a",
    "timestamp": 1704070850
  }
}
```

**Note**: When `merkle_proof` is empty, `merkle_root` equals `previous_revision`.

## Merkle Tree Batching

To reduce costs, multiple revisions can be witnessed in a single transaction using Merkle trees.

### Process

1. **Collect Revisions**: Gather multiple revision hashes to witness
2. **Build Merkle Tree**: Create a Merkle tree from the revision hashes
3. **Submit Root**: Submit only the Merkle root to the blockchain
4. **Generate Proofs**: For each revision, generate its Merkle proof
5. **Create Witnesses**: Create witness revisions with proofs

### Example: Witnessing 4 Revisions

```
Revision Hashes:
- Rev1: 0xaaaa...
- Rev2: 0xbbbb...
- Rev3: 0xcccc...
- Rev4: 0xdddd...

Merkle Tree:
           Root
          /    \
       H12      H34
      /  \     /  \
    Rev1 Rev2 Rev3 Rev4

Submit to blockchain: Root hash only

Witness for Rev1:
  merkle_proof: [H12's sibling (Rev2), H12's parent's sibling (H34)]
  merkle_root: Root
```

### Proof Verification

To verify a revision was witnessed:

1. Start with revision hash
2. Apply Merkle proof hashes (sibling hashes)
3. Compute up the tree to get root
4. Verify computed root matches `merkle_root`
5. Verify `merkle_root` is on blockchain at `transaction_hash`

## Validation Rules

A Witness Revision is valid if:

1. **Structure**: Contains all required fields with correct types
2. **Revision Type**: The `revision_type` is exactly `"witness"`
3. **Previous Revision**: References a valid existing revision
4. **Network**: One of the supported network values
5. **Timestamp Consistency**:
   - `witness.timestamp` should be close to `local_timestamp`
   - Both should be reasonable (not far in future)
6. **Merkle Proof**: If present, must be valid array of hex strings
7. **Transaction Verification**: The `transaction_hash` exists on the specified `network`
8. **Merkle Root Verification**: If batched, Merkle proof must lead to merkle_root
9. **On-Chain Verification**: The `merkle_root` is stored at the `smart_contract_address` in the transaction
10. **Address Format**: All addresses must be valid hex strings

## Witness Smart Contract

### Ethereum Contract Interface

The witness contract typically has a method like:

```solidity
function witness(bytes32 merkleRoot) public returns (bool)
```

### Verification Process

1. Query blockchain for transaction at `transaction_hash`
2. Verify transaction called the `smart_contract_address`
3. Extract the witnessed value (merkle_root) from transaction data
4. Verify it matches the `merkle_root` in the witness revision
5. Check transaction timestamp matches `timestamp` field

## Common Use Cases

### 1. Document Notarization

```
Document Object → Signature → Witness (Ethereum)
```

Proves the document existed and was signed at a specific time.

### 2. Batch Processing

```
100 Documents → Compute Hashes → Build Merkle Tree → Single Witness Transaction
```

Economical witnessing of many documents at once.

### 3. Legal Evidence

```
Evidence Object → Signature (Parties) → Witness (Mainnet)
```

Creates tamper-proof timestamp for legal proceedings.

### 4. Supply Chain

```
Shipment Event → Witness (Every checkpoint) → Audit Trail
```

Immutable record of supply chain events.

### 5. Credential Issuance

```
VC Issuance → Signature (Issuer) → Witness (Public verification)
```

Publicly verifiable credential issuance timestamps.

## Timestamp Interpretation

### local_timestamp
- Created by client when preparing witness revision
- Not trusted (can be manipulated)
- Used for user display and rough ordering

### witness.timestamp
- Provided by blockchain/TSA
- Trusted (immutable on-chain)
- Authoritative time proof
- Should be used for verification and legal purposes

**Best Practice**: Always use `witness.timestamp` for critical timestamp verification.

## Cost Considerations

### Ethereum

| Network | Cost | When to Use |
|---------|------|-------------|
| Mainnet | ~$5-50 per transaction | Production, legal, high-value |
| Sepolia | Free (testnet) | Development, testing |
| Holesky | Free (testnet) | Development, testing |

**Gas Optimization**: Batch multiple witnesses into one transaction using Merkle trees.

### TSA
- Typically $0.10-1.00 per timestamp
- Good for compliance requirements
- RFC 3161 standard

### Nostr
- Free (decentralized network)
- Lower trust than blockchain
- Good for social proof

## Implementation Notes

### Creating a Witness Revision

1. Identify the revision(s) to witness
2. Choose network (mainnet, sepolia, etc.)
3. If batching, build Merkle tree
4. Submit transaction to blockchain
5. Wait for transaction confirmation
6. Extract transaction details
7. Generate Merkle proofs (if batched)
8. Create witness revision(s)

### Verifying a Witness Revision

#### Single Revision (No Batching)
```
1. Verify merkle_proof is empty
2. Verify merkle_root equals previous_revision
3. Query blockchain for transaction_hash
4. Verify transaction exists and is confirmed
5. Extract witnessed value from transaction
6. Verify it matches merkle_root
7. Check transaction timestamp
```

#### Batched Revision
```
1. Verify merkle_proof is non-empty
2. Compute Merkle root using proof and previous_revision
3. Verify computed root matches merkle_root
4. Query blockchain for transaction_hash
5. Verify merkle_root is stored on-chain
6. Validate transaction timestamp
```

### Error Handling

Common issues and solutions:

| Issue | Solution |
|-------|----------|
| Transaction not found | Wait longer (may not be confirmed yet) |
| Wrong network | Check transaction on correct network |
| Merkle proof invalid | Regenerate proof from original tree |
| Timestamp mismatch | Check blockchain time vs local time |
| Gas estimation failed | Check wallet balance and gas price |

## Security Considerations

### 1. Network Selection
- Use mainnet for production/legal purposes
- Use testnets only for development
- Consider compliance requirements

### 2. Confirmation Depth
- Wait for sufficient confirmations (6+ for mainnet)
- More confirmations = higher security
- Balance security vs speed requirements

### 3. Merkle Proof Storage
- Store proofs securely
- Without proof, batched witness can't be verified
- Consider proof backup strategies

### 4. Timestamp Trust
- Trust blockchain timestamp over local_timestamp
- Account for block time variability
- Consider block reorganizations

### 5. Cost Management
- Batch witnesses to reduce costs
- Monitor gas prices
- Use appropriate network for use case

## Advanced Topics

### Multi-Network Witnessing

Witness the same revision on multiple networks for redundancy:

```
Object → Signature → Witness (Ethereum) → Witness (Nostr) → Witness (TSA)
```

Each witness provides independent proof.

### Periodic Re-Witnessing

For long-term preservation, periodically re-witness important revisions:

```
2024: Object → Witness (Mainnet)
2025: Link to Object → Witness (Mainnet)
2026: Link to 2025 → Witness (Mainnet)
```

### Cross-Chain Verification

Witness on multiple blockchains for increased trust:

```
Object → Witness (Ethereum Mainnet) → Witness (Polygon) → Witness (Arbitrum)
```

## Relationship with Other Revisions

- **Object Revisions**: Primary target for witnessing
- **Signature Revisions**: Often witnessed after signing
- **Link Revisions**: Can be witnessed to prove connection timestamp
- **Template Revisions**: Rarely witnessed (they're standalone)

## See Also

- [Object Revision](/docs/v4.0.0/schema-reference/revision/object-revision) - What typically gets witnessed
- [Signature Revision](/docs/v4.0.0/schema-reference/revision/signing-revision) - Often combined with witnessing
- [RFC 3161 - Timestamping](https://www.rfc-editor.org/rfc/rfc3161) - TSA standard
- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/) - On-chain witnessing
- [Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) - Batch witnessing structure
26:T365a,
## Core Capabilities

### Tamper-Proof Verification
Once a document is notarized in the Aqua Protocol, any modification becomes immediately detectable. The cryptographic hash of the document content is stored in the revision chain, making it mathematically impossible to alter without detection.

### Timestamp Authentication
Every document revision receives a blockchain-anchored timestamp, providing cryptographic proof of when the document was created or modified. This eliminates disputes about document timelines.

### Permanent Audit Trails
All document revisions, signatures, and witnesses are permanently recorded in an immutable chain. This creates a complete history of the document lifecycle that can be independently verified.

### Decentralized Validation
Verification happens cryptographically without requiring trust in intermediaries. Anyone with the document and its Aqua chain can independently verify authenticity and integrity.

## Use Cases by Industry

### Legal Documents

**Contract Authenticity**
- Prove when contracts were signed
- Verify that contract terms haven't been altered
- Establish non-repudiation through digital signatures
- Maintain chain of custody for legal proceedings

**Evidence Preservation**
- Create tamper-proof records of digital evidence
- Timestamp evidence collection
- Maintain audit trails for admissibility
- Prove evidence integrity in court

**Notary Services**
- Provide remote notarization with cryptographic proof
- Replace traditional notary stamps with blockchain anchoring
- Enable verifiable notarization across jurisdictions
- Reduce costs while increasing security

**Legal Compliance**
- Demonstrate compliance with document retention policies
- Prove regulatory filings were submitted on time
- Maintain auditable records for investigations
- Satisfy e-discovery requirements

### Business Applications

**Invoice Verification**
- Authenticate invoices to prevent fraud
- Track invoice approvals and modifications
- Provide proof of invoice delivery and receipt
- Enable automated payment processing with verified invoices

**Purchase Orders**
- Verify PO authenticity between trading partners
- Track PO modifications and approvals
- Prevent unauthorized changes
- Create audit trails for procurement compliance

**Financial Records**
- Ensure integrity of financial statements
- Track modifications to accounting records
- Satisfy auditor requirements for record verification
- Maintain SOX compliance with immutable audit logs

**Regulatory Reporting**
- Prove timely submission of regulatory reports
- Demonstrate report integrity over time
- Satisfy audit requirements
- Reduce compliance costs

### Educational Credentials

**Diploma Authentication**
- Provide instant verification of degree authenticity
- Eliminate diploma mills and fraudulent credentials
- Enable employers to verify qualifications
- Reduce verification costs and time

**Transcript Integrity**
- Prevent transcript tampering
- Allow secure sharing with third parties
- Maintain permanent academic records
- Enable credential portability across institutions

**Certificate Validation**
- Verify professional certifications
- Track certificate expiration dates
- Enable certificate revocation when needed
- Support continuing education tracking

**Academic Records**
- Create verifiable lifetime learning records
- Enable secure transcript sharing
- Support credential stacking and micro-credentials
- Facilitate credit transfers between institutions

### Government Documents

**Identity Documents**
- Authenticate passports and ID cards
- Enable remote identity verification
- Prevent identity fraud
- Support digital identity systems

**License Verification**
- Verify professional licenses instantly
- Track license renewals and expirations
- Enable license portability across jurisdictions
- Support automated compliance checking

**Permits and Certifications**
- Authenticate building permits
- Verify safety certifications
- Track permit modifications
- Enable instant permit validation by inspectors

**Official Records**
- Ensure integrity of government records
- Enable citizen verification of official documents
- Maintain transparent government operations
- Prevent records tampering

## Key Benefits

### Eliminate Single Points of Failure
Traditional document verification systems rely on centralized databases that can fail, be hacked, or become unavailable. Aqua Protocol's decentralized approach distributes verification capability, ensuring documents can always be verified even if specific systems are offline.

### Maintain Document Provenance
Every document modification is recorded with cryptographic proof of who made the change, when it occurred, and what was changed. This complete provenance trail answers questions about document history definitively.

### Cryptographic Verification
Verification relies on mathematical certainty rather than trust. Hashes, signatures, and blockchain anchors provide proof that can't be forged, even by system administrators.

### No Trusted Intermediaries Required
Unlike traditional notary or verification services, Aqua Protocol enables anyone to verify document authenticity independently. This reduces costs and increases accessibility.

### Regulatory Compliance
Industries requiring regulatory compliance benefit from maintained audit trails:
- **Legal firms**: Demonstrate evidence integrity and chain of custody
- **Financial institutions**: Satisfy SOX, GDPR, and financial regulations
- **Healthcare providers**: Maintain HIPAA-compliant document trails
- **Educational institutions**: Provide verifiable credentials that meet accreditation standards

### Cost Reduction
Automated verification reduces manual processes, eliminates middlemen, speeds up verification times, and prevents fraud losses.

## How It Works

### 1. Document Notarization
When a document is first notarized:
- The document content is hashed using SHA3-256
- A genesis revision is created with the document hash
- The revision is signed by the document creator
- The signature is witnessed on a blockchain
- All data is stored in an immutable Aqua chain

### 2. Document Updates
When a document is modified:
- A new revision is created referencing the previous revision
- The new content hash is recorded
- The update is signed by authorized parties
- The signature is witnessed for timestamp proof
- The revision chain grows, maintaining complete history

### 3. Multi-Party Signing
For documents requiring multiple signatures:
- Each party adds their signature as a new revision
- Signatures reference the document revision being signed
- Order of signing is preserved in the chain
- All signatures receive blockchain timestamps
- Final witness anchors the complete signing process

### 4. Verification
Anyone can verify a document by:
- Computing the hash of the document content
- Comparing it to the hash in the revision chain
- Verifying all signatures cryptographically
- Checking blockchain witness timestamps
- Validating the entire revision chain integrity

## Real-World Scenarios

### Scenario 1: Legal Contract Management

**Challenge**: A law firm needs to manage contracts with guaranteed integrity and provable signing timestamps for multiple parties.

**Solution**:
- Contract is notarized when drafted, creating the genesis revision
- Each party reviews and signs, adding signature revisions
- Final contract is witnessed on Ethereum mainnet
- All parties receive the complete Aqua chain
- Years later, if disputed, the contract's integrity and signing timeline can be cryptographically proven

**Benefits**: Non-repudiation, tamper-proof records, defensible timestamps, reduced notary costs

### Scenario 2: Academic Credential Verification

**Challenge**: Universities issue thousands of diplomas, and employers need to verify credentials quickly without calling the registrar.

**Solution**:
- University notarizes each diploma as it's issued
- Diploma includes an Aqua chain with the university's signature
- University witnesses the batch of diplomas on blockchain
- Employers scan QR code or receive Aqua chain from candidate
- Verification happens instantly using Aqua verification tools

**Benefits**: Instant verification, eliminated fraud, reduced administrative burden, improved candidate experience

### Scenario 3: Financial Audit Trail

**Challenge**: A public company must maintain auditable financial records that prove compliance with regulations.

**Solution**:
- Financial statements are notarized each quarter
- CFO signs the statement, adding signature revision
- External auditor witnesses the statement on blockchain
- Audit trail is preserved permanently
- Regulators can verify statement integrity independently

**Benefits**: Regulatory compliance, reduced audit costs, defensible records, fraud prevention

### Scenario 4: Government Permit Issuance

**Challenge**: Building department issues permits that need to be verified by inspectors, contractors, and the public.

**Solution**:
- Permit applications are notarized when submitted
- Permit approvals are signed by authorized officials
- Approved permits are witnessed on blockchain
- QR codes on physical permits link to Aqua chains
- Anyone can verify permit authenticity and status

**Benefits**: Fraud prevention, instant verification, public transparency, reduced administrative overhead

## Integration Patterns

### Document Management Systems
Integrate Aqua Protocol into existing DMS platforms to automatically notarize important documents. When documents are finalized, trigger Aqua notarization via SDK.

### E-Signature Platforms
Enhance e-signature solutions with blockchain-anchored timestamps and cryptographic verification. Each signature becomes a verifiable revision in the Aqua chain.

### CRM and Business Systems
Add document verification to CRM, ERP, or custom business applications. Automatically notarize quotes, proposals, contracts, and invoices as they're generated.

### Educational Systems
Integrate with student information systems to automatically notarize transcripts, diplomas, and certificates as they're issued.

### Government Systems
Add Aqua Protocol to permit, license, and registration systems to provide instant verification capability to citizens and businesses.

## Best Practices

### Initial Notarization
- Notarize documents as early as possible in their lifecycle
- Include relevant metadata (document type, parties, purpose)
- Use appropriate method (scalar for small docs, tree for large)
- Sign immediately after creation to establish authorship

### Multi-Party Documents
- Establish signing order and communicate to all parties
- Each party should verify previous signatures before adding theirs
- Witness after all signatures are collected
- Distribute complete Aqua chain to all parties

### Long-Term Storage
- Store Aqua chains separately from documents
- Back up chains to multiple locations
- Include Aqua chain with document when transmitting
- Test verification periodically

### Verification
- Always verify documents received from third parties
- Check entire revision chain, not just the latest revision
- Verify blockchain witnesses for important documents
- Validate signatures match expected signers

### Privacy Considerations
- Aqua chains don't contain document content by default
- Share chains carefully as they prove document existence
- Use private blockchains if public witnessing is problematic
- Consider what metadata is included in revisions

## Technical Advantages

### Cryptographic Security
- SHA3-256 hashing provides computational infeasibility of collision attacks
- ECDSA signatures (65 bytes) provide 128-bit security level
- Blockchain anchoring makes backdating mathematically impossible

### Scalability
- Document verification is O(n) where n is number of revisions
- Merkle tree mode enables selective disclosure of large documents
- Batch witnessing reduces blockchain transaction costs
- Verification can happen offline after initial chain retrieval

### Interoperability
- JSON-based format enables easy integration
- Multiple SDK options (Rust, JavaScript/TypeScript)
- Platform-agnostic verification
- Standard cryptographic primitives

### Future-Proof
- Protocol versioning supports evolution
- Blockchain-agnostic witness mechanism
- Multiple signature algorithm support
- Extensible revision types

## Common Questions

**Q: What if the blockchain network goes offline?**
A: Verification of existing documents still works using cryptographic verification of signatures and hashes. Only new witnessing requires blockchain access. Historical witnesses remain provable through transaction records.

**Q: How long are documents stored?**
A: Aqua Protocol stores only hashes and metadata, not document content. Document storage is separate and managed by users. Aqua chains are small (kilobytes) and can be stored indefinitely.

**Q: Can witnesses be trusted?**
A: Blockchain witnesses provide cryptographic proof of timestamp. As long as the blockchain network is secure and decentralized, witnesses cannot be backdated or falsified.

**Q: What about privacy?**
A: By default, only document hashes are stored on-chain, not content. The document itself remains private. Share Aqua chains carefully as they prove document existence at specific times.

**Q: How do I revoke a document?**
A: Add a revocation revision to the chain. The document history remains (for audit purposes), but new revisions can indicate revoked status.

## See Also

- [Supply Chain Tracking](/docs/v4.0.0/use-cases/supply-chain) - Apply similar verification to supply chain events
- [Identity Attestation](/docs/v4.0.0/use-cases/identity-attestation) - Verify identity credentials
- [Quick Start](/docs/v4.0.0/quickstart) - Get started with document verification
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction) - Technical specifications
27:T365a,
## Core Capabilities

### Tamper-Proof Verification
Once a document is notarized in the Aqua Protocol, any modification becomes immediately detectable. The cryptographic hash of the document content is stored in the revision chain, making it mathematically impossible to alter without detection.

### Timestamp Authentication
Every document revision receives a blockchain-anchored timestamp, providing cryptographic proof of when the document was created or modified. This eliminates disputes about document timelines.

### Permanent Audit Trails
All document revisions, signatures, and witnesses are permanently recorded in an immutable chain. This creates a complete history of the document lifecycle that can be independently verified.

### Decentralized Validation
Verification happens cryptographically without requiring trust in intermediaries. Anyone with the document and its Aqua chain can independently verify authenticity and integrity.

## Use Cases by Industry

### Legal Documents

**Contract Authenticity**
- Prove when contracts were signed
- Verify that contract terms haven't been altered
- Establish non-repudiation through digital signatures
- Maintain chain of custody for legal proceedings

**Evidence Preservation**
- Create tamper-proof records of digital evidence
- Timestamp evidence collection
- Maintain audit trails for admissibility
- Prove evidence integrity in court

**Notary Services**
- Provide remote notarization with cryptographic proof
- Replace traditional notary stamps with blockchain anchoring
- Enable verifiable notarization across jurisdictions
- Reduce costs while increasing security

**Legal Compliance**
- Demonstrate compliance with document retention policies
- Prove regulatory filings were submitted on time
- Maintain auditable records for investigations
- Satisfy e-discovery requirements

### Business Applications

**Invoice Verification**
- Authenticate invoices to prevent fraud
- Track invoice approvals and modifications
- Provide proof of invoice delivery and receipt
- Enable automated payment processing with verified invoices

**Purchase Orders**
- Verify PO authenticity between trading partners
- Track PO modifications and approvals
- Prevent unauthorized changes
- Create audit trails for procurement compliance

**Financial Records**
- Ensure integrity of financial statements
- Track modifications to accounting records
- Satisfy auditor requirements for record verification
- Maintain SOX compliance with immutable audit logs

**Regulatory Reporting**
- Prove timely submission of regulatory reports
- Demonstrate report integrity over time
- Satisfy audit requirements
- Reduce compliance costs

### Educational Credentials

**Diploma Authentication**
- Provide instant verification of degree authenticity
- Eliminate diploma mills and fraudulent credentials
- Enable employers to verify qualifications
- Reduce verification costs and time

**Transcript Integrity**
- Prevent transcript tampering
- Allow secure sharing with third parties
- Maintain permanent academic records
- Enable credential portability across institutions

**Certificate Validation**
- Verify professional certifications
- Track certificate expiration dates
- Enable certificate revocation when needed
- Support continuing education tracking

**Academic Records**
- Create verifiable lifetime learning records
- Enable secure transcript sharing
- Support credential stacking and micro-credentials
- Facilitate credit transfers between institutions

### Government Documents

**Identity Documents**
- Authenticate passports and ID cards
- Enable remote identity verification
- Prevent identity fraud
- Support digital identity systems

**License Verification**
- Verify professional licenses instantly
- Track license renewals and expirations
- Enable license portability across jurisdictions
- Support automated compliance checking

**Permits and Certifications**
- Authenticate building permits
- Verify safety certifications
- Track permit modifications
- Enable instant permit validation by inspectors

**Official Records**
- Ensure integrity of government records
- Enable citizen verification of official documents
- Maintain transparent government operations
- Prevent records tampering

## Key Benefits

### Eliminate Single Points of Failure
Traditional document verification systems rely on centralized databases that can fail, be hacked, or become unavailable. Aqua Protocol's decentralized approach distributes verification capability, ensuring documents can always be verified even if specific systems are offline.

### Maintain Document Provenance
Every document modification is recorded with cryptographic proof of who made the change, when it occurred, and what was changed. This complete provenance trail answers questions about document history definitively.

### Cryptographic Verification
Verification relies on mathematical certainty rather than trust. Hashes, signatures, and blockchain anchors provide proof that can't be forged, even by system administrators.

### No Trusted Intermediaries Required
Unlike traditional notary or verification services, Aqua Protocol enables anyone to verify document authenticity independently. This reduces costs and increases accessibility.

### Regulatory Compliance
Industries requiring regulatory compliance benefit from maintained audit trails:
- **Legal firms**: Demonstrate evidence integrity and chain of custody
- **Financial institutions**: Satisfy SOX, GDPR, and financial regulations
- **Healthcare providers**: Maintain HIPAA-compliant document trails
- **Educational institutions**: Provide verifiable credentials that meet accreditation standards

### Cost Reduction
Automated verification reduces manual processes, eliminates middlemen, speeds up verification times, and prevents fraud losses.

## How It Works

### 1. Document Notarization
When a document is first notarized:
- The document content is hashed using SHA3-256
- A genesis revision is created with the document hash
- The revision is signed by the document creator
- The signature is witnessed on a blockchain
- All data is stored in an immutable Aqua chain

### 2. Document Updates
When a document is modified:
- A new revision is created referencing the previous revision
- The new content hash is recorded
- The update is signed by authorized parties
- The signature is witnessed for timestamp proof
- The revision chain grows, maintaining complete history

### 3. Multi-Party Signing
For documents requiring multiple signatures:
- Each party adds their signature as a new revision
- Signatures reference the document revision being signed
- Order of signing is preserved in the chain
- All signatures receive blockchain timestamps
- Final witness anchors the complete signing process

### 4. Verification
Anyone can verify a document by:
- Computing the hash of the document content
- Comparing it to the hash in the revision chain
- Verifying all signatures cryptographically
- Checking blockchain witness timestamps
- Validating the entire revision chain integrity

## Real-World Scenarios

### Scenario 1: Legal Contract Management

**Challenge**: A law firm needs to manage contracts with guaranteed integrity and provable signing timestamps for multiple parties.

**Solution**:
- Contract is notarized when drafted, creating the genesis revision
- Each party reviews and signs, adding signature revisions
- Final contract is witnessed on Ethereum mainnet
- All parties receive the complete Aqua chain
- Years later, if disputed, the contract's integrity and signing timeline can be cryptographically proven

**Benefits**: Non-repudiation, tamper-proof records, defensible timestamps, reduced notary costs

### Scenario 2: Academic Credential Verification

**Challenge**: Universities issue thousands of diplomas, and employers need to verify credentials quickly without calling the registrar.

**Solution**:
- University notarizes each diploma as it's issued
- Diploma includes an Aqua chain with the university's signature
- University witnesses the batch of diplomas on blockchain
- Employers scan QR code or receive Aqua chain from candidate
- Verification happens instantly using Aqua verification tools

**Benefits**: Instant verification, eliminated fraud, reduced administrative burden, improved candidate experience

### Scenario 3: Financial Audit Trail

**Challenge**: A public company must maintain auditable financial records that prove compliance with regulations.

**Solution**:
- Financial statements are notarized each quarter
- CFO signs the statement, adding signature revision
- External auditor witnesses the statement on blockchain
- Audit trail is preserved permanently
- Regulators can verify statement integrity independently

**Benefits**: Regulatory compliance, reduced audit costs, defensible records, fraud prevention

### Scenario 4: Government Permit Issuance

**Challenge**: Building department issues permits that need to be verified by inspectors, contractors, and the public.

**Solution**:
- Permit applications are notarized when submitted
- Permit approvals are signed by authorized officials
- Approved permits are witnessed on blockchain
- QR codes on physical permits link to Aqua chains
- Anyone can verify permit authenticity and status

**Benefits**: Fraud prevention, instant verification, public transparency, reduced administrative overhead

## Integration Patterns

### Document Management Systems
Integrate Aqua Protocol into existing DMS platforms to automatically notarize important documents. When documents are finalized, trigger Aqua notarization via SDK.

### E-Signature Platforms
Enhance e-signature solutions with blockchain-anchored timestamps and cryptographic verification. Each signature becomes a verifiable revision in the Aqua chain.

### CRM and Business Systems
Add document verification to CRM, ERP, or custom business applications. Automatically notarize quotes, proposals, contracts, and invoices as they're generated.

### Educational Systems
Integrate with student information systems to automatically notarize transcripts, diplomas, and certificates as they're issued.

### Government Systems
Add Aqua Protocol to permit, license, and registration systems to provide instant verification capability to citizens and businesses.

## Best Practices

### Initial Notarization
- Notarize documents as early as possible in their lifecycle
- Include relevant metadata (document type, parties, purpose)
- Use appropriate method (scalar for small docs, tree for large)
- Sign immediately after creation to establish authorship

### Multi-Party Documents
- Establish signing order and communicate to all parties
- Each party should verify previous signatures before adding theirs
- Witness after all signatures are collected
- Distribute complete Aqua chain to all parties

### Long-Term Storage
- Store Aqua chains separately from documents
- Back up chains to multiple locations
- Include Aqua chain with document when transmitting
- Test verification periodically

### Verification
- Always verify documents received from third parties
- Check entire revision chain, not just the latest revision
- Verify blockchain witnesses for important documents
- Validate signatures match expected signers

### Privacy Considerations
- Aqua chains don't contain document content by default
- Share chains carefully as they prove document existence
- Use private blockchains if public witnessing is problematic
- Consider what metadata is included in revisions

## Technical Advantages

### Cryptographic Security
- SHA3-256 hashing provides computational infeasibility of collision attacks
- ECDSA signatures (65 bytes) provide 128-bit security level
- Blockchain anchoring makes backdating mathematically impossible

### Scalability
- Document verification is O(n) where n is number of revisions
- Merkle tree mode enables selective disclosure of large documents
- Batch witnessing reduces blockchain transaction costs
- Verification can happen offline after initial chain retrieval

### Interoperability
- JSON-based format enables easy integration
- Multiple SDK options (Rust, JavaScript/TypeScript)
- Platform-agnostic verification
- Standard cryptographic primitives

### Future-Proof
- Protocol versioning supports evolution
- Blockchain-agnostic witness mechanism
- Multiple signature algorithm support
- Extensible revision types

## Common Questions

**Q: What if the blockchain network goes offline?**
A: Verification of existing documents still works using cryptographic verification of signatures and hashes. Only new witnessing requires blockchain access. Historical witnesses remain provable through transaction records.

**Q: How long are documents stored?**
A: Aqua Protocol stores only hashes and metadata, not document content. Document storage is separate and managed by users. Aqua chains are small (kilobytes) and can be stored indefinitely.

**Q: Can witnesses be trusted?**
A: Blockchain witnesses provide cryptographic proof of timestamp. As long as the blockchain network is secure and decentralized, witnesses cannot be backdated or falsified.

**Q: What about privacy?**
A: By default, only document hashes are stored on-chain, not content. The document itself remains private. Share Aqua chains carefully as they prove document existence at specific times.

**Q: How do I revoke a document?**
A: Add a revocation revision to the chain. The document history remains (for audit purposes), but new revisions can indicate revoked status.

## See Also

- [Supply Chain Tracking](/docs/v4.0.0/use-cases/supply-chain) - Apply similar verification to supply chain events
- [Identity Attestation](/docs/v4.0.0/use-cases/identity-attestation) - Verify identity credentials
- [Quick Start](/docs/v4.0.0/quickstart) - Get started with document verification
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction) - Technical specifications
28:T17b5,
The Aqua Protocol enables a robust **Self-Sovereign Identity (SSI)** framework where individuals and organizations can issue, attest, and verify identity claims without relying on centralized identity providers. By leveraging cryptographic proofs and decentralized trust chains, Aqua allows users to own their data while enabling third parties to verify specific attributes with certainty.

## Core Capabilities

### Self-Sovereign Identity (SSI)
Users have full control over their identities. Identity claims are **self-issued** first, proving account ownership, and then enriched by **attestations** from trusted authorities. This ensures that the user is always the central point of their identity graph.

### Verifiable Attestations
Third parties (Trust Authorities) can sign attestations that validate a user's specific claims (e.g., "Over 18", "Accredited Investor", "University Graduate"). These attestations are cryptographically linked to the user's identity chain and the authority's trust chain.

### Trust Chains
Trust is transitive and transparent. A verifier doesn't just trust a claim; they verify the entire chain of authority. For example, a diploma is trusted because it's signed by a University, which is accredited by an Education Ministry, which is recognized by the Government.

### Selective Disclosure & Privacy
Users can share specific attestations (e.g., "I am over 21") without revealing their entire identity or unrelated personal data. Data Vaults protect sensitive claims, ensuring they are only decrypted for authorized verifiers.

## Use Cases by Industry

### Education & Academia

**Digital Diplomas & Transcripts**
- Universities issue tamper-proof degree certificates.
- Students can instantly prove graduation to employers.
- Prevents credential fraud and "diploma mills".
- Enables portable academic records across institutions.

**Professional Certifications**
- Licensing boards attest to professional status (e.g., Medical License, Bar Association).
- Real-time verification of valid/active status.
- Automated expiry and renewal tracking.

### Government & Legal

**Digital ID & Passports**
- Governments issue digital complements to physical IDs.
- Citizens use digital wallets to prove citizenship or residency.
- Streamlined visa and border entry processes.

**Notary & Witnessing**
- Notaries attest to the identity of a signer on a document.
- Creates a cryptographic link between the person, the document, and the notary.
- Replaces physical stamps with digital signatures.

### Financial Services

**KYC/AML Compliance**
- Banks perform "Know Your Customer" checks once and issue a reusable attestation.
- Users share this attestation with other services to onboard instantly without re-submitting documents.
- Reduces compliance costs and friction.

**Accredited Investor Status**
- Financial institutions attest that a user meets investment criteria.
- Allows participation in regulated private equity or tokens.

### Digital Services & Web3

**Sybil Resistance**
- Verify that an account belongs to a unique human without collecting personal data.
- "Proof of Humanity" or "Social Login" attestations.
- Prevents bot spam and manipulation in DAOs and communities.

**Reputation & Social Proof**
- Platforms attest to a user's reputation score or history.
- Enables portable reputation across different marketplaces and communities.

## Key Benefits

### User Privacy & Control
Users store their own data in encrypted Data Vaults. They grant access only when necessary and can revoke it at any time. No centralized "honey pot" of user data to hack.

### Fraud Reduction
Cryptographic signatures make it impossible to forge attestations. 

### Interoperability
Built on standard cryptographic primitives, allowing identity claims to be used across different platforms, wallets, and services that support the Aqua Protocol.

### Reduced Friction
"Verify once, use everywhere." Users don't need to repeatedly upload passport photos or utility bills. One verified attestation can be reused across multiple services.

## How It Works

### 1. Claim Creation (Self-Issuance)
The user creates a **Self-Issued Identity Claim**.
- Example: "I claim my name is Alice."
- This claim is signed by Alice's private key, establishing ownership of the claim.
- It serves as the "subject" for future attestations.

### 2. Attestation
A **Trust Authority** (e.g., a University) verifies the claim off-chain (by checking real documents) and then issues an **Attestation**.
- The Authority signs a statement referencing Alice's self-issued claim hash.
- "I, University X, attest that the claim [Hash] by Alice is true."
- This attestation is recorded in the Authority's Aqua chain.

### 3. Verification & Trust Chains
A relying party (e.g., an Employer) verifies the diploma.
- They check Alice's claim.
- They verify the University's signature on the attestation.
- They verify the University's authority (e.g., by checking a "Ministry of Education" attestation on the University's identity).
- If the chain of trust is valid, the diploma is accepted.


## Real-World Scenario: The "Trust Chain"

Consider verifying a **University Degree**:

1.  **The Graduate (Alice)**: Creates a self-issued claim for her degree.
2.  **The Professor**: Signs an attestation for Alice's grade/completion.
3.  **The Department Head**: Attests to the Professor's employment.
4.  **The University**: Attests to the Department Head's role.
5.  **The Ministry of Education**: Attests to the University's accreditation.

When an employer verifies Alice's degree, they trace this path back to a root of trust they recognize (e.g., the Ministry of Education), ensuring the credential is legitimate without needing to call the university.

## See Also

- [Document Verification](/docs/v4.0.0/use-cases/document-verification) - Verify the integrity of files and contracts.
- [Supply Chain Tracking](/docs/v4.0.0/use-cases/supply-chain) - Trace provenance of physical goods.
- [Aqua CLI](/docs/v4.0.0/dev-tools/aqua-cli) - Tools for issuing and verifying claims.
29:T17b5,
The Aqua Protocol enables a robust **Self-Sovereign Identity (SSI)** framework where individuals and organizations can issue, attest, and verify identity claims without relying on centralized identity providers. By leveraging cryptographic proofs and decentralized trust chains, Aqua allows users to own their data while enabling third parties to verify specific attributes with certainty.

## Core Capabilities

### Self-Sovereign Identity (SSI)
Users have full control over their identities. Identity claims are **self-issued** first, proving account ownership, and then enriched by **attestations** from trusted authorities. This ensures that the user is always the central point of their identity graph.

### Verifiable Attestations
Third parties (Trust Authorities) can sign attestations that validate a user's specific claims (e.g., "Over 18", "Accredited Investor", "University Graduate"). These attestations are cryptographically linked to the user's identity chain and the authority's trust chain.

### Trust Chains
Trust is transitive and transparent. A verifier doesn't just trust a claim; they verify the entire chain of authority. For example, a diploma is trusted because it's signed by a University, which is accredited by an Education Ministry, which is recognized by the Government.

### Selective Disclosure & Privacy
Users can share specific attestations (e.g., "I am over 21") without revealing their entire identity or unrelated personal data. Data Vaults protect sensitive claims, ensuring they are only decrypted for authorized verifiers.

## Use Cases by Industry

### Education & Academia

**Digital Diplomas & Transcripts**
- Universities issue tamper-proof degree certificates.
- Students can instantly prove graduation to employers.
- Prevents credential fraud and "diploma mills".
- Enables portable academic records across institutions.

**Professional Certifications**
- Licensing boards attest to professional status (e.g., Medical License, Bar Association).
- Real-time verification of valid/active status.
- Automated expiry and renewal tracking.

### Government & Legal

**Digital ID & Passports**
- Governments issue digital complements to physical IDs.
- Citizens use digital wallets to prove citizenship or residency.
- Streamlined visa and border entry processes.

**Notary & Witnessing**
- Notaries attest to the identity of a signer on a document.
- Creates a cryptographic link between the person, the document, and the notary.
- Replaces physical stamps with digital signatures.

### Financial Services

**KYC/AML Compliance**
- Banks perform "Know Your Customer" checks once and issue a reusable attestation.
- Users share this attestation with other services to onboard instantly without re-submitting documents.
- Reduces compliance costs and friction.

**Accredited Investor Status**
- Financial institutions attest that a user meets investment criteria.
- Allows participation in regulated private equity or tokens.

### Digital Services & Web3

**Sybil Resistance**
- Verify that an account belongs to a unique human without collecting personal data.
- "Proof of Humanity" or "Social Login" attestations.
- Prevents bot spam and manipulation in DAOs and communities.

**Reputation & Social Proof**
- Platforms attest to a user's reputation score or history.
- Enables portable reputation across different marketplaces and communities.

## Key Benefits

### User Privacy & Control
Users store their own data in encrypted Data Vaults. They grant access only when necessary and can revoke it at any time. No centralized "honey pot" of user data to hack.

### Fraud Reduction
Cryptographic signatures make it impossible to forge attestations. 

### Interoperability
Built on standard cryptographic primitives, allowing identity claims to be used across different platforms, wallets, and services that support the Aqua Protocol.

### Reduced Friction
"Verify once, use everywhere." Users don't need to repeatedly upload passport photos or utility bills. One verified attestation can be reused across multiple services.

## How It Works

### 1. Claim Creation (Self-Issuance)
The user creates a **Self-Issued Identity Claim**.
- Example: "I claim my name is Alice."
- This claim is signed by Alice's private key, establishing ownership of the claim.
- It serves as the "subject" for future attestations.

### 2. Attestation
A **Trust Authority** (e.g., a University) verifies the claim off-chain (by checking real documents) and then issues an **Attestation**.
- The Authority signs a statement referencing Alice's self-issued claim hash.
- "I, University X, attest that the claim [Hash] by Alice is true."
- This attestation is recorded in the Authority's Aqua chain.

### 3. Verification & Trust Chains
A relying party (e.g., an Employer) verifies the diploma.
- They check Alice's claim.
- They verify the University's signature on the attestation.
- They verify the University's authority (e.g., by checking a "Ministry of Education" attestation on the University's identity).
- If the chain of trust is valid, the diploma is accepted.


## Real-World Scenario: The "Trust Chain"

Consider verifying a **University Degree**:

1.  **The Graduate (Alice)**: Creates a self-issued claim for her degree.
2.  **The Professor**: Signs an attestation for Alice's grade/completion.
3.  **The Department Head**: Attests to the Professor's employment.
4.  **The University**: Attests to the Department Head's role.
5.  **The Ministry of Education**: Attests to the University's accreditation.

When an employer verifies Alice's degree, they trace this path back to a root of trust they recognize (e.g., the Ministry of Education), ensuring the credential is legitimate without needing to call the university.

## See Also

- [Document Verification](/docs/v4.0.0/use-cases/document-verification) - Verify the integrity of files and contracts.
- [Supply Chain Tracking](/docs/v4.0.0/use-cases/supply-chain) - Trace provenance of physical goods.
- [Aqua CLI](/docs/v4.0.0/dev-tools/aqua-cli) - Tools for issuing and verifying claims.
2a:T2595,
## Why Aqua Protocol?

Traditional systems for tracking data provenance, verifying authenticity, and maintaining audit trails rely on centralized databases and trusted intermediaries. These approaches introduce:

- **Single points of failure**: Centralized systems can be compromised, taken offline, or manipulated
- **Trust requirements**: Users must trust the intermediary to maintain integrity
- **Limited verification**: Third parties cannot independently verify authenticity
- **Vendor lock-in**: Data is trapped in proprietary systems
- **High costs**: Intermediaries charge fees for verification services

Aqua Protocol solves these problems through:

- **Decentralized verification**: Anyone can verify data integrity cryptographically
- **Mathematical certainty**: Cryptographic proofs replace trust requirements
- **Immutable history**: Complete audit trails that cannot be altered
- **Open standards**: Platform-agnostic verification using standard algorithms
- **Cost efficiency**: Reduced reliance on intermediaries and manual processes

## Core Capabilities

### Tamper-Proof Records
Once data is recorded in an Aqua chain, modifications become immediately detectable. Cryptographic hashes ensure that any change to content, timestamps, or signatures invalidates the chain, providing mathematical proof of tampering.

### Blockchain Timestamping
Every critical revision can be anchored to Ethereum, Nostr, or TSA timestamping services. This provides cryptographic proof of when data existed, eliminating disputes about timing and preventing backdating.

### Multi-Party Signatures
Multiple parties can cryptographically sign revisions, establishing non-repudiation and accountability. Each signature is independently verifiable, proving who authorized what and when.

### Provenance Tracking
Link revisions create relationships between chains, enabling complex provenance graphs. Track how data flows through systems, who touched it, and what transformations occurred.

### Template-Based Validation
Version 4's template system enforces data schemas with JSON Schema validation, ensuring consistent structure across revisions while maintaining cryptographic integrity.

## Application Domains

### Legal and Compliance
Legal documents, contracts, evidence, regulatory filings, and compliance records require guaranteed integrity and provable timestamps. Aqua Protocol provides:
- Non-repudiation through cryptographic signatures
- Defensible timestamps via blockchain anchoring
- Complete audit trails for investigations
- Chain of custody for evidence
- Regulatory compliance documentation

### Supply Chain and Logistics
Products moving through complex supply chains need provenance tracking from origin to destination. Aqua Protocol enables:
- End-to-end traceability from raw materials to consumer
- Multi-party coordination across manufacturers, distributors, and retailers
- Authenticity verification to prevent counterfeits
- Regulatory compliance for food, pharmaceuticals, and other regulated goods
- Efficient recalls with precise product tracking

### Identity and Credentials
Educational institutions, professional organizations, and governments issue credentials that need verification. Aqua Protocol provides:
- Instant verification of diplomas, certificates, and licenses
- Revocation capability when credentials expire or are withdrawn
- Portable credentials that individuals control
- Elimination of credential fraud
- Reduced verification costs and time

### Financial Services
Financial institutions require immutable audit trails for transactions, statements, and regulatory reports. Aqua Protocol offers:
- Tamper-proof financial records
- Provable submission timing for regulatory filings
- Multi-party approval workflows for transactions
- Audit-ready documentation for compliance
- Fraud prevention through verification

### Healthcare
Patient records, clinical trial data, and medical device tracking demand integrity and privacy. Aqua Protocol enables:
- Verifiable medical records that patients control
- Clinical trial data integrity for regulatory approval
- Medical device tracking and recall management
- HIPAA-compliant audit trails
- Secure sharing between healthcare providers

### Intellectual Property
Patents, copyrights, trade secrets, and creative works benefit from provable timestamps. Aqua Protocol provides:
- Proof of creation date for prior art disputes
- Version tracking for creative works
- Licensing and royalty audit trails
- Collaborative creation with attribution
- Protection against IP theft

## Industry-Specific Solutions

### Manufacturing
- Bill of materials with cryptographic proof
- Quality control inspection records
- Product genealogy from components to finished goods
- Supplier certification verification
- Warranty claim documentation

### Real Estate
- Property title chains with verified transfers
- Lease agreements with multi-party signatures
- Inspection reports with tamper-proof timestamps
- Escrow milestone documentation
- Regulatory compliance for transactions

### Energy and Utilities
- Renewable energy certificate tracking
- Carbon credit provenance verification
- Utility meter reading audit trails
- Regulatory compliance documentation
- Asset maintenance history

### Government and Public Sector
- Passport and identity document verification
- Professional license tracking
- Permit and certification issuance
- Public records integrity
- Voting and election audit trails

## Technical Flexibility

Aqua Protocol adapts to diverse requirements through:

- **Multiple revision types**: Objects, templates, signatures, witnesses, and links
- **Flexible signing methods**: RSA, Ethereum EIP-191, DID:JWS, and more
- **Choice of witnesses**: Ethereum (mainnet, testnets), Nostr, TSA
- **Scalar or tree methods**: Optimize for simplicity or selective disclosure
- **Cross-platform SDKs**: Rust with WASM, JavaScript/TypeScript for any environment
- **Template customization**: Define domain-specific schemas with JSON Schema

## Getting Started

Explore the detailed use cases below to understand how Aqua Protocol applies to your specific domain:

<CardGrid cols={2}>
  <Card title="Document Verification" icon="file-check" href="/docs/v4.0.0/use-cases/document-verification">
    Ensure document authenticity and integrity with cryptographic verification. Learn how legal firms, businesses, educational institutions, and government agencies use Aqua Protocol for tamper-proof document management.
  </Card>

  <Card title="Supply Chain Tracking" icon="truck" href="/docs/v4.0.0/use-cases/supply-chain">
    Track products through the supply chain with end-to-end transparency. Discover how food, pharmaceutical, manufacturing, and logistics companies implement provenance verification.
  </Card>

  <Card title="Identity Attestation" icon="id-card" href="/docs/v4.0.0/use-cases/identity-attestation">
    Implement secure identity verification and credential attestation. Explore how credentials, certifications, and identity documents gain instant verifiability.
  </Card>

</CardGrid>

## Common Patterns

Regardless of industry, Aqua Protocol implementations typically follow these patterns:

### 1. Genesis Creation
Start by creating the initial revision with core data:
- Document content, product information, or credential details
- Relevant metadata (timestamps, identifiers, classifications)
- Template reference for structured data validation

### 2. Multi-Party Signatures
Collect signatures from relevant parties:
- Creator signs to establish authenticity
- Reviewers sign to indicate approval
- Authorities sign for official endorsement
- Each signature adds non-repudiation

### 3. Blockchain Witnessing
Anchor critical revisions to blockchain:
- Provides tamper-proof timestamps
- Prevents backdating of revisions
- Enables independent verification
- Satisfies regulatory requirements

### 4. Provenance Linking
Connect related chains:
- Link components to assemblies
- Reference supporting documents
- Establish dependencies between datasets
- Create complex verification graphs

### 5. Long-Term Verification
Maintain verifiability over time:
- Store Aqua chains separately from content
- Distribute chains to all stakeholders
- Periodically verify chain integrity
- Update verification tools as needed

## Benefits Across All Use Cases

### Trust Without Intermediaries
Cryptographic verification replaces trust in centralized authorities. Anyone can independently verify authenticity, reducing costs and increasing accessibility.

### Regulatory Compliance
Immutable audit trails satisfy regulators across industries. From SOX compliance in finance to HIPAA in healthcare, Aqua Protocol provides defensible documentation.

### Cost Reduction
Automated verification eliminates manual processes, reduces fraud losses, speeds up operations, and removes intermediary fees.

### Enhanced Security
Cryptographic primitives (SHA3-256, ECDSA) provide security that cannot be achieved with traditional databases. Even system administrators cannot forge valid chains.

### Future-Proof Design
Protocol versioning, extensible revision types, and blockchain-agnostic witnessing ensure Aqua chains remain verifiable as technology evolves.

## Next Steps

Ready to implement Aqua Protocol for your use case?

- Review the detailed use case documentation above
- Check out the [Quick Start Guide](/docs/v4.0.0/quickstart) for hands-on implementation
- Explore the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) for technical specifications
- Choose your SDK: [JavaScript (v3)](/docs/v3.0.2/introduction)
2b:T2595,
## Why Aqua Protocol?

Traditional systems for tracking data provenance, verifying authenticity, and maintaining audit trails rely on centralized databases and trusted intermediaries. These approaches introduce:

- **Single points of failure**: Centralized systems can be compromised, taken offline, or manipulated
- **Trust requirements**: Users must trust the intermediary to maintain integrity
- **Limited verification**: Third parties cannot independently verify authenticity
- **Vendor lock-in**: Data is trapped in proprietary systems
- **High costs**: Intermediaries charge fees for verification services

Aqua Protocol solves these problems through:

- **Decentralized verification**: Anyone can verify data integrity cryptographically
- **Mathematical certainty**: Cryptographic proofs replace trust requirements
- **Immutable history**: Complete audit trails that cannot be altered
- **Open standards**: Platform-agnostic verification using standard algorithms
- **Cost efficiency**: Reduced reliance on intermediaries and manual processes

## Core Capabilities

### Tamper-Proof Records
Once data is recorded in an Aqua chain, modifications become immediately detectable. Cryptographic hashes ensure that any change to content, timestamps, or signatures invalidates the chain, providing mathematical proof of tampering.

### Blockchain Timestamping
Every critical revision can be anchored to Ethereum, Nostr, or TSA timestamping services. This provides cryptographic proof of when data existed, eliminating disputes about timing and preventing backdating.

### Multi-Party Signatures
Multiple parties can cryptographically sign revisions, establishing non-repudiation and accountability. Each signature is independently verifiable, proving who authorized what and when.

### Provenance Tracking
Link revisions create relationships between chains, enabling complex provenance graphs. Track how data flows through systems, who touched it, and what transformations occurred.

### Template-Based Validation
Version 4's template system enforces data schemas with JSON Schema validation, ensuring consistent structure across revisions while maintaining cryptographic integrity.

## Application Domains

### Legal and Compliance
Legal documents, contracts, evidence, regulatory filings, and compliance records require guaranteed integrity and provable timestamps. Aqua Protocol provides:
- Non-repudiation through cryptographic signatures
- Defensible timestamps via blockchain anchoring
- Complete audit trails for investigations
- Chain of custody for evidence
- Regulatory compliance documentation

### Supply Chain and Logistics
Products moving through complex supply chains need provenance tracking from origin to destination. Aqua Protocol enables:
- End-to-end traceability from raw materials to consumer
- Multi-party coordination across manufacturers, distributors, and retailers
- Authenticity verification to prevent counterfeits
- Regulatory compliance for food, pharmaceuticals, and other regulated goods
- Efficient recalls with precise product tracking

### Identity and Credentials
Educational institutions, professional organizations, and governments issue credentials that need verification. Aqua Protocol provides:
- Instant verification of diplomas, certificates, and licenses
- Revocation capability when credentials expire or are withdrawn
- Portable credentials that individuals control
- Elimination of credential fraud
- Reduced verification costs and time

### Financial Services
Financial institutions require immutable audit trails for transactions, statements, and regulatory reports. Aqua Protocol offers:
- Tamper-proof financial records
- Provable submission timing for regulatory filings
- Multi-party approval workflows for transactions
- Audit-ready documentation for compliance
- Fraud prevention through verification

### Healthcare
Patient records, clinical trial data, and medical device tracking demand integrity and privacy. Aqua Protocol enables:
- Verifiable medical records that patients control
- Clinical trial data integrity for regulatory approval
- Medical device tracking and recall management
- HIPAA-compliant audit trails
- Secure sharing between healthcare providers

### Intellectual Property
Patents, copyrights, trade secrets, and creative works benefit from provable timestamps. Aqua Protocol provides:
- Proof of creation date for prior art disputes
- Version tracking for creative works
- Licensing and royalty audit trails
- Collaborative creation with attribution
- Protection against IP theft

## Industry-Specific Solutions

### Manufacturing
- Bill of materials with cryptographic proof
- Quality control inspection records
- Product genealogy from components to finished goods
- Supplier certification verification
- Warranty claim documentation

### Real Estate
- Property title chains with verified transfers
- Lease agreements with multi-party signatures
- Inspection reports with tamper-proof timestamps
- Escrow milestone documentation
- Regulatory compliance for transactions

### Energy and Utilities
- Renewable energy certificate tracking
- Carbon credit provenance verification
- Utility meter reading audit trails
- Regulatory compliance documentation
- Asset maintenance history

### Government and Public Sector
- Passport and identity document verification
- Professional license tracking
- Permit and certification issuance
- Public records integrity
- Voting and election audit trails

## Technical Flexibility

Aqua Protocol adapts to diverse requirements through:

- **Multiple revision types**: Objects, templates, signatures, witnesses, and links
- **Flexible signing methods**: RSA, Ethereum EIP-191, DID:JWS, and more
- **Choice of witnesses**: Ethereum (mainnet, testnets), Nostr, TSA
- **Scalar or tree methods**: Optimize for simplicity or selective disclosure
- **Cross-platform SDKs**: Rust with WASM, JavaScript/TypeScript for any environment
- **Template customization**: Define domain-specific schemas with JSON Schema

## Getting Started

Explore the detailed use cases below to understand how Aqua Protocol applies to your specific domain:

<CardGrid cols={2}>
  <Card title="Document Verification" icon="file-check" href="/docs/v4.0.0/use-cases/document-verification">
    Ensure document authenticity and integrity with cryptographic verification. Learn how legal firms, businesses, educational institutions, and government agencies use Aqua Protocol for tamper-proof document management.
  </Card>

  <Card title="Supply Chain Tracking" icon="truck" href="/docs/v4.0.0/use-cases/supply-chain">
    Track products through the supply chain with end-to-end transparency. Discover how food, pharmaceutical, manufacturing, and logistics companies implement provenance verification.
  </Card>

  <Card title="Identity Attestation" icon="id-card" href="/docs/v4.0.0/use-cases/identity-attestation">
    Implement secure identity verification and credential attestation. Explore how credentials, certifications, and identity documents gain instant verifiability.
  </Card>

</CardGrid>

## Common Patterns

Regardless of industry, Aqua Protocol implementations typically follow these patterns:

### 1. Genesis Creation
Start by creating the initial revision with core data:
- Document content, product information, or credential details
- Relevant metadata (timestamps, identifiers, classifications)
- Template reference for structured data validation

### 2. Multi-Party Signatures
Collect signatures from relevant parties:
- Creator signs to establish authenticity
- Reviewers sign to indicate approval
- Authorities sign for official endorsement
- Each signature adds non-repudiation

### 3. Blockchain Witnessing
Anchor critical revisions to blockchain:
- Provides tamper-proof timestamps
- Prevents backdating of revisions
- Enables independent verification
- Satisfies regulatory requirements

### 4. Provenance Linking
Connect related chains:
- Link components to assemblies
- Reference supporting documents
- Establish dependencies between datasets
- Create complex verification graphs

### 5. Long-Term Verification
Maintain verifiability over time:
- Store Aqua chains separately from content
- Distribute chains to all stakeholders
- Periodically verify chain integrity
- Update verification tools as needed

## Benefits Across All Use Cases

### Trust Without Intermediaries
Cryptographic verification replaces trust in centralized authorities. Anyone can independently verify authenticity, reducing costs and increasing accessibility.

### Regulatory Compliance
Immutable audit trails satisfy regulators across industries. From SOX compliance in finance to HIPAA in healthcare, Aqua Protocol provides defensible documentation.

### Cost Reduction
Automated verification eliminates manual processes, reduces fraud losses, speeds up operations, and removes intermediary fees.

### Enhanced Security
Cryptographic primitives (SHA3-256, ECDSA) provide security that cannot be achieved with traditional databases. Even system administrators cannot forge valid chains.

### Future-Proof Design
Protocol versioning, extensible revision types, and blockchain-agnostic witnessing ensure Aqua chains remain verifiable as technology evolves.

## Next Steps

Ready to implement Aqua Protocol for your use case?

- Review the detailed use case documentation above
- Check out the [Quick Start Guide](/docs/v4.0.0/quickstart) for hands-on implementation
- Explore the [Schema Reference](/docs/v4.0.0/schema-reference/introduction) for technical specifications
- Choose your SDK: [JavaScript (v3)](/docs/v3.0.2/introduction)
2c:T4129,
# Supply Chain Tracking

Aqua Protocol provides cryptographic provenance tracking for supply chain operations, enabling end-to-end traceability from raw materials to finished products. Each step in the supply chain is recorded with immutable timestamps, creating a verifiable chain of custody that proves authenticity and tracks movement across multiple parties.

## Core Capabilities

### End-to-End Traceability
Track products from origin to destination with cryptographic proof at each step. Every transfer, transformation, and quality check is recorded in an immutable chain, creating a complete product history that can be independently verified.

### Multi-Party Coordination
Supply chains involve manufacturers, distributors, retailers, regulators, and consumers. Aqua Protocol enables all parties to contribute to the chain while maintaining data integrity, without requiring a central authority.

### Provenance Verification
Prove the origin and authenticity of products cryptographically. Consumers and businesses can verify that products are genuine, sourced ethically, and meet quality standards without trusting intermediaries.

### Real-Time Transparency
All stakeholders can verify the current state and history of products in real-time. Blockchain witnesses provide tamper-proof timestamps, ensuring accurate tracking of supply chain events as they occur.

## Use Cases by Industry

### Food & Agriculture

**Farm-to-Table Tracking**
- Record harvest timestamps and origin farm information
- Track temperature and storage conditions during transport
- Prove organic certification and farming practices
- Enable consumers to verify food provenance via QR codes

**Quality Assurance**
- Document quality inspections at each stage
- Track batch numbers for recall management
- Record processing and packaging timestamps
- Maintain cold chain compliance records

**Regulatory Compliance**
- Demonstrate compliance with food safety regulations
- Provide audit trails for health inspectors
- Track certifications (organic, fair trade, kosher, halal)
- Prove country of origin for import/export

**Recall Management**
- Identify affected batches immediately
- Trace contamination to specific sources
- Notify all parties in distribution chain
- Minimize recall scope with precise tracking

### Pharmaceuticals

**Drug Authentication**
- Prevent counterfeit medications from entering supply chain
- Verify pharmaceutical manufacturer and production batch
- Track medication from factory to pharmacy
- Enable patients to verify medication authenticity

**Cold Chain Management**
- Record temperature at every transport stage
- Prove compliance with storage requirements
- Alert stakeholders to temperature excursions
- Maintain regulatory compliance documentation

**Clinical Trial Management**
- Track investigational drugs through trial phases
- Document chain of custody for trial materials
- Prove compliance with trial protocols
- Maintain audit trails for regulatory submissions

**Regulatory Reporting**
- Demonstrate compliance with pharmaceutical regulations
- Track serialization and aggregation data
- Provide audit trails for FDA, EMA, and other authorities
- Support Drug Supply Chain Security Act (DSCSA) compliance

### Manufacturing

**Component Traceability**
- Track components from suppliers to assembly
- Verify authenticity of critical components
- Manage bill of materials with cryptographic proof
- Prevent counterfeit parts from entering production

**Quality Control**
- Record inspection results at each manufacturing stage
- Document rework and quality issues
- Track serial numbers through production process
- Maintain statistical process control data

**Product Genealogy**
- Build complete product history from raw materials
- Track which components went into which products
- Enable root cause analysis for defects
- Support warranty claims with production records

**Supplier Management**
- Verify supplier certifications and compliance
- Track supplier performance metrics
- Prove ethical sourcing practices
- Manage supplier risk with documented history

### Logistics & Distribution

**Shipment Tracking**
- Record custody transfers between carriers
- Timestamp loading and unloading events
- Track location updates throughout journey
- Prove on-time delivery with blockchain witnesses

**Customs and Border Control**
- Provide immutable documentation for customs
- Prove product origin for tariff classification
- Streamline border crossings with verified data
- Reduce customs delays with cryptographic proof

**Last-Mile Delivery**
- Verify final delivery to customer
- Timestamp customer receipt
- Prove condition at delivery
- Enable dispute resolution with documented proof

**Warehouse Management**
- Track inventory movements within facilities
- Record picking, packing, and shipping operations
- Maintain lot and serial number traceability
- Integrate with ERP systems for real-time updates

## Key Benefits

### Eliminate Counterfeits
Counterfeit products cost industries billions annually. Aqua Protocol makes counterfeiting economically infeasible by requiring cryptographic proof at each supply chain step. Fake products cannot produce valid Aqua chains, making them easily identifiable.

### Improve Recall Efficiency
When safety issues arise, rapid recall is critical. Aqua Protocol enables precise identification of affected products, reducing recall scope and cost. Complete provenance data shows exactly which batches are impacted and where they were distributed.

### Increase Consumer Trust
Consumers increasingly demand transparency about product origins and manufacturing. Scannable QR codes linked to Aqua chains let customers verify authenticity, ethical sourcing, and quality standards, building brand trust.

### Streamline Compliance
Regulatory compliance requires extensive documentation and audit trails. Aqua Protocol automatically creates tamper-proof records that satisfy regulators, reducing compliance costs and audit preparation time.

### Enable Ethical Sourcing
Prove that products meet ethical standards for labor practices, environmental impact, and sustainable sourcing. Immutable records prevent "ethics washing" and provide verifiable proof of responsible practices.

### Reduce Liability
Complete documentation of supply chain events reduces liability exposure. When disputes arise, cryptographic proof shows exactly what happened, when, and who was responsible.

## How It Works

### 1. Product Registration
When a product enters the supply chain:
- Genesis revision is created with product identifier
- Initial metadata recorded (SKU, batch number, origin)
- Manufacturer signs the genesis revision
- Signature is witnessed on blockchain for timestamp proof
- Product receives unique Aqua chain

### 2. Supply Chain Events
As the product moves through the supply chain:
- Each event creates a new revision (transfer, inspection, processing)
- Event data includes timestamp, location, responsible party
- Each party signs their contributions to the chain
- Critical events are witnessed for regulatory proof
- Chain grows to include complete product history

### 3. Multi-Party Signatures
When custody transfers between parties:
- Sending party signs transfer revision
- Receiving party verifies and countersigns
- Both signatures reference the same state
- Blockchain witness timestamps the transfer
- Prevents disputes about transfer timing or condition

### 4. Verification
At any point, stakeholders can verify:
- Scan product QR code to retrieve Aqua chain
- Verify all cryptographic signatures
- Check blockchain witnesses for timestamps
- Validate entire chain integrity
- Confirm product authenticity and history

## Real-World Scenarios

### Scenario 1: Pharmaceutical Supply Chain

**Challenge**: A pharmaceutical company must track medication from manufacturing through distribution to pharmacies while maintaining cold chain compliance and preventing counterfeits.

**Solution**:
- Each medication batch gets genesis revision when manufactured
- Quality control inspections add signed revisions
- Temperature monitors record readings as revisions
- Each distributor transfer is signed by both parties
- Pharmacies verify medication authenticity by scanning
- Regulators can audit complete chain from manufacturer to patient

**Benefits**: Counterfeit prevention, cold chain compliance, regulatory audit trails, patient safety, streamlined recalls

### Scenario 2: Organic Food Certification

**Challenge**: Consumers want to verify that "organic" products are genuinely organic from farm to store, but current systems rely on paper certificates that can be forged.

**Solution**:
- Farms create genesis revision with organic certification
- Certification body signs the certification revision
- Each processing step is documented and signed
- Distributors add transport and storage revisions
- Retailers witness final product placement
- Consumers scan QR code to verify organic provenance

**Benefits**: Verified organic claims, consumer confidence, brand differentiation, premium pricing justification

### Scenario 3: Automotive Parts Traceability

**Challenge**: An automotive manufacturer needs to track critical safety components through multiple supplier tiers to ensure authenticity and enable recalls if defects are discovered.

**Solution**:
- Tier 3 supplier creates genesis for raw materials
- Tier 2 supplier adds processing revisions with quality checks
- Tier 1 supplier integrates into assemblies with link revisions
- OEM manufacturer links assemblies into final vehicles
- Each VIN is linked to component Aqua chains
- Defective component traced to exact source and all affected vehicles

**Benefits**: Counterfeit prevention, rapid recall execution, root cause analysis, supplier accountability, quality improvement

### Scenario 4: Coffee Supply Chain Transparency

**Challenge**: Coffee roasters want to prove fair trade practices and sustainable sourcing to increasingly conscious consumers, but existing certification systems are opaque.

**Solution**:
- Coffee farmers create genesis with harvest data
- Fair trade auditor signs certification revision
- Exporters document transport and quality grading
- Importers add customs and warehousing data
- Roasters link to final packaged products
- Consumers scan bags to see complete farm-to-cup journey

**Benefits**: Verified ethical sourcing, consumer transparency, premium pricing, farmer accountability, brand storytelling

## Integration Patterns

### ERP Systems
Integrate Aqua Protocol with enterprise resource planning systems to automatically create revisions for inventory movements, production events, and quality checks.

**Implementation**:
- ERP triggers Aqua revision creation on key events
- Product master data becomes genesis revision
- Manufacturing orders add production revisions
- Shipping orders create transfer revisions
- Quality inspections add signed quality revisions

### IoT Sensors
Connect IoT devices to automatically record sensor data as revisions:
- Temperature sensors for cold chain monitoring
- GPS trackers for location updates
- RFID readers for automated checkpoint scanning
- Weight scales for quantity verification
- Quality inspection equipment for automated testing

### Blockchain Oracles
Use blockchain oracles to feed external data into supply chains:
- Weather data for agricultural provenance
- Customs clearance status
- Regulatory database lookups
- Third-party certification verification
- Market pricing for timestamp-based valuation

### Consumer Apps
Build consumer-facing applications that verify products:
- Mobile apps with QR code scanning
- Web portals for product history viewing
- Voice assistants for product authentication
- Smart packaging with NFC chips
- Augmented reality product storytelling

### Supplier Portals
Create portals for suppliers to contribute to chains:
- Self-service revision creation
- Document upload and signature
- Certification management
- Quality data submission
- Real-time status visibility

## Best Practices

### Genesis Creation
- Create genesis as early as possible in supply chain
- Include comprehensive product metadata
- Use template revisions for standardized data
- Sign genesis immediately to establish authenticity
- Witness genesis for high-value or regulated products

### Event Granularity
- Balance detail with practical overhead
- Record all custody transfers
- Document critical quality checkpoints
- Capture regulatory compliance events
- Skip routine events that don't add value

### Multi-Party Coordination
- Establish clear protocols for handoffs
- Both parties must sign custody transfers
- Verify previous signatures before adding new ones
- Communicate chain updates to all stakeholders
- Maintain consistent timestamp standards

### Data Privacy
- Aqua chains store hashes, not sensitive content
- Use tree method for selective disclosure
- Share chains only with authorized parties
- Consider what metadata is included
- Use private witnesses if public timestamps are problematic

### Verification Strategy
- Verify products at key checkpoints
- Check complete chain for high-value items
- Spot-check for routine items
- Validate blockchain witnesses for critical events
- Train staff on verification procedures

### Batch Operations
- Use batch witnessing to reduce costs
- Group similar products in same witness transaction
- Balance cost savings with timestamp precision
- Implement automated batching in integration systems
- Monitor batch sizes for optimization

## Technical Advantages

### Scalability
- Object revisions scale to billions of products
- Link revisions enable hierarchical organization
- Batch witnessing reduces blockchain costs
- Offline verification after chain retrieval
- Distributed storage prevents bottlenecks

### Interoperability
- JSON-based format for easy integration
- Multiple SDK options (Rust, JavaScript)
- Standard cryptographic primitives
- Platform-agnostic verification
- Compatible with existing supply chain systems

### Flexibility
- Template system for industry-specific schemas
- Custom revision types for unique requirements
- Multiple signature methods for different parties
- Choice of witnessing networks
- Extensible for future needs

### Security
- SHA3-256 hashing prevents collision attacks
- ECDSA signatures provide strong authentication
- Blockchain anchoring prevents backdating
- Merkle trees enable selective disclosure
- Cryptographic proof instead of trust

## Common Questions

**Q: How do we handle products without digital interfaces?**
A: Use QR codes, NFC tags, or printed Aqua chain identifiers on packaging. The Aqua chain exists independently of the physical product. Low-cost printed codes work for most products.

**Q: What if a supply chain participant doesn't want to use Aqua Protocol?**
A: The chain can continue without them, but their contribution won't have cryptographic proof. This creates accountability - participants who don't use Aqua Protocol are less trustworthy. Market pressure encourages adoption.

**Q: How do we handle returns and reverse logistics?**
A: Add revision documenting the return event, including reason and condition. The chain naturally grows to include forward and reverse movements, maintaining complete product history.

**Q: Can we integrate with existing traceability systems?**
A: Yes. Aqua Protocol can wrap existing systems, adding cryptographic proof to current tracking data. Legacy system data can be hashed and stored in revisions.

**Q: What about supply chain privacy?**
A: Aqua chains contain only hashes by default, not business-sensitive data. Share chains selectively with authorized parties. Use tree method for selective disclosure of specific fields to certain stakeholders.

**Q: How do we handle lost or damaged products?**
A: Add revision documenting loss or damage event with relevant details. The Aqua chain preserves the history up to that point, supporting insurance claims and investigations.

**Q: What if blockchain networks fail?**
A: Verification of existing chains works offline using cryptographic signatures. Only new witnessing requires blockchain access. Historical witnesses remain provable through blockchain transaction records.

## See Also

- [Document Verification](/docs/v4.0.0/use-cases/document-verification) - Apply similar techniques to documents
- [Identity Attestation](/docs/v4.0.0/use-cases/identity-attestation) - Verify credentials and certifications
- [Quick Start](/docs/v4.0.0/quickstart) - Get started with supply chain tracking
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction) - Technical specifications
2d:T4129,
# Supply Chain Tracking

Aqua Protocol provides cryptographic provenance tracking for supply chain operations, enabling end-to-end traceability from raw materials to finished products. Each step in the supply chain is recorded with immutable timestamps, creating a verifiable chain of custody that proves authenticity and tracks movement across multiple parties.

## Core Capabilities

### End-to-End Traceability
Track products from origin to destination with cryptographic proof at each step. Every transfer, transformation, and quality check is recorded in an immutable chain, creating a complete product history that can be independently verified.

### Multi-Party Coordination
Supply chains involve manufacturers, distributors, retailers, regulators, and consumers. Aqua Protocol enables all parties to contribute to the chain while maintaining data integrity, without requiring a central authority.

### Provenance Verification
Prove the origin and authenticity of products cryptographically. Consumers and businesses can verify that products are genuine, sourced ethically, and meet quality standards without trusting intermediaries.

### Real-Time Transparency
All stakeholders can verify the current state and history of products in real-time. Blockchain witnesses provide tamper-proof timestamps, ensuring accurate tracking of supply chain events as they occur.

## Use Cases by Industry

### Food & Agriculture

**Farm-to-Table Tracking**
- Record harvest timestamps and origin farm information
- Track temperature and storage conditions during transport
- Prove organic certification and farming practices
- Enable consumers to verify food provenance via QR codes

**Quality Assurance**
- Document quality inspections at each stage
- Track batch numbers for recall management
- Record processing and packaging timestamps
- Maintain cold chain compliance records

**Regulatory Compliance**
- Demonstrate compliance with food safety regulations
- Provide audit trails for health inspectors
- Track certifications (organic, fair trade, kosher, halal)
- Prove country of origin for import/export

**Recall Management**
- Identify affected batches immediately
- Trace contamination to specific sources
- Notify all parties in distribution chain
- Minimize recall scope with precise tracking

### Pharmaceuticals

**Drug Authentication**
- Prevent counterfeit medications from entering supply chain
- Verify pharmaceutical manufacturer and production batch
- Track medication from factory to pharmacy
- Enable patients to verify medication authenticity

**Cold Chain Management**
- Record temperature at every transport stage
- Prove compliance with storage requirements
- Alert stakeholders to temperature excursions
- Maintain regulatory compliance documentation

**Clinical Trial Management**
- Track investigational drugs through trial phases
- Document chain of custody for trial materials
- Prove compliance with trial protocols
- Maintain audit trails for regulatory submissions

**Regulatory Reporting**
- Demonstrate compliance with pharmaceutical regulations
- Track serialization and aggregation data
- Provide audit trails for FDA, EMA, and other authorities
- Support Drug Supply Chain Security Act (DSCSA) compliance

### Manufacturing

**Component Traceability**
- Track components from suppliers to assembly
- Verify authenticity of critical components
- Manage bill of materials with cryptographic proof
- Prevent counterfeit parts from entering production

**Quality Control**
- Record inspection results at each manufacturing stage
- Document rework and quality issues
- Track serial numbers through production process
- Maintain statistical process control data

**Product Genealogy**
- Build complete product history from raw materials
- Track which components went into which products
- Enable root cause analysis for defects
- Support warranty claims with production records

**Supplier Management**
- Verify supplier certifications and compliance
- Track supplier performance metrics
- Prove ethical sourcing practices
- Manage supplier risk with documented history

### Logistics & Distribution

**Shipment Tracking**
- Record custody transfers between carriers
- Timestamp loading and unloading events
- Track location updates throughout journey
- Prove on-time delivery with blockchain witnesses

**Customs and Border Control**
- Provide immutable documentation for customs
- Prove product origin for tariff classification
- Streamline border crossings with verified data
- Reduce customs delays with cryptographic proof

**Last-Mile Delivery**
- Verify final delivery to customer
- Timestamp customer receipt
- Prove condition at delivery
- Enable dispute resolution with documented proof

**Warehouse Management**
- Track inventory movements within facilities
- Record picking, packing, and shipping operations
- Maintain lot and serial number traceability
- Integrate with ERP systems for real-time updates

## Key Benefits

### Eliminate Counterfeits
Counterfeit products cost industries billions annually. Aqua Protocol makes counterfeiting economically infeasible by requiring cryptographic proof at each supply chain step. Fake products cannot produce valid Aqua chains, making them easily identifiable.

### Improve Recall Efficiency
When safety issues arise, rapid recall is critical. Aqua Protocol enables precise identification of affected products, reducing recall scope and cost. Complete provenance data shows exactly which batches are impacted and where they were distributed.

### Increase Consumer Trust
Consumers increasingly demand transparency about product origins and manufacturing. Scannable QR codes linked to Aqua chains let customers verify authenticity, ethical sourcing, and quality standards, building brand trust.

### Streamline Compliance
Regulatory compliance requires extensive documentation and audit trails. Aqua Protocol automatically creates tamper-proof records that satisfy regulators, reducing compliance costs and audit preparation time.

### Enable Ethical Sourcing
Prove that products meet ethical standards for labor practices, environmental impact, and sustainable sourcing. Immutable records prevent "ethics washing" and provide verifiable proof of responsible practices.

### Reduce Liability
Complete documentation of supply chain events reduces liability exposure. When disputes arise, cryptographic proof shows exactly what happened, when, and who was responsible.

## How It Works

### 1. Product Registration
When a product enters the supply chain:
- Genesis revision is created with product identifier
- Initial metadata recorded (SKU, batch number, origin)
- Manufacturer signs the genesis revision
- Signature is witnessed on blockchain for timestamp proof
- Product receives unique Aqua chain

### 2. Supply Chain Events
As the product moves through the supply chain:
- Each event creates a new revision (transfer, inspection, processing)
- Event data includes timestamp, location, responsible party
- Each party signs their contributions to the chain
- Critical events are witnessed for regulatory proof
- Chain grows to include complete product history

### 3. Multi-Party Signatures
When custody transfers between parties:
- Sending party signs transfer revision
- Receiving party verifies and countersigns
- Both signatures reference the same state
- Blockchain witness timestamps the transfer
- Prevents disputes about transfer timing or condition

### 4. Verification
At any point, stakeholders can verify:
- Scan product QR code to retrieve Aqua chain
- Verify all cryptographic signatures
- Check blockchain witnesses for timestamps
- Validate entire chain integrity
- Confirm product authenticity and history

## Real-World Scenarios

### Scenario 1: Pharmaceutical Supply Chain

**Challenge**: A pharmaceutical company must track medication from manufacturing through distribution to pharmacies while maintaining cold chain compliance and preventing counterfeits.

**Solution**:
- Each medication batch gets genesis revision when manufactured
- Quality control inspections add signed revisions
- Temperature monitors record readings as revisions
- Each distributor transfer is signed by both parties
- Pharmacies verify medication authenticity by scanning
- Regulators can audit complete chain from manufacturer to patient

**Benefits**: Counterfeit prevention, cold chain compliance, regulatory audit trails, patient safety, streamlined recalls

### Scenario 2: Organic Food Certification

**Challenge**: Consumers want to verify that "organic" products are genuinely organic from farm to store, but current systems rely on paper certificates that can be forged.

**Solution**:
- Farms create genesis revision with organic certification
- Certification body signs the certification revision
- Each processing step is documented and signed
- Distributors add transport and storage revisions
- Retailers witness final product placement
- Consumers scan QR code to verify organic provenance

**Benefits**: Verified organic claims, consumer confidence, brand differentiation, premium pricing justification

### Scenario 3: Automotive Parts Traceability

**Challenge**: An automotive manufacturer needs to track critical safety components through multiple supplier tiers to ensure authenticity and enable recalls if defects are discovered.

**Solution**:
- Tier 3 supplier creates genesis for raw materials
- Tier 2 supplier adds processing revisions with quality checks
- Tier 1 supplier integrates into assemblies with link revisions
- OEM manufacturer links assemblies into final vehicles
- Each VIN is linked to component Aqua chains
- Defective component traced to exact source and all affected vehicles

**Benefits**: Counterfeit prevention, rapid recall execution, root cause analysis, supplier accountability, quality improvement

### Scenario 4: Coffee Supply Chain Transparency

**Challenge**: Coffee roasters want to prove fair trade practices and sustainable sourcing to increasingly conscious consumers, but existing certification systems are opaque.

**Solution**:
- Coffee farmers create genesis with harvest data
- Fair trade auditor signs certification revision
- Exporters document transport and quality grading
- Importers add customs and warehousing data
- Roasters link to final packaged products
- Consumers scan bags to see complete farm-to-cup journey

**Benefits**: Verified ethical sourcing, consumer transparency, premium pricing, farmer accountability, brand storytelling

## Integration Patterns

### ERP Systems
Integrate Aqua Protocol with enterprise resource planning systems to automatically create revisions for inventory movements, production events, and quality checks.

**Implementation**:
- ERP triggers Aqua revision creation on key events
- Product master data becomes genesis revision
- Manufacturing orders add production revisions
- Shipping orders create transfer revisions
- Quality inspections add signed quality revisions

### IoT Sensors
Connect IoT devices to automatically record sensor data as revisions:
- Temperature sensors for cold chain monitoring
- GPS trackers for location updates
- RFID readers for automated checkpoint scanning
- Weight scales for quantity verification
- Quality inspection equipment for automated testing

### Blockchain Oracles
Use blockchain oracles to feed external data into supply chains:
- Weather data for agricultural provenance
- Customs clearance status
- Regulatory database lookups
- Third-party certification verification
- Market pricing for timestamp-based valuation

### Consumer Apps
Build consumer-facing applications that verify products:
- Mobile apps with QR code scanning
- Web portals for product history viewing
- Voice assistants for product authentication
- Smart packaging with NFC chips
- Augmented reality product storytelling

### Supplier Portals
Create portals for suppliers to contribute to chains:
- Self-service revision creation
- Document upload and signature
- Certification management
- Quality data submission
- Real-time status visibility

## Best Practices

### Genesis Creation
- Create genesis as early as possible in supply chain
- Include comprehensive product metadata
- Use template revisions for standardized data
- Sign genesis immediately to establish authenticity
- Witness genesis for high-value or regulated products

### Event Granularity
- Balance detail with practical overhead
- Record all custody transfers
- Document critical quality checkpoints
- Capture regulatory compliance events
- Skip routine events that don't add value

### Multi-Party Coordination
- Establish clear protocols for handoffs
- Both parties must sign custody transfers
- Verify previous signatures before adding new ones
- Communicate chain updates to all stakeholders
- Maintain consistent timestamp standards

### Data Privacy
- Aqua chains store hashes, not sensitive content
- Use tree method for selective disclosure
- Share chains only with authorized parties
- Consider what metadata is included
- Use private witnesses if public timestamps are problematic

### Verification Strategy
- Verify products at key checkpoints
- Check complete chain for high-value items
- Spot-check for routine items
- Validate blockchain witnesses for critical events
- Train staff on verification procedures

### Batch Operations
- Use batch witnessing to reduce costs
- Group similar products in same witness transaction
- Balance cost savings with timestamp precision
- Implement automated batching in integration systems
- Monitor batch sizes for optimization

## Technical Advantages

### Scalability
- Object revisions scale to billions of products
- Link revisions enable hierarchical organization
- Batch witnessing reduces blockchain costs
- Offline verification after chain retrieval
- Distributed storage prevents bottlenecks

### Interoperability
- JSON-based format for easy integration
- Multiple SDK options (Rust, JavaScript)
- Standard cryptographic primitives
- Platform-agnostic verification
- Compatible with existing supply chain systems

### Flexibility
- Template system for industry-specific schemas
- Custom revision types for unique requirements
- Multiple signature methods for different parties
- Choice of witnessing networks
- Extensible for future needs

### Security
- SHA3-256 hashing prevents collision attacks
- ECDSA signatures provide strong authentication
- Blockchain anchoring prevents backdating
- Merkle trees enable selective disclosure
- Cryptographic proof instead of trust

## Common Questions

**Q: How do we handle products without digital interfaces?**
A: Use QR codes, NFC tags, or printed Aqua chain identifiers on packaging. The Aqua chain exists independently of the physical product. Low-cost printed codes work for most products.

**Q: What if a supply chain participant doesn't want to use Aqua Protocol?**
A: The chain can continue without them, but their contribution won't have cryptographic proof. This creates accountability - participants who don't use Aqua Protocol are less trustworthy. Market pressure encourages adoption.

**Q: How do we handle returns and reverse logistics?**
A: Add revision documenting the return event, including reason and condition. The chain naturally grows to include forward and reverse movements, maintaining complete product history.

**Q: Can we integrate with existing traceability systems?**
A: Yes. Aqua Protocol can wrap existing systems, adding cryptographic proof to current tracking data. Legacy system data can be hashed and stored in revisions.

**Q: What about supply chain privacy?**
A: Aqua chains contain only hashes by default, not business-sensitive data. Share chains selectively with authorized parties. Use tree method for selective disclosure of specific fields to certain stakeholders.

**Q: How do we handle lost or damaged products?**
A: Add revision documenting loss or damage event with relevant details. The Aqua chain preserves the history up to that point, supporting insurance claims and investigations.

**Q: What if blockchain networks fail?**
A: Verification of existing chains works offline using cryptographic signatures. Only new witnessing requires blockchain access. Historical witnesses remain provable through blockchain transaction records.

## See Also

- [Document Verification](/docs/v4.0.0/use-cases/document-verification) - Apply similar techniques to documents
- [Identity Attestation](/docs/v4.0.0/use-cases/identity-attestation) - Verify credentials and certifications
- [Quick Start](/docs/v4.0.0/quickstart) - Get started with supply chain tracking
- [Schema Reference](/docs/v4.0.0/schema-reference/introduction) - Technical specifications
0:{"buildId":"Wvwsg1u7-8cob0E1kTWhP","rsc":["$","$1","c",{"children":[["$","$2",null,{"fallback":["$","$L3",null,{}],"children":[["$","$L4",null,{"header":["$","$L5",null,{"currentVersion":"v4.0.0","versions":["v1.1.0","v2.0.2","v3.0.2","v4.0.0"],"config":{"site":{"title":"Aqua Protocol","description":"Open-source cryptographic trust infrastructure for the AI era — verifiable identity, access control, and tamper-proof provenance.","baseUrl":"/","language":"en","url":"https://aqua-protocol.org","organizationName":"inblockio","projectName":"aqua-docs","activeVersion":"v4.0.0","favicon":"/logo/aqua-logo.png","logo":{"dark":"/logo/aqua-logo.png","light":"/logo/aqua-logo.png"}},"theme":{"defaultMode":"system","respectPrefersColorScheme":true},"navigation":{"showSidebar":true,"collapsibleSidebar":true,"showBreadcrumbs":true,"showTableOfContents":true,"tocPosition":"right","tocMaxDepth":3},"search":{"enabled":false,"provider":"meilisearch","placeholder":"Search documentation...","meilisearch":{"host":"http://localhost:7700","apiKey":"aSampleMasterKey","indexName":"docs"}},"features":{"showLastUpdated":true,"showReadingTime":true,"showAuthors":false,"showTags":true,"versioning":true,"i18n":{"defaultLocale":"en","locales":["en"],"localeNames":{"en":"English"},"prefixDefault":true},"editUrl":"https://github.com/inblockio/aqua-docs/edit/main/docs"},"$schema":"./node_modules/specra/config/specra.config.schema.json","social":{"github":"https://github.com/inblockio","twitter":"https://x.com/inblockio","custom":[{"label":"Website","url":"https://dev.inblock.io"}]},"analytics":{"googleAnalytics":"","plausible":""},"footer":{"copyright":"Copyright © 2026 Aqua. All rights reserved.","links":[{"title":"Documentation","items":[{"label":"Getting Started","href":"/docs/v4.0.0/en/quickstart"},{"label":"API Reference","href":"/docs/v4.0.0/en/dev-tools/aquafier-api"}]},{"title":"Community","items":[{"label":"GitHub","href":"https://github.com/inblockio"}]}]},"banner":{"enabled":false,"message":"🎉 Aqua protocol - Let us build privacy infra together!","type":"error","dismissible":true},"env":{"AQUAFIER_URL":"https://aquafier.inblock.io"},"deployment":{"target":"github-pages","basePath":"","customDomain":true}}}],"docs":[{"slug":"en/schema-reference/aqua-tree","filePath":"schema-reference/aqua-tree","title":"Aqua Tree","meta":{"title":"Aqua Tree","description":"The root data structure containing revisions and metadata","sidebar_position":1,"content":"$6","reading_time":5,"word_count":888,"locale":"en"},"content":"$7","categoryLabel":"Schema Reference","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"book"},{"slug":"en/welcome","filePath":"welcome","title":"Welcome to Aqua Protocol","meta":{"title":"Welcome to Aqua Protocol","description":"Account & verify data in seconds using cryptographic proof","icon":"door-open","sidebar_position":1,"content":"$8","reading_time":5,"word_count":842,"locale":"en"},"content":"$9"},{"slug":"en/quickstart","filePath":"quickstart","title":"Quick Start","meta":{"title":"Quick Start","description":"This guide will get you up and running with Aqua Protocol quickly. You'll create your first Aqua chain, sign it, and optionally witness it on a blockchain.","icon":"rocket","sidebar_position":2,"content":"$a","reading_time":7,"word_count":1244,"locale":"en"},"content":"$b"},{"slug":"en/schema-reference/file-index","filePath":"schema-reference/file-index","title":"File Index","meta":{"title":"File Index","description":"Mapping content hashes to human-readable filenames","sidebar_position":2,"content":"$c","reading_time":5,"word_count":941,"locale":"en"},"content":"$d","categoryLabel":"Schema Reference","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"book"},{"slug":"en/development","filePath":"development","title":"Development Guide","meta":{"title":"Development Guide","description":"This guide covers everything you need to develop applications with Aqua Protocol, including signing methods, witnessing options, and SDK usage.","icon":"code","sidebar_position":3,"content":"$e","reading_time":9,"word_count":1674,"locale":"en"},"content":"$f"},{"slug":"en/schema-reference/introduction","filePath":"schema-reference/introduction","title":"Aqua Protocol Schema Reference ","meta":{"title":"Aqua Protocol Schema Reference ","description":"Complete technical reference for Aqua Protocol v4","sidebar_position":3,"content":"$10","reading_time":8,"word_count":1467,"locale":"en"},"content":"$11","categoryLabel":"Schema Reference","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"book"},{"slug":"en/version-info","filePath":"version-info","title":"Version v4 (beta)","meta":{"title":"Version v4 (beta)","description":"Concepts, protocol structure, and getting started with Aqua Protocol v4","sidebar_position":4,"icon":"git-commit-horizontal","content":"$12","reading_time":4,"word_count":686,"locale":"en"},"content":"$13"},{"slug":"en/dev-tools/aqua-cli","filePath":"dev-tools/aqua-cli","title":"Aqua CLI","meta":{"title":"Aqua CLI","description":"Install a binary for notarization and verification","icon":"terminal","content":"$14","reading_time":3,"word_count":406,"locale":"en"},"content":"$15","categoryLabel":"Development Tools","categoryPosition":3,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"wrench"},{"slug":"en/dev-tools/aqua-sdk","filePath":"dev-tools/aqua-sdk","title":"Aqua SDK","meta":{"title":"Aqua SDK","description":"A library for use in a code base for  notarization and verification","icon":"code","content":"$16","reading_time":2,"word_count":387,"locale":"en"},"content":"$17","categoryLabel":"Development Tools","categoryPosition":3,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"wrench"},{"slug":"en/dev-tools/aquafier-api","filePath":"dev-tools/aquafier-api","title":"Aquafier API","meta":{"title":"Aquafier API","description":" A http API for notarization and verification ","icon":"code","content":"$18","reading_time":3,"word_count":573,"locale":"en"},"content":"$19","categoryLabel":"Development Tools","categoryPosition":3,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"wrench"},{"slug":"en/schema-reference/revision/link-revision","filePath":"schema-reference/revision/link-revision","title":"Link Revision","meta":{"title":"Link Revision","description":"Schema specification for Link Revisions in Aqua Protocol v4","content":"$1a","reading_time":11,"word_count":2009,"locale":"en"},"content":"$1b","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/schema-reference/revision/object-revision","filePath":"schema-reference/revision/object-revision","title":"Object Revision","meta":{"title":"Object Revision","description":"Schema specification for Object Revisions in Aqua Protocol v4","content":"$1c","reading_time":6,"word_count":1048,"locale":"en"},"content":"$1d","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/schema-reference/revision/revision","filePath":"schema-reference/revision/revision","title":"Aqua Protocol Revisions","meta":{"title":"Aqua Protocol Revisions","description":"What is a revision , what maked up a revision ?","content":"$1e","reading_time":3,"word_count":461,"locale":"en"},"content":"$1f","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/schema-reference/revision/signing-revision","filePath":"schema-reference/revision/signing-revision","title":"Signature Revision","meta":{"title":"Signature Revision","description":"Schema specification for Signature Revisions in Aqua Protocol v4","content":"$20","reading_time":7,"word_count":1393,"locale":"en"},"content":"$21","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/schema-reference/revision/template-revision","filePath":"schema-reference/revision/template-revision","title":"Template Revision","meta":{"title":"Template Revision","description":"Schema specification for Template Revisions in Aqua Protocol v4","content":"$22","reading_time":7,"word_count":1369,"locale":"en"},"content":"$23","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/schema-reference/revision/witness-revision","filePath":"schema-reference/revision/witness-revision","title":"Witness Revision","meta":{"title":"Witness Revision","description":"Schema specification for Witness Revisions in Aqua Protocol v4","content":"$24","reading_time":9,"word_count":1682,"locale":"en"},"content":"$25","categoryLabel":"Revision Types","categoryPosition":4,"categoryCollapsible":true,"categoryCollapsed":true},{"slug":"en/use-cases/document-verification","filePath":"use-cases/document-verification","title":"Document Verification","meta":{"title":"Document Verification","description":"Aqua Protocol provides tamper-proof verification of document integrity through cryptographic proofs, enabling organizations to authenticate documents without relying on centralized authorities. Every document modification is timestamped and permanently recorded, creating an immutable audit trail.","content":"$26","reading_time":10,"word_count":1863,"locale":"en"},"content":"$27","categoryLabel":"Use Cases","categoryPosition":2,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"lightbulb"},{"slug":"en/use-cases/identity-attestation","filePath":"use-cases/identity-attestation","title":"Identity Attestation","meta":{"title":"Identity Attestation","description":"Establish trust with verifiable self-sovereign identity claims and attestations","content":"$28","reading_time":5,"word_count":865,"locale":"en"},"content":"$29","categoryLabel":"Use Cases","categoryPosition":2,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"lightbulb"},{"slug":"en/use-cases/introduction","filePath":"use-cases/introduction","title":"Aqua Protocol Use Cases","meta":{"title":"Aqua Protocol Use Cases","description":"Aqua Protocol provides cryptographic verification and provenance tracking for data across diverse industries and applications. By creating immutable chains of revisions with signatures and blockchain anchoring, Aqua enables trust without centralized authorities.","content":"$2a","reading_time":6,"word_count":1189,"locale":"en"},"content":"$2b","categoryLabel":"Use Cases","categoryPosition":2,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"lightbulb"},{"slug":"en/use-cases/supply-chain","filePath":"use-cases/supply-chain","title":"Supply Chain Tracking","meta":{"title":"Supply Chain Tracking","description":"End-to-end traceability and provenance verification for supply chain operations","content":"$2c","reading_time":12,"word_count":2274,"locale":"en"},"content":"$2d","categoryLabel":"Use Cases","categoryPosition":2,"categoryCollapsible":true,"categoryCollapsed":false,"categoryIcon":"lightbulb"}],"version":"v4.0.0","children":"$L2e","toc":"$L2f","config":{"site":{"title":"Aqua Protocol","description":"Open-source cryptographic trust infrastructure for the AI era — verifiable identity, access control, and tamper-proof provenance.","baseUrl":"/","language":"en","url":"https://aqua-protocol.org","organizationName":"inblockio","projectName":"aqua-docs","activeVersion":"v4.0.0","favicon":"/logo/aqua-logo.png","logo":{"dark":"/logo/aqua-logo.png","light":"/logo/aqua-logo.png"}},"theme":{"defaultMode":"system","respectPrefersColorScheme":true},"navigation":{"showSidebar":true,"collapsibleSidebar":true,"showBreadcrumbs":true,"showTableOfContents":true,"tocPosition":"right","tocMaxDepth":3},"search":{"enabled":false,"provider":"meilisearch","placeholder":"Search documentation...","meilisearch":{"host":"http://localhost:7700","apiKey":"aSampleMasterKey","indexName":"docs"}},"features":{"showLastUpdated":true,"showReadingTime":true,"showAuthors":false,"showTags":true,"versioning":true,"i18n":{"defaultLocale":"en","locales":["en"],"localeNames":{"en":"English"},"prefixDefault":true},"editUrl":"https://github.com/inblockio/aqua-docs/edit/main/docs"},"$schema":"./node_modules/specra/config/specra.config.schema.json","social":{"github":"https://github.com/inblockio","twitter":"https://x.com/inblockio","custom":[{"label":"Website","url":"https://dev.inblock.io"}]},"analytics":{"googleAnalytics":"","plausible":""},"footer":{"copyright":"Copyright © 2026 Aqua. All rights reserved.","links":[{"title":"Documentation","items":[{"label":"Getting Started","href":"/docs/v4.0.0/en/quickstart"},{"label":"API Reference","href":"/docs/v4.0.0/en/dev-tools/aquafier-api"}]},{"title":"Community","items":[{"label":"GitHub","href":"https://github.com/inblockio"}]}]},"banner":{"enabled":false,"message":"🎉 Aqua protocol - Let us build privacy infra together!","type":"error","dismissible":true},"env":{"AQUAFIER_URL":"https://aquafier.inblock.io"},"deployment":{"target":"github-pages","basePath":"","customDomain":true}}}],"$L30","$L31","$L32"]}],["$L33"],"$L34"]}],"loading":null,"isPartial":false}
2e:["$","article",null,{"className":"flex-1 min-w-0","children":[["$","nav",null,{"className":"flex items-center gap-2 text-sm text-muted-foreground mb-4","aria-label":"Breadcrumb","children":[["$","div","/docs/v4.0.0/en",{"className":"flex items-center gap-2","children":[false,["$","$L35",null,{"href":"/docs/v4.0.0/en","className":"hover:text-foreground transition-colors","children":"Docs"}]]}],["$","div","/docs/v4.0.0/en/dev-tools",{"className":"flex items-center gap-2","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right h-4 w-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","$L35",null,{"href":"/docs/v4.0.0/en/dev-tools","className":"hover:text-foreground transition-colors","children":"Dev Tools"}]]}],["$","div","/docs/v4.0.0/en/dev-tools/aqua-sdk",{"className":"flex items-center gap-2","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right h-4 w-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","span",null,{"className":"text-foreground font-medium","children":"Aqua SDK"}]]}]]}],false,["$","div",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-4xl font-bold tracking-tight mb-3 text-foreground","children":"Aqua SDK"}],["$","p",null,{"className":"text-lg text-muted-foreground leading-relaxed","children":"A library for use in a code base for  notarization and verification"}]]}],["$","div",null,{"className":"flex flex-wrap items-center gap-4 text-sm text-muted-foreground border-b border-border pb-4 mb-6","children":[["$","div",null,{"className":"flex items-center gap-1.5","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","children":[["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],["$","polyline","68esgv",{"points":"12 6 12 12 16 14"}],"$undefined"]}],["$","span",null,{"children":[2," min read"]}]]}],"$undefined",false]}],["$","div",null,{"className":"prose prose-slate dark:prose-invert max-w-none prose-headings:scroll-mt-24 prose-headings:font-semibold prose-h1:text-4xl prose-h2:text-3xl prose-h2:mt-12 prose-h2:mb-4 prose-h3:text-2xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-base prose-p:leading-7 prose-p:text-muted-foreground prose-p:mb-4 prose-a:font-normal prose-a:transition-all prose-code:text-primary prose-code:bg-muted/50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded-md prose-code:text-[13px] prose-code:font-mono prose-code:border prose-code:border-border/50 prose-code:before:content-none prose-code:after:content-none prose-pre:bg-transparent prose-pre:p-0 prose-ul:list-disc prose-ul:list-inside prose-ul:space-y-2 prose-ul:mb-4 prose-ol:list-decimal prose-ol:list-inside prose-ol:space-y-2 prose-ol:mb-4 prose-li:leading-7 prose-li:text-muted-foreground prose-strong:text-foreground prose-strong:font-semibold","children":[["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":["This Page contains sdk details of version 4 of the Aqua Protocol.To Use version 3 which is stable visit ",["$","a",null,{"href":"/docs/v4.0.0/quickstart","className":"text-primary hover:underline font-medium","children":"quickstart"}],"\nThe Aqua SDK is a Rust library that provides the core functionality for creating, signing, witnessing, and verifying Aqua Protocol chains. It supports Aqua Protocol v4 and includes WebAssembly (WASM) bindings for cross-platform compatibility."]}],"\n",["$","h2",null,{"id":"features","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Features"}],"\n","$L36","\n","$L37","\n","$L38","\n","$L39","\n","$L3a","\n","$L3b","\n","$L3c","\n","$L3d","\n","$L3e","\n","$L3f","\n","$L40","\n","$L41","\n","$L42","\n","$L43","\n","$L44","\n","$L45"]}],"$undefined","$L46","$L47"]}]
2f:["$","$L48",null,{"items":[{"id":"features","title":"Features","level":2},{"id":"installation","title":"Installation","level":2},{"id":"quick-example","title":"Quick Example","level":2},{"id":"use-cases","title":"Use Cases","level":2},{"id":"repository","title":"Repository","level":2},{"id":"documentation","title":"Documentation","level":2},{"id":"version","title":"Version","level":2}],"config":{"site":{"title":"Aqua Protocol","description":"Open-source cryptographic trust infrastructure for the AI era — verifiable identity, access control, and tamper-proof provenance.","baseUrl":"/","language":"en","url":"https://aqua-protocol.org","organizationName":"inblockio","projectName":"aqua-docs","activeVersion":"v4.0.0","favicon":"/logo/aqua-logo.png","logo":{"dark":"/logo/aqua-logo.png","light":"/logo/aqua-logo.png"}},"theme":{"defaultMode":"system","respectPrefersColorScheme":true},"navigation":{"showSidebar":true,"collapsibleSidebar":true,"showBreadcrumbs":true,"showTableOfContents":true,"tocPosition":"right","tocMaxDepth":3},"search":{"enabled":false,"provider":"meilisearch","placeholder":"Search documentation...","meilisearch":{"host":"http://localhost:7700","apiKey":"aSampleMasterKey","indexName":"docs"}},"features":{"showLastUpdated":true,"showReadingTime":true,"showAuthors":false,"showTags":true,"versioning":true,"i18n":{"defaultLocale":"en","locales":["en"],"localeNames":{"en":"English"},"prefixDefault":true},"editUrl":"https://github.com/inblockio/aqua-docs/edit/main/docs"},"$schema":"./node_modules/specra/config/specra.config.schema.json","social":{"github":"https://github.com/inblockio","twitter":"https://x.com/inblockio","custom":[{"label":"Website","url":"https://dev.inblock.io"}]},"analytics":{"googleAnalytics":"","plausible":""},"footer":{"copyright":"Copyright © 2026 Aqua. All rights reserved.","links":[{"title":"Documentation","items":[{"label":"Getting Started","href":"/docs/v4.0.0/en/quickstart"},{"label":"API Reference","href":"/docs/v4.0.0/en/dev-tools/aquafier-api"}]},{"title":"Community","items":[{"label":"GitHub","href":"https://github.com/inblockio"}]}]},"banner":{"enabled":false,"message":"🎉 Aqua protocol - Let us build privacy infra together!","type":"error","dismissible":true},"env":{"AQUAFIER_URL":"https://aquafier.inblock.io"},"deployment":{"target":"github-pages","basePath":"","customDomain":true}}}]
30:["$","$L49",null,{}]
31:["$","$L4a",null,{}]
32:["$","$L4b",null,{}]
33:["$","script","script-0",{"src":"/_next/static/chunks/9df80df1e0c22aa5.js","async":true}]
34:["$","$L4c",null,{"children":["$","$2",null,{"name":"Next.MetadataOutlet","children":"$@4d"}]}]
36:["$","ul",null,{"className":"list-disc list-outside pl-5 space-y-2 mb-4 text-muted-foreground [&_p]:mb-0 [&_p]:inline [&_ul]:ml-6 [&_ol]:ml-6","children":["\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Create Aqua Chains"}],": Build revision chains with objects, templates, signatures, witnesses, and links"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Template System"}],": Define and validate structured data using JSON Schema"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Multiple Signature Methods"}],": Support for RSA, Ethereum EIP-191, and DID:JWS signatures"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Blockchain Witnessing"}],": Anchor revisions to Ethereum (mainnet, Sepolia, Holesky), Nostr, or TSA"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Chain Verification"}],": Cryptographically verify complete revision chains"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Cross-Platform"}],": WASM support enables use in web browsers, Node.js, and native applications"]}],"\n"]}]
37:["$","h2",null,{"id":"installation","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Installation"}]
38:["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":"Add the SDK to your Rust project:"}]
39:["$","$L4e",null,{"code":"[dependencies]\naqua-rs-sdk = { git = \"https://github.com/inblockio/aqua-verifier-rs\" }","language":"toml","filename":"cargo.toml"}]
3a:["$","h2",null,{"id":"quick-example","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Quick Example"}]
4f:T6ab,    use aqua_rs_sdk::primitives::Method;
    use aqua_rs_sdk::schema::file_data::FileData;
    use aqua_rs_sdk::Aquafier;
    use std::path::PathBuf;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating Aqua chain...");

        // Read file content
        let filename = "test.txt".to_string();
        let file_content = tokio::fs::read(&filename).await?;

        // Create file data
        let file_data = FileData::new(
            filename.clone(),
            file_content,
            PathBuf::from(format!("./{}", filename)),
        );

        // Initialize Aquafier
        let aquafier = Aquafier::new(None, None);

        // Create genesis revision (notarize the file)
        let result = aquafier.create_genesis_revision(file_data, Method::Scalar);

        match result {
            Ok(tree) => {
                println!("✓ Aqua chain created successfully!");
                println!("{}", serde_json::to_string_pretty(&tree)?);

                println!("\nYou can now:");
                println!("- Add a signature revision");
                println!("- Witness on blockchain");
                println!("- Verify the chain");

                // Sign the revision
                // let signature = sign_revision(&object_revision, &signing_key)?;

                // Witness on blockchain
                // let witness = witness_revision(&signature, EthereumNetwork::Sepolia)?;

                // Verify the complete chain
                // let is_valid = verify_chain(&aqua_chain)?;

            }
            Err(e) => {
                eprintln!("Error: {:#?}", e);
            }
        }

        Ok(())
    }

3b:["$","$L4e",null,{"code":"$4f","language":"rust","filename":"main.rs"}]
3c:["$","h2",null,{"id":"use-cases","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Use Cases"}]
3d:["$","ul",null,{"className":"list-disc list-outside pl-5 space-y-2 mb-4 text-muted-foreground [&_p]:mb-0 [&_p]:inline [&_ul]:ml-6 [&_ol]:ml-6","children":["\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Application Integration"}],": Embed Aqua Protocol directly into your Rust applications"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Custom Tools"}],": Build specialized tools for specific workflows"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Smart Contracts"}],": Integrate with blockchain applications using WASM"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Web Applications"}],": Use WASM bindings to run in browsers"]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":[["$","strong",null,{"children":"Server Applications"}],": Build backend services with native Rust performance"]}],"\n"]}]
3e:["$","h2",null,{"id":"repository","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Repository"}]
3f:["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":[["$","strong",null,{"children":"GitHub"}],": ",["$","a",null,{"href":"https://github.com/inblockio/aqua-rs-sdk","className":"text-primary hover:underline font-medium","target":"_blank","rel":"noopener noreferrer","children":"github.com/inblockio/aqua-verifier-rs"}]]}]
40:["$","h2",null,{"id":"documentation","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Documentation"}]
41:["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":"For detailed API documentation, examples, and guides:"}]
42:["$","ul",null,{"className":"list-disc list-outside pl-5 space-y-2 mb-4 text-muted-foreground [&_p]:mb-0 [&_p]:inline [&_ul]:ml-6 [&_ol]:ml-6","children":["\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":["$","a",null,{"href":"/docs/v4.0.0/schema-reference/introduction","className":"text-primary hover:underline font-medium","children":"Schema Reference"}]}],"\n",["$","li",null,{"className":"leading-7 [&>p]:mb-0 [&>p]:inline","children":["$","a",null,{"href":"https://docs.rs/aqua-rs-sdk","className":"text-primary hover:underline font-medium","target":"_blank","rel":"noopener noreferrer","children":"API Documentation"}]}],"\n"]}]
43:["$","h2",null,{"id":"version","className":"text-2xl font-semibold tracking-tight mt-10 mb-4 text-foreground scroll-mt-24","children":"Version"}]
44:["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":[["$","strong",null,{"children":"Current Version"}],": 4.0.0 (Beta)"]}]
45:["$","p",null,{"className":"text-base leading-7 text-muted-foreground mb-4","children":["The SDK implements Aqua Protocol v4 with the template system and enhanced revision types. For production-stable implementations, consider the ",["$","a",null,{"href":"/docs/v3.0.2/tooling","className":"text-primary hover:underline font-medium","children":"JavaScript SDK (v3)"}],"."]}]
46:["$","div",null,{"className":"mt-12 pt-6 border-t border-border flex items-center justify-between","children":[["$","a",null,{"href":"https://github.com/inblockio/aqua-docs/edit/main/docs/v4.0.0/en/dev-tools/aqua-sdk.mdx","target":"_blank","rel":"noopener noreferrer","className":"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-file-pen h-4 w-4","children":[["$","path","1couwa",{"d":"M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5"}],["$","path","tnqrlb",{"d":"M14 2v4a2 2 0 0 0 2 2h4"}],["$","path","1y4qbx",{"d":"M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"}],"$undefined"]}],"Edit this page"]}],["$","a",null,{"href":"https://github.com/inblockio/issues/new","target":"_blank","rel":"noopener noreferrer","className":"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-external-link h-4 w-4","children":[["$","path","1q9fwt",{"d":"M15 3h6v6"}],["$","path","gplh6r",{"d":"M10 14 21 3"}],["$","path","a6xqqp",{"d":"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"}],"$undefined"]}],"Report an issue"]}]]}]
47:["$","div",null,{"className":"mt-12 pt-8 border-t border-border grid grid-cols-2 gap-4","children":[["$","$L35",null,{"href":"/docs/v4.0.0/en/dev-tools/aqua-cli","className":"group flex flex-col gap-2 p-4 rounded-xl border border-border hover:border-primary/50 hover:bg-muted/50 transition-all","style":{"textDecoration":"none !important"},"children":[["$","div",null,{"className":"flex items-center gap-2 text-sm text-muted-foreground","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-left h-4 w-4","children":[["$","path","1wnfg3",{"d":"m15 18-6-6 6-6"}],"$undefined"]}],["$","span",null,{"children":"Previous"}]]}],["$","div",null,{"className":"text-base font-medium text-foreground group-hover:text-primary transition-colors","children":"Aqua CLI"}]]}],["$","$L35",null,{"href":"/docs/v4.0.0/en/dev-tools/aquafier-api","className":"group flex flex-col gap-2 p-4 rounded-xl border border-border hover:border-primary/50 hover:bg-muted/50 transition-all text-right","style":{"textDecoration":"none !important"},"children":[["$","div",null,{"className":"flex items-center justify-end gap-2 text-sm text-muted-foreground","children":[["$","span",null,{"children":"Next"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right h-4 w-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}]]}],["$","div",null,{"className":"text-base font-medium text-foreground group-hover:text-primary transition-colors","children":"Aquafier API"}]]}]]}]
4d:null
