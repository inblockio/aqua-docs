1:"$Sreact.fragment"
2:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"ConfigProvider"]
3:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"TabProvider"]
4:I[339756,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"default"]
5:I[837457,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"default"]
6:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"Button"]
7:I[522016,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],""]
10:I[168027,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"default"]
:HL["/_next/static/chunks/a06cf6f745569492.css","style"]
:HL["/_next/static/chunks/a491150350dc0381.css","style"]
:HL["/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
0:{"P":null,"b":"jYB6lbiHIxAlWcwG_MhGb","c":["","docs","v2.0.2","introduction"],"q":"","i":false,"f":[[["",{"children":["docs",{"children":[["version","v2.0.2","d"],{"children":[["slug","introduction","c"],{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/chunks/a06cf6f745569492.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/chunks/a491150350dc0381.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/_next/static/chunks/eb22c92016909501.js","async":true,"nonce":"$undefined"}],["$","script","script-1",{"src":"/_next/static/chunks/c4a8b026e121e3ad.js","async":true,"nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"font-sans antialiased","children":["$","$L2",null,{"config":{"site":{"title":"Aqua Protocol","description":"Aqua","baseUrl":"/","language":"en","url":"https://aqua-protocol.org","organizationName":"inblockio","projectName":"aqua-docs","activeVersion":"v4.0.0","favicon":"/logo/aqua-logo.png","logo":"/logo/aqua-logo.png"},"theme":{"defaultMode":"system","respectPrefersColorScheme":true},"navigation":{"showSidebar":true,"collapsibleSidebar":true,"showBreadcrumbs":true,"showTableOfContents":true,"tocPosition":"right","tocMaxDepth":3},"search":{"enabled":false,"provider":"meilisearch","placeholder":"Search documentation...","meilisearch":{"host":"http://localhost:7700","apiKey":"aSampleMasterKey","indexName":"docs"}},"features":{"showLastUpdated":true,"showReadingTime":true,"showAuthors":false,"showTags":true,"versioning":true,"i18n":false,"editUrl":"https://github.com/inblockio/aqua-docs/edit/main/docs"},"$schema":"./lib/config.types.ts","social":{"github":"https://github.com/inblockio","twitter":"https://twitter.com/inblockio","custom":[{"label":"Website","href":"https://dev.inblock.io"}]},"analytics":{"googleAnalytics":"","plausible":""},"footer":{"copyright":"Copyright Â© 2024 Aqua. All rights reserved.","links":[{"title":"Documentation","items":[{"label":"Getting Started","href":"/docs/v1.0.0/getting-started"},{"label":"API Reference","href":"/docs/v1.0.0/api"}]},{"title":"Community","items":[{"label":"GitHub","href":"https://github.com/inblockio/aqua-docs"},{"label":"Discord","href":"#"}]}]},"banner":{"enabled":false,"message":"ðŸŽ‰ This is a development version. Some features may not work as expected.","type":"error","dismissible":true},"env":{},"deployment":{"target":"github-pages","basePath":"","customDomain":true}},"children":["$","$L3",null,{"defaultTab":"","children":["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","div",null,{"className":"min-h-screen bg-background flex items-center justify-center px-6","children":["$","div",null,{"className":"max-w-2xl mx-auto text-center space-y-6","children":[["$","div",null,{"className":"space-y-2","children":[["$","h1",null,{"className":"text-6xl md:text-8xl font-bold text-primary","children":"404"}],["$","h2",null,{"className":"text-2xl md:text-3xl font-semibold text-foreground","children":"Page Not Found"}]]}],["$","p",null,{"className":"text-muted-foreground text-lg max-w-md mx-auto","children":"The page you're looking for doesn't exist or may have been moved."}],["$","div",null,{"className":"flex flex-col sm:flex-row items-center justify-center gap-4 pt-6","children":[["$","$L6",null,{"asChild":true,"size":"lg","children":["$","$L7",null,{"href":"/","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-house mr-2 h-4 w-4","children":[["$","path","5wwlr5",{"d":"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"}],["$","path","1d0kgt",{"d":"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"}],"$undefined"]}],"Go to Homepage"]}]}],["$","$L6",null,{"asChild":true,"variant":"outline","size":"lg","children":["$","$L7",null,{"href":"/docs/v4.0.0/welcome","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left mr-2 h-4 w-4","children":["$L8","$L9","$undefined"]}],"View Documentation"]}]}]]}]]}]}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]}]]}],{"children":["$La",{"children":["$Lb",{"children":["$Lc",{"children":["$Ld",{},null,false,false]},["$Le",[],[]],false,false]},null,false,false]},null,false,false]},null,false,false],"$Lf",false]],"m":"$undefined","G":["$10",[]],"S":true}
11:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"VersionNotFound"]
13:I[897367,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"OutletBoundary"]
14:"$Sreact.suspense"
16:I[897367,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"ViewportBoundary"]
18:I[897367,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"MetadataBoundary"]
8:["$","path","1l729n",{"d":"m12 19-7-7 7-7"}]
9:["$","path","x3x0zl",{"d":"M19 12H5"}]
a:["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
b:["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L11",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]]}]
c:["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
d:["$","$1","c",{"children":["$L12",null,["$","$L13",null,{"children":["$","$14",null,{"name":"Next.MetadataOutlet","children":"$@15"}]}]]}]
e:["$","div","l",{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"}]}]
f:["$","$1","h",{"children":[null,["$","$L16",null,{"children":"$L17"}],["$","div",null,{"hidden":true,"children":["$","$L18",null,{"children":["$","$14",null,{"name":"Next.Metadata","children":"$L19"}]}]}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]
1a:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"DocLoading"]
1b:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"DocLayoutWrapper"]
1c:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"Header"]
1d:T75d,

## Introduction

The Aqua Protocol (AQP) is a data accountability and exchange protocol between hosts in peer-to-peer environments. The AQP is used to realize the goal of accounting for data origin and history (data provenance). Short: A verifiable linkable data structure to attest and certify data.

Issues for improving the protocol are tracked here: https://github.com/inblockio/aqua-improvement-proposal


## Motivation

In today's world, there are no widely adopted trustless processes of checking if
data have been manipulated or corrupted, are attributed to the wrong author, or
are attributed to the wrong time. Today's processes are dependent on centralized
trusted services which retain all power over governing the data.

There is a lack of transparency or ability to check if data have been altered
by an unauthorized party. Additionally, consumers of data are incapable of
verifying if centralized services have altered the data. This leads to a world
of untrustworthy information in which we don't know how to conclude what is
true.

In a world where every piece of information is a grain in a sandstorm, it has
become impossible to navigate reality. In contrast, in a world where every
piece of information is a fixed star in the sky for a lifetime, we are able to
relate and make sense of the information given. The Aqua Protocol (AQP) turns
grains of information into fixed stars of information.

The AQP adds a peer-to-peer layer of accountability, making it impossible to
change data unnoticed. AQP adds an essential line of defense against attacks on
data integrity, plagiarism, or misattribution. AQP is used to govern trusted
data, which can be quickly verified. This includes the verification of its
integrity and history, the verification of its account (the entity who creates
or manipulates the data), and the verification of its existence and timestamp.

1e:T75d,

## Introduction

The Aqua Protocol (AQP) is a data accountability and exchange protocol between hosts in peer-to-peer environments. The AQP is used to realize the goal of accounting for data origin and history (data provenance). Short: A verifiable linkable data structure to attest and certify data.

Issues for improving the protocol are tracked here: https://github.com/inblockio/aqua-improvement-proposal


## Motivation

In today's world, there are no widely adopted trustless processes of checking if
data have been manipulated or corrupted, are attributed to the wrong author, or
are attributed to the wrong time. Today's processes are dependent on centralized
trusted services which retain all power over governing the data.

There is a lack of transparency or ability to check if data have been altered
by an unauthorized party. Additionally, consumers of data are incapable of
verifying if centralized services have altered the data. This leads to a world
of untrustworthy information in which we don't know how to conclude what is
true.

In a world where every piece of information is a grain in a sandstorm, it has
become impossible to navigate reality. In contrast, in a world where every
piece of information is a fixed star in the sky for a lifetime, we are able to
relate and make sense of the information given. The Aqua Protocol (AQP) turns
grains of information into fixed stars of information.

The AQP adds a peer-to-peer layer of accountability, making it impossible to
change data unnoticed. AQP adds an essential line of defense against attacks on
data integrity, plagiarism, or misattribution. AQP is used to govern trusted
data, which can be quickly verified. This includes the verification of its
integrity and history, the verification of its account (the entity who creates
or manipulates the data), and the verification of its existence and timestamp.

1f:T2bb7,


## Data Structure:
This are the basics to get you started but for a thorough understanding one done with the sections below have a look at references section to  get a thorough understanding for example what is a witness, wtness network and how are witness hash created.

The aqua chain structure can be broken into a the following components : 


### Revision

A revision is the smallest portable entity within the AQP. Multiple revisions
form a single portable hash chain which is serialized in JSON format.
They have existed before in unsecured systems where multiple revisions form a
file which can be displayed as a page. The AQP adds the cryptographic harness
to secure it. With presenting a portable hash chain, it is possible to track
all incremental changes stored in each revision to understand the history of a
page and how it came to be. This allows us to have version control on digital
assets being able to restore earlier states and to relate to them. This allows
us to have historical evidence of digital assets.
<br/>

Every revision is represented by a merkle-root hash representing a list of alphabetically ordered key-value pairs which are hashed (implementation example SHA3-512). This allows us to dynamically change the data structure without the need to introduce breaking protocol changes.

  * The input data MUST NOT have dublicated keys as this would lead to non-deterministic ordering.

Aqua-Chain: Is a portable hash-chain. This provides immutability for the history of the file, once signed and/or witnessed with the respective security guarantees.
Aqua-revisions form a portable Aqua-Chain.

There are 4 Types of Revisions:
  * Content Revision: Contains the data object(the data/file encoded to base 64).This is used to secure the data integrity and reference the data object for provenance purposes. 
  * Signature Revision: Is used to cryptographically sign, we are currently supporting  Ethereum signatures.
  * Witness Revision: Used to witness the Hash to prove its existence. We are supporting Ethereum by default.
  * Metadata Revision: used to ensure content revision is valid.



### Page

A page is a visible representation of a file containing multiple or a single
revision attributed to a shared origin. A page view could also be used to
create a new revision by a used service which interfaces with the file for
manipulation. In AQP all revisions share a global URI hash to
attribute them together called a genesis hash.



### Witness

We define witnessing as the process of observing an event. A witness is judged
by their capability to recollect and share an observed event. In other words,
witnessing is the process of storing input data for later playback to provide
data symmetry around an event.

### Witness Network

The digital service in a distributed ledger or similar infrastructure which
provides transaction security and data symmetry for shared data within the
network. An example of a witness network would be Ethereum.

E.g. Ethereum can be used to store a digital fingerprint of a domain snapshot
of a data vault. A domain snapshot is the Merklized state of all witnessed hash
chains being present in the data vault. It is required to pay the witness
network for its service. In the case of Ethereum, this is done using 'Ether'.
This in return allows the account owner to create an 'undeniable' proof that a
specific revision and the previous revisions within a hash chain has existed.


### Signature

A signature in AQP is a cryptographic signature generated by public-private key pair. The protocol should be abstract, where it will support â€˜Methodâ€™ in later iterations. This will allow us to use different types of implementations such as: `PGP signatures`, `Ethereum`, or `Bitcoin wallet â€™s` signatures.

In this specification, we use the AQP reference implementationâ€™s signing method, which is via an Ethereum wallet.

```js
signature_hash = calculate_hash_sum(
    signature + public_key
)
```

The signature is generated by a wallet signing the following message:

```
I sign the following page verification_hash:" +[0x0x9dab72<revision_verification_hash>]
```


### Wallet
A wallet is a software for protecting and managing private cryptographic keys
(of private-public key pairs) which are used to govern digital assets. This is
done by authorization of transactions via digital signatures or by initiating
decryption processes to access data.

See [Separation of Concerns](design-principles.md#separation-of-account-and-service).

### Account

We are following Ethereum's account definition:
> In general, there are two types of accounts. Externally owned accounts,
> controlled by private keys. And contract accounts, controlled by their
> contract code
-- [Ethereum Whitepaper](https://ethereum.org/en/whitepaper/#ethereum-accounts)

In general, we can't prove if an account owner is a person or a machine. With
advancements in AI, it will become increasingly difficult to prove that a human
is a human. [Attempts are being made](https://www.proofofhumanity.id/) to
increase trustworthiness of accounts which fall short in questions of privacy
and security as they make public claims. Traditional know your customer (KYC)
combined with the AQP and Aqua Identity Protocol (AIP) identification processes
can provide similar "proof of being human" which can be attested to an account.
This allows us to outsource the problem of identification, where we only focus
on unique accounts which are sufficient for data accounting independent of
humans or machines. Identity claims issued via the AIP will help to provide the
context required to meaningfully interact between accounts.

For more on this topic, please read the [Aqua Identity
Protocol](aqua-identity-protocol.md).

### Domain
A domain is a unique namespace attributed to an account. It allows us to manage
services and files within that namespace creating a domain of data governance
After granted permissions, additional accounts can be added to share control
over a domain or singular assets. To enforce boundaries of a domain, additional
software like the [Guardian](guardian.md) is required.

E.g. by setting up the a data vault with your account it becomes your
domain of data governance.



### Transaction Security

Transaction security is an economic measure of the level of integrity assurance
for a transaction. It is defined as the cost required to forge a transaction.
The transaction security can be increased by cryptographic security and by strong
replication of transactions. Public distributed ledger systems are highly suitable
for providing very high level of transaction security at the cost of privacy
and immutability (data can't be changed or deleted). Today, public distributed
ledgers such as Bitcoin and Ethereum provide the highest level of transaction
security.

### Data Asset

Data turns into a valuable asset if it is accounted for. In an accounted form
it can be easily priced, exchanged or traded.

### Data Vault

Software used to store and manage data with an account. The software must apply
a secure architecture and measures for keeping data assets safe. This is
achieved through encryption, strong authentication and restrictive access to
keep data private by default.

See [Design Principles / Separation of Account and
Service](design-principles.md#separation-of-account-and-service)



### Metadata

```
metadata_hash = calculate_hash_sum(
    domain_id + time_stamp + previous_verification_hash
)
```

Description:
- metadata_hash: The check sum for all metadata data fields. It simplifies the
  hash construction and the ability to identify data corrupton in this part of
  the verification structure.
- domain_id: 10 digits hexadecimal randomly generated to identify the host
  system that runs the AQP service.
- time_stamp: time-stamp of the current revision (decimal numbers
  YYYYMMDDHHMMSS e.g. 20211128092608).
- previous_verification_hash: previous_revision_verification_hash if present



### Witness

Witnessing allows one to undeniably prove the existence of a dataset
(represented as a portable hash chain). To complete the witnessing process, a
Domain Snapshot is created. This is a collection of all revision hashes within
one domain. A Merkle tree is used to unify all hashes of the latest revisions
of all portable hash chains within a domain into a single hash value.

The `witness_event_verification_hash` is written to the [Witness
Network](#witness-network). The
`witness_event_verification_hash` is then generated by using the
`domain_snapshot_genesis_hash` and the `merkle_root` hash together. This
allows the page snapshot itself to also be witnessed.

A single revision which has been witnessed, will not store the whole Merkle
tree, but only its relevant path to the Merkle root. Performing a Merkle proof
means that its revision is included in the Merkle tree.

```
witness_hash = calculate_hash_sum(
    domain_snapshot_genesis_hash + merkle_root +
    witness_network + witness_event_transaction_hash
)
```


### Witness network
We are using the Ethereum Network as an optional Witness Network for
cryptographic time-stamping.

### Encryption
according to wikipedia
```
In cryptography, encryption (more specifically, encoding) is the process of transforming information in a way that, ideally, only authorized parties can decode. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Despite its goal, encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.

```

### Hash
according to investopedia

```
A hash is a mathematical function that converts an input of arbitrary length into an encrypted output of a fixed length. Thus, regardless of the original amount of data or file size involved, its unique hash will always be the same size. Moreover, secure hashes cannot be "reverse-engineered" to get the input from the hashed output, at least with current technology.

If you use a specific function on the same data, its hash will be identical, so you can validate that the data is the same (i.e., unaltered) if you already know its hash. A different function would deliver a different hash.

```

### Verification Process

The verification process is a redo of the verification data generation
process, and additionally a comparison of their results.

**Verification of Content**

All hashes are recalculated in a separate client implementation, and
compared with the ones sent via the API. If the data was not altered or
corrupted; nor was there a difference in the process to calculate the
hash, they will match. This will create a high level of assurance that
the integrity and history of the portable hash chain in question has not been
altered.

**Verification of Account**

We cryptographically verify that the revision signature is indeed generated by the account specified in the verification data.

**Verification of Time**

To verify that the witness event included in a revision is correct, a
lookup and comparison of the `witness_event_verification_hash` on-chain is
performed and compared with the recalculated event.
20:T2bb7,


## Data Structure:
This are the basics to get you started but for a thorough understanding one done with the sections below have a look at references section to  get a thorough understanding for example what is a witness, wtness network and how are witness hash created.

The aqua chain structure can be broken into a the following components : 


### Revision

A revision is the smallest portable entity within the AQP. Multiple revisions
form a single portable hash chain which is serialized in JSON format.
They have existed before in unsecured systems where multiple revisions form a
file which can be displayed as a page. The AQP adds the cryptographic harness
to secure it. With presenting a portable hash chain, it is possible to track
all incremental changes stored in each revision to understand the history of a
page and how it came to be. This allows us to have version control on digital
assets being able to restore earlier states and to relate to them. This allows
us to have historical evidence of digital assets.
<br/>

Every revision is represented by a merkle-root hash representing a list of alphabetically ordered key-value pairs which are hashed (implementation example SHA3-512). This allows us to dynamically change the data structure without the need to introduce breaking protocol changes.

  * The input data MUST NOT have dublicated keys as this would lead to non-deterministic ordering.

Aqua-Chain: Is a portable hash-chain. This provides immutability for the history of the file, once signed and/or witnessed with the respective security guarantees.
Aqua-revisions form a portable Aqua-Chain.

There are 4 Types of Revisions:
  * Content Revision: Contains the data object(the data/file encoded to base 64).This is used to secure the data integrity and reference the data object for provenance purposes. 
  * Signature Revision: Is used to cryptographically sign, we are currently supporting  Ethereum signatures.
  * Witness Revision: Used to witness the Hash to prove its existence. We are supporting Ethereum by default.
  * Metadata Revision: used to ensure content revision is valid.



### Page

A page is a visible representation of a file containing multiple or a single
revision attributed to a shared origin. A page view could also be used to
create a new revision by a used service which interfaces with the file for
manipulation. In AQP all revisions share a global URI hash to
attribute them together called a genesis hash.



### Witness

We define witnessing as the process of observing an event. A witness is judged
by their capability to recollect and share an observed event. In other words,
witnessing is the process of storing input data for later playback to provide
data symmetry around an event.

### Witness Network

The digital service in a distributed ledger or similar infrastructure which
provides transaction security and data symmetry for shared data within the
network. An example of a witness network would be Ethereum.

E.g. Ethereum can be used to store a digital fingerprint of a domain snapshot
of a data vault. A domain snapshot is the Merklized state of all witnessed hash
chains being present in the data vault. It is required to pay the witness
network for its service. In the case of Ethereum, this is done using 'Ether'.
This in return allows the account owner to create an 'undeniable' proof that a
specific revision and the previous revisions within a hash chain has existed.


### Signature

A signature in AQP is a cryptographic signature generated by public-private key pair. The protocol should be abstract, where it will support â€˜Methodâ€™ in later iterations. This will allow us to use different types of implementations such as: `PGP signatures`, `Ethereum`, or `Bitcoin wallet â€™s` signatures.

In this specification, we use the AQP reference implementationâ€™s signing method, which is via an Ethereum wallet.

```js
signature_hash = calculate_hash_sum(
    signature + public_key
)
```

The signature is generated by a wallet signing the following message:

```
I sign the following page verification_hash:" +[0x0x9dab72<revision_verification_hash>]
```


### Wallet
A wallet is a software for protecting and managing private cryptographic keys
(of private-public key pairs) which are used to govern digital assets. This is
done by authorization of transactions via digital signatures or by initiating
decryption processes to access data.

See [Separation of Concerns](design-principles.md#separation-of-account-and-service).

### Account

We are following Ethereum's account definition:
> In general, there are two types of accounts. Externally owned accounts,
> controlled by private keys. And contract accounts, controlled by their
> contract code
-- [Ethereum Whitepaper](https://ethereum.org/en/whitepaper/#ethereum-accounts)

In general, we can't prove if an account owner is a person or a machine. With
advancements in AI, it will become increasingly difficult to prove that a human
is a human. [Attempts are being made](https://www.proofofhumanity.id/) to
increase trustworthiness of accounts which fall short in questions of privacy
and security as they make public claims. Traditional know your customer (KYC)
combined with the AQP and Aqua Identity Protocol (AIP) identification processes
can provide similar "proof of being human" which can be attested to an account.
This allows us to outsource the problem of identification, where we only focus
on unique accounts which are sufficient for data accounting independent of
humans or machines. Identity claims issued via the AIP will help to provide the
context required to meaningfully interact between accounts.

For more on this topic, please read the [Aqua Identity
Protocol](aqua-identity-protocol.md).

### Domain
A domain is a unique namespace attributed to an account. It allows us to manage
services and files within that namespace creating a domain of data governance
After granted permissions, additional accounts can be added to share control
over a domain or singular assets. To enforce boundaries of a domain, additional
software like the [Guardian](guardian.md) is required.

E.g. by setting up the a data vault with your account it becomes your
domain of data governance.



### Transaction Security

Transaction security is an economic measure of the level of integrity assurance
for a transaction. It is defined as the cost required to forge a transaction.
The transaction security can be increased by cryptographic security and by strong
replication of transactions. Public distributed ledger systems are highly suitable
for providing very high level of transaction security at the cost of privacy
and immutability (data can't be changed or deleted). Today, public distributed
ledgers such as Bitcoin and Ethereum provide the highest level of transaction
security.

### Data Asset

Data turns into a valuable asset if it is accounted for. In an accounted form
it can be easily priced, exchanged or traded.

### Data Vault

Software used to store and manage data with an account. The software must apply
a secure architecture and measures for keeping data assets safe. This is
achieved through encryption, strong authentication and restrictive access to
keep data private by default.

See [Design Principles / Separation of Account and
Service](design-principles.md#separation-of-account-and-service)



### Metadata

```
metadata_hash = calculate_hash_sum(
    domain_id + time_stamp + previous_verification_hash
)
```

Description:
- metadata_hash: The check sum for all metadata data fields. It simplifies the
  hash construction and the ability to identify data corrupton in this part of
  the verification structure.
- domain_id: 10 digits hexadecimal randomly generated to identify the host
  system that runs the AQP service.
- time_stamp: time-stamp of the current revision (decimal numbers
  YYYYMMDDHHMMSS e.g. 20211128092608).
- previous_verification_hash: previous_revision_verification_hash if present



### Witness

Witnessing allows one to undeniably prove the existence of a dataset
(represented as a portable hash chain). To complete the witnessing process, a
Domain Snapshot is created. This is a collection of all revision hashes within
one domain. A Merkle tree is used to unify all hashes of the latest revisions
of all portable hash chains within a domain into a single hash value.

The `witness_event_verification_hash` is written to the [Witness
Network](#witness-network). The
`witness_event_verification_hash` is then generated by using the
`domain_snapshot_genesis_hash` and the `merkle_root` hash together. This
allows the page snapshot itself to also be witnessed.

A single revision which has been witnessed, will not store the whole Merkle
tree, but only its relevant path to the Merkle root. Performing a Merkle proof
means that its revision is included in the Merkle tree.

```
witness_hash = calculate_hash_sum(
    domain_snapshot_genesis_hash + merkle_root +
    witness_network + witness_event_transaction_hash
)
```


### Witness network
We are using the Ethereum Network as an optional Witness Network for
cryptographic time-stamping.

### Encryption
according to wikipedia
```
In cryptography, encryption (more specifically, encoding) is the process of transforming information in a way that, ideally, only authorized parties can decode. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Despite its goal, encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.

```

### Hash
according to investopedia

```
A hash is a mathematical function that converts an input of arbitrary length into an encrypted output of a fixed length. Thus, regardless of the original amount of data or file size involved, its unique hash will always be the same size. Moreover, secure hashes cannot be "reverse-engineered" to get the input from the hashed output, at least with current technology.

If you use a specific function on the same data, its hash will be identical, so you can validate that the data is the same (i.e., unaltered) if you already know its hash. A different function would deliver a different hash.

```

### Verification Process

The verification process is a redo of the verification data generation
process, and additionally a comparison of their results.

**Verification of Content**

All hashes are recalculated in a separate client implementation, and
compared with the ones sent via the API. If the data was not altered or
corrupted; nor was there a difference in the process to calculate the
hash, they will match. This will create a high level of assurance that
the integrity and history of the portable hash chain in question has not been
altered.

**Verification of Account**

We cryptographically verify that the revision signature is indeed generated by the account specified in the verification data.

**Verification of Time**

To verify that the witness event included in a revision is correct, a
lookup and comparison of the `witness_event_verification_hash` on-chain is
performed and compared with the recalculated event.
21:T1683,
# Aqua Protocol Tooling & Components

This document provides a comprehensive overview of all the tools and components available in the Aqua Protocol ecosystem version 1.2.

## Aqua CLI

Aqua CLI is a command line utility that enables you to create, verify, witness, and sign aqua chains. There are two implementations available:

### Rust Implementation (Recommended)

The Rust CLI is the stable implementation and the recommended choice for getting started with the Aqua protocol.

**Installation:**
- Via cargo: `cargo install aqua-cli`
- Building from source:
  ```bash
  git clone git@github.com:inblockio/aqua-cli-rs.git
  cargo build --release
  cd target/release/ && cp aqua-cli /usr/bin
  ```

**Repository:** https://github.com/inblockio/aqua-cli-rs

**Key Features:**
- Verify aqua chain JSON files
- Generate aqua chains
- Generate validation reports
- Sign and witness aqua chains

**Available Commands:**
- `-a` or `--authenticate`: Verify an aqua JSON file
- `-s` or `--sign`: Sign an aqua JSON file
- `-w` or `--witness`: Witness an aqua JSON file
- `-f` or `--file`: Generate an aqua JSON file
- `-v` or `--verbose`: Provide logs about the process
- `-o` or `--output`: Save output to file (JSON, HTML, or PDF)
- `-l` or `--level`: Define validation strictness (1 or 2)
- `-d` or `--delete`: Remove revision from an aqua JSON file
- `-c` or `--count`: Specify number of revisions to remove

**Environment Variables:**
- `aqua_domain`: Random alphanumeric value
- `aqua_network`: "sepolia", "holesky", or "mainnet"
- `verification_platform`: "alchemy", "infura", or "none" (default: "none")
- `aqua_alchemy_look_up`: true or false

**Example Usage:**
```bash
aqua-cli -a chain.json
aqua-cli -s chain.json --output report.json
aqua-cli -w chain.json --output report.json
aqua-cli -f document.pdf
aqua-cli --file image.png --verbose
```

### JavaScript Implementation

The JavaScript implementation is used to quickly prototype ideas.

**Repository:** https://github.com/inblockio/aqua-verifier-js

:::warning
If you are just getting started, use the Rust CLI. The JS version is primarily used to prototype ideas.
:::

**Environment Setup:**
1. Install Node.js (latest version)
2. Ensure you have Yarn or npm installed

**Installation:**
```bash
git clone git@github.com:inblockio/aqua-cli-js.git
cd aqua-cli-js && npm i && npm build
```

**Configuration:**
Create a `credentials.json` file with the following structure:
```json
{
    "mnemonic": "sample sample sample sample sample sample sample sample sample sample sample author matter",
    "nostr_sk": "xxxxxxxxxxxxxxxx",
    "did:key": "xxxxxxxxxxxxxx"
}
```

**Usage Commands:**

**Notarize:**
```bash
./notarize.js [OPTIONS] <filename>
```
Options:
- `--sign [cli|metamask|did]`: Sign with Ethereum seed phrase, MetaMask, or DID key
- `--witness-eth`: Witness to Ethereum on-chain with MetaMask
- `--witness-nostr`: Witness to Nostr network
- `--witness-tsa`: Witness to TSA DigiCert
- `--link <filename.aqua.json>`: Add a link to an AQUA chain as a dependency

**Verify:**
```bash
./verify.js [OPTIONS] <page title>
# or
./verify.js [OPTIONS] --file <offline file.json or file.xml>
```
Options:
- `-v`: Verbose
- `--server`: The URL of the server (e.g., https://pkc.inblock.io)
- `--ignore-merkle-proof`: Ignore verifying the witness merkle proof
- `--file`: The file to read from for the data

## Aqua Container (Aquafier)

Aqua Container is a Rust web application with a React frontend that implements the Aqua protocol. It enables data to be signed, witnessed, and verified through a web browser interface.

**Try it online:** https://aquafire.aqua-protocol.org/

**Technical Details:**
- Backend: Axum web server in Rust
- Frontend: React (TypeScript)
- Database: SQLite with Diesel ORM
- Communication: HTTP protocol
- File size limit: 20 MB maximum
- Docker container available for quick deployment

**Repository:** https://github.com/inblockio/aqua-verifier-rs

The container is built using the same libraries as the CLI, providing all CLI capabilities with a graphical interface.

## Aqua Verifier (Chrome Extension)

The Aqua Verifier is a Chrome extension that can be used to verify aqua chains directly in your browser. This is the easiest and fastest way to get started with the Aqua protocol.

**Installation:** Available on the [Chrome Web Store](https://chromewebstore.google.com/detail/verifypage/gadnjidhhadchnegnpadkibmjlgihiaj)

## Personal Knowledge Container (PKC)

The Personal Knowledge Container was a prototype implementation of Aqua protocol v1.1.

:::note
For information about PKC, please refer to version 1.1 documentation.
:::

## Aqua Guardian

Aqua Guardian is a security gateway designed to exchange Aqua-Chains and enforce policies of Aqua-Contracts. It provides secure connectivity between Guardians and verifies the integrity of Aqua storage containers.

:::warning
The Aqua Guardian still uses Aqua protocol version 1.1, making it incompatible with protocol 1.2 and all tools that use protocol 1.2 (such as Aqua Container and Aqua CLI).
:::

## Why Two CLI Implementations?

The JavaScript implementation enables rapid prototyping of new ideas, while the Rust implementation provides stability and production-ready features. This dual approach allows the team to experiment quickly while maintaining a reliable tool for end users.

## Getting Started

For most users, we recommend starting with either:
1. **Aqua Verifier Chrome Extension** - For the quickest and easiest start
2. **Aqua CLI (Rust)** - For command-line users who want full control
3. **Aqua Container Sandbox** - For a web-based graphical interface

All tools support the core Aqua protocol operations: creating, signing, witnessing, and verifying aqua chains to ensure data integrity.
22:T1683,
# Aqua Protocol Tooling & Components

This document provides a comprehensive overview of all the tools and components available in the Aqua Protocol ecosystem version 1.2.

## Aqua CLI

Aqua CLI is a command line utility that enables you to create, verify, witness, and sign aqua chains. There are two implementations available:

### Rust Implementation (Recommended)

The Rust CLI is the stable implementation and the recommended choice for getting started with the Aqua protocol.

**Installation:**
- Via cargo: `cargo install aqua-cli`
- Building from source:
  ```bash
  git clone git@github.com:inblockio/aqua-cli-rs.git
  cargo build --release
  cd target/release/ && cp aqua-cli /usr/bin
  ```

**Repository:** https://github.com/inblockio/aqua-cli-rs

**Key Features:**
- Verify aqua chain JSON files
- Generate aqua chains
- Generate validation reports
- Sign and witness aqua chains

**Available Commands:**
- `-a` or `--authenticate`: Verify an aqua JSON file
- `-s` or `--sign`: Sign an aqua JSON file
- `-w` or `--witness`: Witness an aqua JSON file
- `-f` or `--file`: Generate an aqua JSON file
- `-v` or `--verbose`: Provide logs about the process
- `-o` or `--output`: Save output to file (JSON, HTML, or PDF)
- `-l` or `--level`: Define validation strictness (1 or 2)
- `-d` or `--delete`: Remove revision from an aqua JSON file
- `-c` or `--count`: Specify number of revisions to remove

**Environment Variables:**
- `aqua_domain`: Random alphanumeric value
- `aqua_network`: "sepolia", "holesky", or "mainnet"
- `verification_platform`: "alchemy", "infura", or "none" (default: "none")
- `aqua_alchemy_look_up`: true or false

**Example Usage:**
```bash
aqua-cli -a chain.json
aqua-cli -s chain.json --output report.json
aqua-cli -w chain.json --output report.json
aqua-cli -f document.pdf
aqua-cli --file image.png --verbose
```

### JavaScript Implementation

The JavaScript implementation is used to quickly prototype ideas.

**Repository:** https://github.com/inblockio/aqua-verifier-js

:::warning
If you are just getting started, use the Rust CLI. The JS version is primarily used to prototype ideas.
:::

**Environment Setup:**
1. Install Node.js (latest version)
2. Ensure you have Yarn or npm installed

**Installation:**
```bash
git clone git@github.com:inblockio/aqua-cli-js.git
cd aqua-cli-js && npm i && npm build
```

**Configuration:**
Create a `credentials.json` file with the following structure:
```json
{
    "mnemonic": "sample sample sample sample sample sample sample sample sample sample sample author matter",
    "nostr_sk": "xxxxxxxxxxxxxxxx",
    "did:key": "xxxxxxxxxxxxxx"
}
```

**Usage Commands:**

**Notarize:**
```bash
./notarize.js [OPTIONS] <filename>
```
Options:
- `--sign [cli|metamask|did]`: Sign with Ethereum seed phrase, MetaMask, or DID key
- `--witness-eth`: Witness to Ethereum on-chain with MetaMask
- `--witness-nostr`: Witness to Nostr network
- `--witness-tsa`: Witness to TSA DigiCert
- `--link <filename.aqua.json>`: Add a link to an AQUA chain as a dependency

**Verify:**
```bash
./verify.js [OPTIONS] <page title>
# or
./verify.js [OPTIONS] --file <offline file.json or file.xml>
```
Options:
- `-v`: Verbose
- `--server`: The URL of the server (e.g., https://pkc.inblock.io)
- `--ignore-merkle-proof`: Ignore verifying the witness merkle proof
- `--file`: The file to read from for the data

## Aqua Container (Aquafier)

Aqua Container is a Rust web application with a React frontend that implements the Aqua protocol. It enables data to be signed, witnessed, and verified through a web browser interface.

**Try it online:** https://aquafire.aqua-protocol.org/

**Technical Details:**
- Backend: Axum web server in Rust
- Frontend: React (TypeScript)
- Database: SQLite with Diesel ORM
- Communication: HTTP protocol
- File size limit: 20 MB maximum
- Docker container available for quick deployment

**Repository:** https://github.com/inblockio/aqua-verifier-rs

The container is built using the same libraries as the CLI, providing all CLI capabilities with a graphical interface.

## Aqua Verifier (Chrome Extension)

The Aqua Verifier is a Chrome extension that can be used to verify aqua chains directly in your browser. This is the easiest and fastest way to get started with the Aqua protocol.

**Installation:** Available on the [Chrome Web Store](https://chromewebstore.google.com/detail/verifypage/gadnjidhhadchnegnpadkibmjlgihiaj)

## Personal Knowledge Container (PKC)

The Personal Knowledge Container was a prototype implementation of Aqua protocol v1.1.

:::note
For information about PKC, please refer to version 1.1 documentation.
:::

## Aqua Guardian

Aqua Guardian is a security gateway designed to exchange Aqua-Chains and enforce policies of Aqua-Contracts. It provides secure connectivity between Guardians and verifies the integrity of Aqua storage containers.

:::warning
The Aqua Guardian still uses Aqua protocol version 1.1, making it incompatible with protocol 1.2 and all tools that use protocol 1.2 (such as Aqua Container and Aqua CLI).
:::

## Why Two CLI Implementations?

The JavaScript implementation enables rapid prototyping of new ideas, while the Rust implementation provides stability and production-ready features. This dual approach allows the team to experiment quickly while maintaining a reliable tool for end users.

## Getting Started

For most users, we recommend starting with either:
1. **Aqua Verifier Chrome Extension** - For the quickest and easiest start
2. **Aqua CLI (Rust)** - For command-line users who want full control
3. **Aqua Container Sandbox** - For a web-based graphical interface

All tools support the core Aqua protocol operations: creating, signing, witnessing, and verifying aqua chains to ensure data integrity.
12:["$","$14",null,{"fallback":["$","$L1a",null,{}],"children":[["$","$L1b",null,{"header":["$","$L1c",null,{"currentVersion":"v2.0.2","versions":["v1.1.0","v2.0.2","v3.0.2","v4.0.0"],"config":"$0:f:0:1:0:props:children:1:props:children:props:children:props:config"}],"docs":[{"slug":"introduction","filePath":"introduction","title":"Prologue","meta":{"title":"Prologue","linkTitle":"prologue","sidebar_position":1,"weight":10,"menu":{"main":{"weight":10}},"content":"$1d","reading_time":2,"word_count":296},"content":"$1e"},{"slug":"concepts","filePath":"concepts","title":"Concepts","meta":{"title":"Concepts","description":"An of the terms used in version 2 of the protocol","content":"$1f","reading_time":9,"word_count":1684},"content":"$20"},{"slug":"tooling","filePath":"tooling","title":"Aqua Protocol Tooling & Components","meta":{"title":"Aqua Protocol Tooling & Components","description":"Overview of Aqua Protocol v1.2 tools and components","content":"$21","reading_time":4,"word_count":796},"content":"$22"}],"version":"v2.0.2","children":"$L23","toc":"$L24","config":"$0:f:0:1:0:props:children:1:props:children:props:children:props:config","currentPageTabGroup":"$undefined"}],"$L25","$L26","$L27"]}]
28:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"DocLayout"]
2b:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"TableOfContents"]
2c:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"MdxHotReload"]
2d:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"HotReloadIndicator"]
2e:I[931024,["/_next/static/chunks/eb22c92016909501.js","/_next/static/chunks/c4a8b026e121e3ad.js"],"DevModeBadge"]
29:T75d,

## Introduction

The Aqua Protocol (AQP) is a data accountability and exchange protocol between hosts in peer-to-peer environments. The AQP is used to realize the goal of accounting for data origin and history (data provenance). Short: A verifiable linkable data structure to attest and certify data.

Issues for improving the protocol are tracked here: https://github.com/inblockio/aqua-improvement-proposal


## Motivation

In today's world, there are no widely adopted trustless processes of checking if
data have been manipulated or corrupted, are attributed to the wrong author, or
are attributed to the wrong time. Today's processes are dependent on centralized
trusted services which retain all power over governing the data.

There is a lack of transparency or ability to check if data have been altered
by an unauthorized party. Additionally, consumers of data are incapable of
verifying if centralized services have altered the data. This leads to a world
of untrustworthy information in which we don't know how to conclude what is
true.

In a world where every piece of information is a grain in a sandstorm, it has
become impossible to navigate reality. In contrast, in a world where every
piece of information is a fixed star in the sky for a lifetime, we are able to
relate and make sense of the information given. The Aqua Protocol (AQP) turns
grains of information into fixed stars of information.

The AQP adds a peer-to-peer layer of accountability, making it impossible to
change data unnoticed. AQP adds an essential line of defense against attacks on
data integrity, plagiarism, or misattribution. AQP is used to govern trusted
data, which can be quickly verified. This includes the verification of its
integrity and history, the verification of its account (the entity who creates
or manipulates the data), and the verification of its existence and timestamp.

2a:T75d,

## Introduction

The Aqua Protocol (AQP) is a data accountability and exchange protocol between hosts in peer-to-peer environments. The AQP is used to realize the goal of accounting for data origin and history (data provenance). Short: A verifiable linkable data structure to attest and certify data.

Issues for improving the protocol are tracked here: https://github.com/inblockio/aqua-improvement-proposal


## Motivation

In today's world, there are no widely adopted trustless processes of checking if
data have been manipulated or corrupted, are attributed to the wrong author, or
are attributed to the wrong time. Today's processes are dependent on centralized
trusted services which retain all power over governing the data.

There is a lack of transparency or ability to check if data have been altered
by an unauthorized party. Additionally, consumers of data are incapable of
verifying if centralized services have altered the data. This leads to a world
of untrustworthy information in which we don't know how to conclude what is
true.

In a world where every piece of information is a grain in a sandstorm, it has
become impossible to navigate reality. In contrast, in a world where every
piece of information is a fixed star in the sky for a lifetime, we are able to
relate and make sense of the information given. The Aqua Protocol (AQP) turns
grains of information into fixed stars of information.

The AQP adds a peer-to-peer layer of accountability, making it impossible to
change data unnoticed. AQP adds an essential line of defense against attacks on
data integrity, plagiarism, or misattribution. AQP is used to govern trusted
data, which can be quickly verified. This includes the verification of its
integrity and history, the verification of its account (the entity who creates
or manipulates the data), and the verification of its existence and timestamp.

23:["$","$L28",null,{"meta":{"title":"Prologue","linkTitle":"prologue","sidebar_position":1,"weight":10,"menu":"$12:props:children:0:props:docs:0:meta:menu","content":"$29","reading_time":2,"word_count":296},"content":"$2a","previousDoc":"$undefined","nextDoc":{"title":"Concepts","slug":"concepts"},"version":"v2.0.2","slug":"introduction","config":"$0:f:0:1:0:props:children:1:props:children:props:children:props:config"}]
24:["$","$L2b",null,{"items":[{"id":"introduction","title":"Introduction","level":2},{"id":"motivation","title":"Motivation","level":2}],"config":"$0:f:0:1:0:props:children:1:props:children:props:children:props:config"}]
25:["$","$L2c",null,{}]
26:["$","$L2d",null,{}]
27:["$","$L2e",null,{}]
17:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
2f:I[27201,["/_next/static/chunks/d96012bcfc98706a.js","/_next/static/chunks/963c71eec1d89c3f.js"],"IconMark"]
15:null
19:[["$","title","0",{"children":"Prologue | Aqua Protocol"}],["$","meta","1",{"name":"description","content":"Documentation for Prologue"}],["$","link","2",{"rel":"canonical","href":"https://aqua-protocol.org/docs/v2.0.2/introduction"}],["$","meta","3",{"property":"og:title","content":"Prologue"}],["$","meta","4",{"property":"og:description","content":"Documentation for Prologue"}],["$","meta","5",{"property":"og:url","content":"https://aqua-protocol.org/docs/v2.0.2/introduction"}],["$","meta","6",{"property":"og:site_name","content":"Documentation Platform"}],["$","meta","7",{"property":"og:locale","content":"en_US"}],["$","meta","8",{"property":"og:type","content":"article"}],["$","meta","9",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","10",{"name":"twitter:title","content":"Prologue"}],["$","meta","11",{"name":"twitter:description","content":"Documentation for Prologue"}],["$","link","12",{"rel":"icon","href":"/logo/aqua-logo.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/apple-icon.png"}],["$","$L2f","14",{}]]
